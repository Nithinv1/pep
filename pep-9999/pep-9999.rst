PEP:	9999
Title:	Flat multi-nested iterators
Author:	Yamato Nagata <gey3933 at gmail.com>
Status:	Draft
Type:	Standards Track
Python-Version: 3.6
Created:	11-Apr-2018
Post-History:	

Abstract
========

This proposal is supposed to make nested list, tuple, set and other
thing which contains value flat more easier.


Rationale
=========


itertools.chain.from_iterable is easy to use, but it can only used to
flat 1 nested --not nested elements are not supported--. So I thought
we need another function.


Specification
=============

Code is below::

    def flatten(iterables, unpack=(list, tuple, set), peep=(list, tuple, set)):
        for element in iterables:
            if isinstance(element, unpack) and isinstance(element, peep):
                yield from flatten(element, unpack=unpack, peep=peep)
            elif isinstance(element, unpack):
                yield from flatten(element, unpack=(), peep=())
            elif isinstance(element, peep):
                yield type(element)(flatten(element, unpack=unpack, peep=peep))
            else:
                yield element

This returns the generator which generate the value that nested in "unpack" --default 
is list/tuple/set-- is unpacked. And this won't unpack the type only in "peep". if 

* if type in "unpack" and "peep": It will be unpacked and the inner element will be unpacked.

* if type in "unpack" but not in "peep": It will be unpacked and the inner element will be unpacked.

* if type not in "unpack" but in "peep": Current element won't be unpacked, but inner elements 
  will be unpacked.

* if type not in "unpack" and not in "peep": Current element will yield as given.

example::

    def flatten(iterables, unpack=(list, tuple, set), peep=(list, tuple, set)):
        for element in iterables:
            if isinstance(element, unpack) and isinstance(element, peep):
                yield from flatten(element, unpack=unpack, peep=peep)
            elif isinstance(element, unpack):
                yield from flatten(element, unpack=(), peep=())
            elif isinstance(element, peep):
                yield type(element)(flatten(element, unpack=unpack, peep=peep))
            else:
                yield element

Why This Must Use "unpack"
''''''''''''''''''''''''''
There is a way to substitute of use of "unpack". I thought first this code::

    def flatten(iterables):
        for element in iterables:
            try:
                if iter(element) and type(element) != str:
                    yield from flatten(element, unpack=unpack)
                else:
                    rase TypeError
            except TypeError:
                    yield element

But, this unpacks other class, for example "range", too. So I made user can 
change "which class to unpack".(and "!= str" is not beautiful)

And this functions can't handle user-defined functions.



How This works
==============

some examples here::
    >>> def flatten(iterables, unpack=(list, tuple, set), peep=(list, tuple, set)):
    ...     for element in iterables:
    ...         if isinstance(element, unpack) and isinstance(element, peep):
    ...             yield from flatten(element, unpack=unpack, peep=peep)
    ...         elif isinstance(element, unpack):
    ...             yield from flatten(element, unpack=(), peep=())
    ...         elif isinstance(element, peep):
    ...             yield type(element)(flatten(element, unpack=unpack, peep=peep))
    ...         else:
    ...             yield element
    ...
    >>> val = [1, 2, [3, 4, {5, 6, (7,)}, 8], [9], range(10, 13)]
    >>> ret = list(flatten(val))
    >>> ret
    [1, 2, 3, 4, 7, 5, 6, 8, 9, range(10, 13)]  # range is not unpacked
    >>>
    >>> ret = list(flatten(val, unpack=(list)))
    >>> ret
    [1, 2, 3, 4, {(7,), 5, 6}, 8, 9, range(10, 13)]  # only list were unpacked
    >>>
    >>> ret = list(flatten(val, unpack=(list, tuple), peep=(list, tuple)))
    >>> ret
    [1, 2, 3, 4, {(7,), 5, 6}, 8, 9, range(10, 13)]  # can't unpack anything
    >>>
    >>> ret = list(flatten(val, unpack=(tuple)))
    >>> ret
    [1, 2, [3, 4, {5, 6, 7}, 8], [9], range(10, 13)]  # only tuple were unpacked
    >>>
    >>> ret = list(flatten(val, unpack=(list, set, tuple, range)))
    >>> ret
    [1, 2, 3, 4, 7, 5, 6, 8, 9, 10, 11, 12]  # everything include range were unpacked



Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 50
   coding: utf-8
   End: