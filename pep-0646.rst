PEP: 646
Title: Variadic Generics
Author: Mark Mendoza <mendoza.mark.a@gmail.com>,
        Matthew Rahtz <mrahtz@google.com>,
        Pradeep Kumar Srinivasan <gohanpra@gmail.com>,
        Vincent Siles <vsiles@fb.com>
Sponsor: Guido van Rossum <guido@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 16-Sep-2020
Python-Version: 3.10
Post-History: 07-Oct-2020, 23-Dec-2020, 29-Dec-2020

Abstract
========

PEP 484 introduced ``TypeVar``, enabling creation of generics parameterised
with a single type. In this PEP, we introduce ``TypeVarTuple``, enabling parameterisation
with an *arbitrary* number of types - that is, a *variadic* type variable,
enabling *variadic* generics. This allows the type of array-like structures
in numerical computing libraries such as NumPy and TensorFlow to be
parameterised with the array *shape*, enabling static type checkers
to catch shape-related bugs in code that uses these libraries.

Motivation
==========

In the context of numerical computation with libraries such as NumPy and
TensorFlow, the *shape* of arguments is often just as important as the
argument *type*. For example, consider the following function which converts a
batch [#batch]_ of videos to grayscale:

::

    def to_gray(videos: Array): ...

From the signature alone, it is not obvious what shape of array [#array]_
we should pass for the ``videos`` argument. Possibilities include, for
example,

  batch × time × height × width × channels

and

  time × batch × channels × height × width. [#timebatch]_

Ideally, we should have some way of making the required shape clear in the
signature itself. Multiple proposals [#numeric-stack]_ [#typing-ideas]_
[#syntax-proposal]_ have suggested the use of the standard generics syntax for
this purpose. We would write:

::

    def to_gray(videos: Array[Time, Batch, Height, Width, Channels]): ...

However, note that arrays can be of arbitrary rank - ``Array`` as used above is
generic in an arbitrary number of axes. One way around this would be to use a different
``Array`` class for each rank...

::

    Axis1 = TypeVar('Axis1')
    Axis2 = TypeVar('Axis2')

    class Array1(Generic[Axis1]): ...

    class Array2(Generic[Axis1, Axis2]): ...

...but this would be cumbersome, both for users (who would have to sprinkle 1s and 2s
and so on throughout their code) and for the authors of array libraries (who would have to duplicate implementations throughout multiple classes).

Variadic generics are necessary for a ``Array`` that is generic in an arbitrary
number of axes to be cleanly defined as a single class.

Specification
=============

In order to support the above use-cases, we introduce ``TypeVarTuple``. This serves as a placeholder not for a single type but for an *arbitrary* number of types, and behaving like a number of ``TypeVar`` instances packed in a ``Tuple``.

These are described in detail below.

Type Variable Tuples
--------------------

In the same way that a normal type variable is a stand-in for a single type,
a type variable *tuple* is a stand-in for an arbitrary number of types (zero or
more) in a flat ordered list.

Type variable tuples are created with:

::

    from typing import TypeVarTuple

    Ts = TypeVarTuple('Ts')

As a first example of how type variable tuples are used, consider a generic
class parameterized using a type variable tuple:

::

    Shape = TypeVarTuple('Shape')

    class Array(Generic[Shape]): ...

    Height = NewType('Height', int)
    Width = NewType('Width', int)
    shape = (Height(480), Width(640))
    x: Array[Height, Width] = Array()

Note that the type variable behaves like a sequence of individual ``TypeVar``
instances. That is, we could also have defined ``Array`` as:

::

    Axis1 = TypeVar('Shape1')
    Axis2 = TypeVar('Shape2')

    class Array(Generic[Axis1, Axis2]): ...

However, this ``Array`` could only access two type parameters, whereas the original
``Array`` could accept an *arbitrary* number of type parameters.

Type variable tuples can be used anywhere a normal ``TypeVar`` can.
This includes class definitions, as shown above, and function signatures:

::

    class Array(Generic[Shape]):

        def __abs__(self) -> Array[Shape]: ...

        def __add__(self, other: Array[Shape]) -> Array[Shape]) ...

    x: Array[Height, Width] = Array()
    y = abs(x)  # Inferred type of y is Array[Height, Width]
    z = x + x   #        ...       z is Array[Height, Width]

Type variable tuples can also be used as variable annotations directly,
but note that since ``x: Axis1, Axis2`` would not be a valid annotation,
neither is ``x: Shape``. Instead, the type variable tuple must be wrapped
in a ``Tuple`` as ``x: Tuple[Shape]`` (though see
```*args`` as a Type Variable Tuple` for one exception):

::

    class Array(Generic[Shape]):

        def __init__(self, shape: Tuple[Shape]):
            self._shape: Tuple[Shape] = shape

        def get_shape(self) -> Tuple[Shape]:
            return self._shape

    x: Array[Height, Width] = Array(shape)
    s = x.get_shape()  # Inferred type is Tuple[Height, Width]

Multiple Type Variable Tuples: Not Allowed
''''''''''''''''''''''''''''''''''''''''''

Note that as of this PEP (that is, we may update this rule in future PEPs), only a single type variable tuple may appear in a type parameter list:

::

    Ts1 = TypeVarTuple('Ts1')
    Ts2 = TypeVarTuple('Ts2')

    class Array(Generic[Ts1, Ts2]): ...  # Error

Variance, Type Constraints and Type Bounds: Not (Yet) Supported
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

To keep this PEP minimal, ``TypeVarTuple`` does not yet support specification of:

* Variance (e.g. ``TypeVar('T', covariant=True)``)
* Type constraints (``TypeVar('T', int, float)``)
* Type bounds (``TypeVar('T', bound=ParentClass)``)

We leave the decision of how these arguments should behave to a future PEP, when variadic generics have been tested 'in the field'.

Behaviour when Type Parameters are not Specified
''''''''''''''''''''''''''''''''''''''''''''''''

TODO: plain ``Tensor`` behaves like ``Tensor[Any, ...]``

``*args`` as a Type Variable Tuple
----------------------------------

PEP 484 states that when a type annotation is provided for ``*args``, each argument
must be of the type annotated. That is, if we specify ``*args`` to be type ``int``,
then *all* arguments must be of type ``int``. This limits our ability to specify
the type signatures of functions that take heterogeneous argument types.

If ``*args`` is annotated as an instance of a type variable tuple, however, the
types of the individual arguments become the types in the type variable tuple:

::

    Ts = TypeVarTuple('Ts')
    
    def args_to_tuple(*args: Ts) -> Tuple[Ts]: ...

    args_to_tuple(1, 'a')  # Inferred type is Tuple[int, str]

Note that this behaves *only* applies when ``*args`` is annotation as a
'raw' type variable tuple. If the type variable tuple is wrapped in a
``Tuple``, the old behaviour still applies, and all arguments must be a
tuple of the same types:

::

    def foo(*args: Tuple[Ts]) -> Tuple[Ts]): ...

    foo((1, 'a'), (2, 'b'))       # Valid; inferred type is Tuple[int, str]
    foo((1, 'a'), (True, False))  # Error

Finally, note that a type variable tuple may *not* be used as the type of
``**kwargs``. (We do not yet know of a use-case for this feature, so we prefer
to leave the ground fresh for a potential future PEP.)

::

    # NOT valid
    def foo(**kwargs: Ts): ...


Type Variable Tuples with ``Callable``
--------------------------------------

Type variable tuples can also be used in the arguments section of a
``Callable``:

::

    class Process:
      def __init__(
        target: Callable[[Ts], Any],
        args: Tuple[Ts]
      ): ...

    def func(arg1: int, arg2: str): ...
    
    Process(target=func, args=(0, 'foo'))  # Valid
    Process(target=func, args=('foo', 0))  # Error

However, note that as of this PEP, if a type variable tuple does appear in
the arguments section, it must appear alone. That is, `Type Prefixing` is not
supported.

Type Variable Tuples with ``Union``
-----------------------------------

Finally, type variable tuples can be used with ``Union``:

::
    
    def f(*args: Ts) -> Union[Ts]:
        return random.choice(args)

    f(1, 'foo')  # Inferred type is Union[int, str]

If the type variable tuple is empty (e.g. if we had ``*args: Ts``
and didn't pass any arguments), the type checker should
raise an error on the ``Union`` (matching the behaviour of ``Union``
at runtime, which requires at least one type argument).

Overloads for Accessing Individual Types
----------------------------------------

For situations where we require access to each individual type, overloads can be used with individual ``TypeVar`` instances in place of the type variable tuple:

::

    Shape = TypeVarTuple('Shape')
    Axis1 = TypeVar('Axis1')
    Axis2 = TypeVar('Axis2')
    Axis3 = TypeVar('Axis3')

    class Array(Generic[Shape]): ...

      @overload
      def transpose(
        self: Array[Axis1, Axis2]
      ) -> Array[Axis2, Axis1]: ...

      @overload
      def transpose(
        self: Array[Axis1, Axis2, Axis3)
      ) -> Array[Axis3, Axis2, Axis1]: ...

(For array shape operations in particular, having to specify
overloads for each possible rank is, of course, a rather cumbersome
solution. However, it's the best we can do without additional type
manipulation mechanisms, which are beyond the scope of this PEP.)

Type Prefixing
--------------

Normal types can be prefixed to a type variable tuple:

::
    Shape = TypeVarTuple('Shape')
    class Batch: pass

    def add_batch_axis(x: Array[Shape]) -> Array[Batch, Shape]: ...
    def del_batch_axis(x: Array[Batch, Shape]) -> Array[Shape]: ...

    x: Array[Height, Width]
    y = add_batch(x)  # Inferred type is Array[Batch, Height, Width]
    z = del_batch(y)  # Array[Height, Width]

Normal ``TypeVar`` instances can also be prefixed:

::

    T = TypeVar('T')
    Ts = TypeVarTuple('Ts')

    def prefix_tuple(
        x: T,
        y: Tuple[Ts]
    ) -> Tuple[T, Ts]: ...

    z = prefix_tuple(x=0, y=(True, 'a'))
    # Inferred type of z is Tuple[int, bool, str]

As of this PEP - that is, we may expand the flexibility of concatenation in future PEPS - prefixing of one type variable tuple to another is *not* supported, and prefixing is the only form of concatenation supported.

Aliases
-------

Generic aliases can be created using a type variable tuple in
a similar way to regular type variables:

::

    IntTuple = Tuple[int, Ts]
    IntTuple[float, bool]  # Equivalent to Tuple[int, float, bool]

As this example shows, all type arguments passed to the alias are
bound to the type variable tuple. If no type arguments are given,
the type variable tuple holds no types:

::

    IntTuple  # Equivalent to Tuple[int]

Normal ``TypeVar`` instances can also be used in such aliases:

::
    T = TypeVar('T')
    Foo = Tuple[T, Ts]

    # T is bound to `int`; Ts is bound to `bool, str`
    Foo[int, bool, str]

Note that the same rules for `Type Prefixing` apply for aliases.
In particular, only one ``TypeVarTuple`` may occur within an alias,
and the ``TypeVarTuple`` must be at the end of the alias.

An Ideal Array Type: One Possible Example
=========================================

Type variable tuples allow us to make significant progress on the
typing of arrays. However, the array class we have sketched
out in this PEP is still missing some desirable features. [#typing-ideas]_

The most crucial feature missing is the ability to specify
the data type (e.g. ``np.float32`` or ``np.uint8``). This is important
because some numerical computing libraries will silently cast
types, which can easily lead to hard-to-diagnose bugs.

Additionally, it might be useful to be able to specify the rank
instead of the full shape. This could be useful for cases where
axes don't have obvious semantic meaning like 'height' or 'width',
or where the array is very high-dimensional and writing out all
the axes would be too verbose.

Here is one possible example of how these features might be implemented
in a complete array type.

::

    # E.g. Ndim[Literal[3]]
    Integer = TypeVar('Integer')
    class Ndim(Generic[Integer]): ...

    # E.g. Shape[Height, Width]
    # (Where Height and Width are custom types)
    Axes = TypeVarTuple('Axes')
    class Shape(Generic[Axes]): ...

    DataType = TypeVar('DataType')
    ShapeType = TypeVar('ShapeType', NDim, Shape)

    # The most verbose type
    # E.g. Array[np.float32, Ndim[Literal[3]]
    #      Array[np.uint8, Shape[Height, Width, Channels]]
    class Array(Generic[DataType, ShapeType]): ...

    # Type aliases for less verbosity
    # E.g. Float32Array[Height, Width, Channels]
    Float32Array = Array[np.float32, Shape[Axes]]
    # E.g. Array1D[np.uint8]
    Array1D = Array[DataType, Ndim[Literal[1]]]

Rationale and Rejected Ideas
============================

Supporting Variadicity Through aliases
--------------------------------------

As noted in the introduction, it **is** possible to avoid variadic generics
by simply defining aliases for each possible number of type parameters:

::

    class Array1(Generic[Axis1]): ...
    class Array2(Generic[Axis1, Axis2]): ...

However, this seems somewhat clumsy - it requires users to unnecessarily
pepper their code with 1s, 2s, and so on for each rank necessary.

Naming of ``TypeVarTuple``
--------------------------

``TypeVarTuple`` began as ``ListVariadic``, based on its naming in
an early implementation in Pyre.

We then changed this to ``TypeVar(list=True)``, on the basis that a)
it better emphasises the similarity to ``TypeVar``, and b) the meaning
of 'list' is more easily understood than the jargon of 'variadic'.

We finally settled on ``TypeVarTuple`` based on the justification
that c) this emphasises the tuple-like behaviour, and d) type variable
tuples are a sufficiently different kind of thing to regular
type variables that we may later wish to support keyword arguments
to its constructor that should not be supported by regular
type variables (such as ``arbitrary_len`` [#arbitrary_len]_).

Backwards Compatibility
=======================

TODO

* ``Tuple`` needs to be upgraded to support parameterization with a
  a type variable tuple.


Reference Implementation
========================

TODO

Footnotes
==========


.. [#batch] 'Batch' is machine learning parlance for 'a number of'.

.. [#array] We use the term 'array' to refer to a matrix with an arbitrary
   number of dimensions. In NumPy, the corresponding class is the ``ndarray``;
   in TensorFlow, the ``Tensor``; and so on.

.. [#timebatch] If the shape begins with 'batch × time', then
   ``videos_batch[0][1]`` would select the second frame of the first video. If the
   shape begins with 'time × batch', then ``videos_batch[1][0]`` would select the
   same frame.

References
==========

.. [#pep-612] PEP 612, "Parameter Specification Variables":
   https://www.python.org/dev/peps/pep-0612

.. [#numeric-stack] Static typing of Python numeric stack:
   https://paper.dropbox.com/doc/Static-typing-of-Python-numeric-stack-summary-6ZQzTkgN6e0oXko8fEWwN

.. [#typing-ideas] Ideas for array shape typing in Python: https://docs.google.com/document/d/1vpMse4c6DrWH5rq2tQSx3qwP_m_0lyn-Ij4WHqQqRHY/edit

.. [#syntax-proposal] Shape annotation syntax proposal:
   https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit

.. [#arbitrary_len] Discussion on Python typing-sig mailing list: https://mail.python.org/archives/list/typing-sig@python.org/thread/SQVTQYWIOI4TIO7NNBTFFWFMSMS2TA4J/


Acknowledgements
================

Thank you to **Alfonso Castaño**, **Antoine Pitrou**, **Bas v.B.**, **David Foster**, **Dimitris Vardoulakis**, **Eric Traut**, **Guido van Rossum**, **Jia Chen**,
**Lucio Fernandez-Arjona**, **Nikita Sobolev**, **Peilonrayz**, **Rebecca Chen**,
**Sergei Lebedev** and **Vladimir Mikulik** for helpful feedback and suggestions on
drafts of this PEP.

Resources
=========

Discussions on variadic generics in Python started in 2016 with `Issue 193`__
on the python/typing GitHub repository.

__ https://github.com/python/typing/issues/193

Inspired by this discussion, **Ivan Levkivskyi** made a concrete proposal
at PyCon 2019, summarised in `Type system improvements`__
and `Static typing of Python numeric stack`__.

__ https://paper.dropbox.com/doc/Type-system-improvements-HHOkniMG9WcCgS0LzXZAe

__ https://paper.dropbox.com/doc/Static-typing-of-Python-numeric-stack-summary-6ZQzTkgN6e0oXko8fEWwN

Expanding on these ideas, **Mark Mendoza** and **Vincent Siles** gave a presentation on
`Variadic Type Variables for Decorators and Tensors`__ at the 2019 Python
Typing Summit.

__ https://github.com/facebook/pyre-check/blob/ae85c0c6e99e3bbfc92ec55104bfdc5b9b3097b2/docs/Variadic_Type_Variables_for_Decorators_and_Tensors.pdf

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

