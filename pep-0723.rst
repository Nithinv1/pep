PEP: 723
Title: Embedding metadata in single-file scripts
Author: Ofek Lev <ofekmeister@gmail.com>
PEP-Delegate: Brett Cannon <brett@python.org>
Discussions-To: https://discuss.python.org/t/29905
Status: Draft
Type: Standards Track
Topic: Packaging
Content-Type: text/x-rst
Created: 04-Aug-2023
Post-History: `19-Jul-2023 <https://discuss.python.org/t/29905>`__


Abstract
========

This PEP specifies a format for defining metadata about single-file Python
scripts, such as their runtime dependencies. This PEP merely extends
:pep:`722` with an alternative format and therefore elides describing the
motivation for such a proposal.

Specification
=============

This PEP chooses to follow the latest developments of other modern packaging
ecosystems (namely `Rust <https://github.com/rust-lang/rfcs/blob/master/text/3424-cargo-script.md>`__
and `Go <https://github.com/erning/gorun>`__) by embedding the existing
standard :pep:`621` that is used to describe projects.

Any Python script may assign a variable named ``__pyproject__`` to a multi-line
double-quoted string containing a valid TOML document. This document contains
what you would expect to see in a ``pyproject.toml`` file, with the following
exceptions regarding the ``[project]`` table:

* The ``name`` and ``version`` fields MUST be defined dynamically by tools if
  the user does not define them
* These fields do not need to be listed in the ``dynamic`` array

Example
-------

The following is an example of a script with an embedded ``pyproject.toml``:

.. code:: python

    __pyproject__ = """
    [project]
    requires-python = ">=3.11"
    dependencies = [
      "requests<3",
      "rich",
    ]
    """

    import requests
    from rich.pretty import pprint

    resp = requests.get("https://peps.python.org/api/peps.json")
    data = resp.json()
    pprint([(k, v["title"]) for k, v in data.items()][:10])


Reference Implementation
========================

This regular expression may be used to parse the metadata::

    (?ms)^__pyproject__ *= *"""$(.+?)^"""$

For languages that do not support easily accessing the match group, one may
parse the entire match as TOML and then access the ``__pyproject__`` key.

The following is an example of how to read the metadata on Python 3.11 or
higher.

.. code:: python

    import re, tomllib

    def read(script: str) -> dict | None:
        match = re.search(r'(?ms)^__pyproject__ *= *"""$(.+?)^"""$', script)
        return tomllib.loads(match.group(1)) if match else None

Often tools will provide commands to manage dependencies. The following is a
crude example of modifying the content using the ``tomlkit`` library.

.. code:: python

    import re, tomlkit

    def add(script: str, dependency: str) -> str:
        match = re.search(r'(?ms)^__pyproject__ *= *"""$(.+?)^"""$', script)
        config = tomlkit.parse(match.group(1))
        config['project']['dependencies'].append(dependency)

        start, end = match.span(1)
        return script[:start] + tomlkit.dumps(config) + script[end:]


Backwards Compatibility
=======================

At the time of writing, ``__pyproject__`` only appears 5 times
`on GitHub <https://github.com/search?q=__pyproject__&type=code>`__ and 4 of
those belong to a user who appears to already be using this PEP's format
for its intended purpose.


How to Teach This
=================

The format is intended to bridge the gap between users just writing scripts and
users writing packages. Knowledge of how to write metadata for one use case will
be directly transferable to the other.

Everything in the parent PEP regarding teaching is applicable to this as well.


Recommendations
===============

For situations in which users do not define the required name and version
fields, the following defaults should be preferred:

* ``name``: ``script-<sha256 of script's path>`` e.g. ``script-3a5c6b...`` to
  provide interoperability with other tools that use the name to derive file
  system storage paths for things like virtual environments
* ``version``: ``0.0.0``


Benefits
========

Ecosystem cohesion
------------------

One of the central themes we discovered from the recent
`packaging survey <https://discuss.python.org/t/22420>`__ is that users have
begun getting frustrated with the lack of unification regarding both tooling
and specs.

Adding yet another way to define metadata would further fragment the community.


Extensibility
-------------

The parent PEP allows for extensions to the custom metadata block format. This
PEP benefits from all future extensions to project metadata and immediately
supports the 2 hypothetical examples that were mentioned:

* versioning - It is quite common to version scripts for persistence even when
  using a VCS like Git. When not using a VCS it is even more common to version,
  for example the author has been in multiple time sensitive debugging sessions
  with customers where due to the airgapped nature of the environment, the only
  way to transfer the script was via email or copying and pasting it into a
  chat window. In these cases, versioning is invaluable to ensure that the
  customer is using the latest version of the script.
* Python runtime requirements - This is useful for tools that are able to run
  specific versions of Python.


Broader applicability
---------------------

This PEP does not prohibit any class of tooling from using embedded metadata
if they so desire and envisions support to be ubiquitous across the ecosystem.
In addition to script runners, one would expect:

* IDEs to provide TOML syntax highlighting
* Dependency version checkers and security scanners to verify and offer updates
  to scripts
* Package managers like Hatch and Poetry to gain the ability to run scripts

Open Issues
===========

None at this point.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
