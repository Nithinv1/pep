PEP: 9999
Title: A metadata format for entry points
Author: KOLANICH <for the email look into git commit information>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 29-Jul-2020
Python-Version: 3.9
Post-History: 


Abstract
========

In this PEP we propose a format for annotating entry points with metadata, available before actually loading an entry point, which mitigates some resource consumption, security and legal issues.


Motivation
==========

Entry points [1]_ provide a mechanism for python packages to implement a plugin syste. While one currently can expose the needed metadata via a custom API defined specially for your plugin system, it poses differrent issues related to the fact one may not want to load the plugin at all depending on various conditions:

* plugins can be just unneeded for your case, so it may be redundant to execute their initialization code.
* plugins can be licensed under restrictive licenses. There is a practice to license software depending on usage of a certain optional dependency, for example if a library A can optionally use a GPL-licensed library G, without satisfying the condition making A a derivative work of G (G provides some non-essentioal additional functonality), authors often license A under a dual license, a permissive one on the condition that G is not used and GPL for the case it is used. But loading a GPL-licensed module depending on G to just retrieve its metadata will require A to be licensed under GPL.
* calling an entry point may be insecure depending o some conditions.
* entry point can require the caller to provide it with some information in the form of function call arguments.
* different ways to retrieve metadata can have impact on software processing the metadata of python packages in generic ways.

All these issues can be solved using a standardized metadata format.

Specification
=============

The proposed new entry point declaration format is 

::
    <entry point name>@<JSON-serialized metadata> = <package name>:<function name>

where <JSON-serialized metadata> can be anything that can be serialized into JSON. In complying implementations of `pkg_resources` it is available as a `metadata` attribute of an `pkg_resources.EntryPoint` object. If the metadata is absent, its attribute is set to `None`.

For the purpose of this spec, everything in between the first `@` and last `=` is considered to be `<JSON-serialized metadata>`.

If `<JSON-serialized metadata>` is not a well-formed JSON, the implementation MUST fall-back to the legacy behavior, setting the name as if it was generated by the previous versions of `pkg_resources` and set `metadata` to `None`.


Backwards Compatibility
=======================
The legacy entry points description format was 

::
    <entry point name> = <package name>:<function name>

.

The proposal doesn't restrict the set of well-formed entry points names. But it changes the interpretation of some of them. More precisely, all the names having `@` within them followed by a well-formed JSON will require changes. But such names look like a way to recreate the metadata system used in this PEP, and their authors should probably modify their code in order to use it. Other uses for names won't require changes in the code.


Forward Compatibility
=======================

Entry point name can contain special characters. We exploit this fact, legacy implementations of `pkg_resources`, that can be detected by absence of `metadata` attribute, consider the metadata as a part of a name: `<entry point name>@<JSON-serialized metadata>`, which can be parsed manually by the software supporting such legacy versions of `pkg_resources` using the straightforward code

.. code-block:: python
    if hasattr(ep.__class__, "__slots__") and "metadata" in ep.__class__.__slots__:
        metadata = ep.metadata
    else:
        encoded = ep.name.split("@", 1)
        ep.name = encoded[0]
        if len(encoded) > 1:
            try:
                metadata = json.loads(encoded[1])
            except BaseException:
                metadata = None
        else:
            metadata = None


Rejected Ideas
==============

* Using another serialization scheme, i.e. [2]_ bencode__. Since it is planned to use JSON in `PEP 426` [3]_, since JSON is widespread, and more importantly, is already in the standard library, it has been chosen.

* Putting the JSON metadata in place other than the name means breaking forward compatibility.


Reference Implementation
========================

[4]_


References
==========

.. [1] Entry points specification
       https://packaging.python.org/specifications/entry-points/

.. [2] The BitTorrent Protocol Specification
       https://www.bittorrent.org/beps/bep_0003.html

.. [3] PEP 426 -- Metadata for Python Software Packages 2.0
       https://www.python.org/dev/peps/pep-0426/

.. [4] Improved entry points mechanism. Entry points now can contain JSON metadata #2033 
       https://github.com/pypa/setuptools/pull/2033


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.
