PEP: 0999
Title: Python minimization
Version: $Revision$
Last-Modified: $Date$
Author: 
Sponsor: 
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 15-Sep-2020


Abstract
========

This PEP aims to provide a way to minimize the footprint of Python on the hard drive for constrained environments like containers. Two possible solutions are provided for discussion.


Motivation
==========

The footprint of an installed Python tends to be quite large on most distributions.
This is not always desirable. In use cases such as containers, there are efforts to keep the disk size as minimal as possible. We would like to provide a standardized way to accomplish this minimization so that downstream distributors don't have to reinvent the wheel, rely on hacks and/or break users expectations.


Rationale
=========

The authors of this PEP have not settled on the specific mechanism for minimization yet. We would like to present two approaches for discussion.


Option 1: Shipping only ``.py`` files, disabling creation of ``.pyc``s
----------------------------------------------------------------------

A simple way of saving space is not shipping `.pyc` files, as they are not strictly necessary. Python programs will run fine from only `.py` files. They will take a bit longer to start, but in our testing the slowdown is acceptable. For example, importing `importlib.py` takes on average 0.025s longer on our machines compared to the `.pyc`.

The problem with this method is that when Python imports a `.py` file without finding a corresponding and up to date `.pyc` file in `__pycache__`, it will try to create it. This is undesirable for two reasons:

1. the disk footprint will start to grow, defeating the purpose of minimization, and
2. many Python distributors, e.g. Linux distros, have a way to track and verify installed files. Having files of unknown origin being generated in the background on the root filesystem is ill advised.

To remedy this, we propose that distributors place a marker file in each `__pycache__` directory that is to be protected. When Python loads a `.py` file, it would look for such marker file in the corresponding `__pycache__` directory and it would skip writing the `.pyc` file if marker is detected. The use of a file as a marker would make this easy to configure and verify this mechanism for distributors and users alike.


Option 2: Shipping the non-optimized `.pyc` file and compressed `.py` source files
----------------------------------------------------------------------------------

While option 1 has advantages, it suffers from needing a new kind of a marker and somewhat slower start times.

Option 2 involves downstream distributors shipping non-optimized `.pyc` files instead of `.py` files. These would be placed in the same directory where the `.py` file would have been (i.e. not inside `__pycache__`). That is because files inside `__pycache__` are checked only if a corresponding `.py` file exists in the directory above.

On the other hand, the optimized `.pyc` files (optimization level 1 and 2) would not be shipped, to save space. This would, however, lead to situations where users running Python with optimizations (switches `-O`, `-OO`, envvar `PYTHONOPTIMIZE`) would instead execute non-optimized versions of Python standard library modules. Authors of this PEP believe that this would not have an adverse impact.

The above solution is achievable even now without any changes to Python. However, the authors believe that the solution as is would be problematic because Python tools generally assume and depend on the presence of the `.py` source files. One prominent example are Python tracebacks, which would no longer display line numbers and code snippets useful for debugging purposes.

To remedy this, we propose instituting a new optional `__pysources__` directory, which would hold Python `.py` source files in a compressed format. Python would primarily load the non-optimized `.pyc` files for execution, but where necessary, it could load the compressed source file as well, for example to display a traceback.


Specification
=============

Size impact
-----------

TODO

TODO how much is saved? show on python-libs, describe what is and isn't inside them

Directory structure
-------------------

Option 1: Shipping only `.py` files, disabling creation of `.pyc`s
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The marker file preventing `.pyc` pycache files to be created could be put into the `__pycache__`
directory as follows::

    project/
    ├── some_file.py
    └── __pycache__
        └── __dont_write_bytecode__

This tells the interpreter that, upon import, it should not create and write a
bytecompiled cache for later use.

This file could be empty or contain any content. The interpreter would only check for its
presence, the contents would not be read.

Option 2: Shipping the non-optimized `.pyc` file and compressed `.py` source files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The directory structure containing the non-optimized `.pyc` bytecache and the compressed sources could be as follows::

    project/
    ├── some_file.pyc
    └── __pysources__
        └── some_file.zpy

Since the `project` directory would not contain any `.py` source files, a `__pycache__` directory would not be present.

Python would first load the non-optimized `.pyc` file for execution, and if it needed access to the sources, it would unpack and load the compressed sources as well.


Backwards Compatibility
=======================

This pep has no implications on backwards compatibility.


How to Teach This
=================

The targeted group of users for this PEP are downstream Python distributors, such as Linux distributions, which are presumed to be aware of new PEPs and related discussions.


Reference Implementation
========================

`Option 1: Shipping only \`.py\` files, disabling creation of \`.pyc\`s`_

`Option 2: Shipping the non-optimized \`.pyc\` file and compressed \`.py\` source files`_


Rejected Ideas
==============

Fedora has already been shipping Python with a slightly smaller footprint. The Python standard library contains a lot of modules where the `.pyc` bytecache files are identical between optimization levels. For example some non-optimized `.pyc` files are identical to `.pyc` files of optimization level 1 (and sometimes level 2 too). Due to this, Fedora has been able to reduce the disk footprint by hardlinking these files in cases where they are identical. However, the disk size saved was relatively minor, at 4.0 MiB or 10.7 % of Fedora's `python-libs` RPM package.

To minimize the footprint further, a range of ideas was considered, see `Python minimization in Fedora`_. These ideas have been then discussed on this `Fedora devel mailing list thread`_.


Open Issues
===========

The exact method to accomplish the minimization has not yet been settled on. We propose two base methods that we feel represent the best ways forward. Whether we go with one of those, a combination of those, or perhaps a yet different solution remains an open issue.


References
==========

.. _`Python minimization in Fedora`:
   https://github.com/hroncok/python-minimization/blob/master/document.md
.. _`Fedora devel mailing list thread`:
   https://lists.fedoraproject.org/archives/list/devel@lists.fedoraproject.org/thread/LACP3PFQPUO6BQQLYYJDFF4CR3DHWRSQ/

.. _`Option 1: Shipping only \`.py\` files, disabling creation of \`.pyc\`s`:
   https://github.com/encukou/cpython/tree/minimization-marker
.. _`Option 2: Shipping the non-optimized \`.pyc\` file and compressed \`.py\` source files`:
   https://github.com/encukou/cpython/tree/minimization-src-from-pyc

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

