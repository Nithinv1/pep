PEP: 9999
Title: dict-grouping
Author: Michael Selik <mike@selik.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 28-Jun-2018
Python-Version: 3.8
Post-History: 28-Jun-2018



Abstract
========

This is a proposal for creating a concise, reliable way to group
elements of a sequence, resulting in a dictionary of lists.



Motivation
==========

One of the most frequent tasks in programming for data analysis is
grouping data into categories. When creating a new Excel spreadsheet,
often the user's first task is to create names for the columns or rows.
The best metaphor for this in Python and the standard library is a dict
of lists, especially now that dictionaries maintain insertion order.

We currently have three reasonable techniques to create groups from a
sequence or iterable:

- ``itertools.groupby``
- ``collections.defaultdict``
- ``dict.setdefault``

Unfortunately, both ``itertools.groupby`` and
``collections.defaultdict`` are error-prone, and ``dict.setdefault`` is
homely (not beautiful).


``defaultdict``
---------------

The ``defaultdict`` is elegant for building a grouping, but many
otherwise-expert programmers will accidentally insert new groups when
they intended to raise a ``KeyError``.

Elegant for creating groups::

   >>> from collections import defaultdict
   >>> groups = defaultdict(set)
   >>> for x in range(7):
   ...     groups[x % 2].add(x)
   ...

Error-prone when using groups::

   >>> groups
   defaultdict(<class 'set'>, {0: {0, 2, 4, 6}, 1: {1, 3, 5}})
   >>> len(groups[2])   # accidentally inserts a new group
   0
   >>> groups
   defaultdict(<class 'set'>, {0: {0, 2, 4, 6}, 1: {1, 3, 5}, 2: set()})

In many situations, a ``defaultdict`` is useful for building a mapping,
but a regular dict is better for the returned type. Pytoolz'
``toolz.itertoolz.frequencies`` illustrates the issue.

https://github.com/pytoolz/toolz/blob/master/toolz/itertoolz.py#L527


``itertools.groupby``
---------------------

Many users of ``itertools.groupby`` will forget to sort
the data before grouping, accidentally creating two or more separate
groups for the same key.

::

   >>> from itertools import groupby
   >>> mod_2 = lambda x: x % 2

Mistake::

   >>> {k: set(group) for k, group in groupby(range(7), key=mod_2)}
   {0: {6}, 1: {5}}

Correct::
   
   >>> numbers = sorted(range(7), key=mod_2)
   >>> {k: set(group) for k, group in groupby(numbers, key=mod_2)}
   {0: {0, 2, 4, 6}, 1: {1, 3, 5}}


``dict.setdefault``
-------------------

The ``dict.setdefault`` method is often the best choice for grouping,
but suffers from a less-beautiful appearance. Secondarily,
``setdefault`` cannot easily create a grouping as an expression.

::

   >>> groups = {}
   >>> for x in range(7):
   ...     groups.setdefault(x % 2, set()).add(x)
   ...
   >>> groups
   {0: {0, 2, 4, 6}, 1: {1, 3, 5}}


This appears to be 



Specification
=============

I propose a new ``dict`` classmethod, ``dict.grouping`` which will
construct a new dictionary based on an iterable and a key-function.

The behavior would be comparable to the following ``dict`` extension:

::

   class Dict(dict):

       @classmethod
       def grouping(cls, iterable, key=None):
           '''
           Group elements of an iterable into a dict of lists.

           The ``key`` is a function computing a key value for each
           element. Each key corresponds to a group -- a list of elements
           in the same order as encountered. By default, the key will be
           the element itself.

               >>> mod_2 = lambda x: x % 2
               >>> Dict.grouping(range(7), mod_2)
               {0: [0, 2, 4, 6], 1: [1, 3, 5]}

               >>> Dict.grouping('AbBa', str.casefold)
               {'a': ['A', 'a'], 'b': ['b', 'B']}
           '''
           # https://en.wikipedia.org/wiki/Equivalence_class
           
           if key is None:
               return cls({k: list(g) for k, g in groupby(sorted(iterable))})

           groups = cls()
           for x in iterable:
               groups.setdefault(key(x), []).append(x)
           return groups



Rationale
=========

The concept of a labeled group is common across many programming tasks.
The ``email.headerregistry.Group`` associates a display name with a list
of addresses. The ``msilib.RadioButtonGroup`` associates a name with
members. When the groups are of equal size and ordered, the labeled
groups can be considered named columns or indexed rows.

This proposal was inspired by similar tools available in other languages
and in Python community libraries.


Other Languages
---------------

Java
~~~~

Java's ``Collectors.groupingBy`` consumes a stream and creates a
``Map<K, List<T>>`` associating keys with lists of values.

https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html


.NET
~~~~

C#'s ``Enumerable.GroupBy`` is similar to Python's ``itertools.groupby``
in that it's an iterator yielding groups that implement the
(``IGrouping<TKey,â€‚TElement>``) interface. Despite claiming deferred
execution, ``Enumerable.GroupBy`` emits complete groups even if the
input sequence was not sorted by key. Additionally, it allows a
transform function for the grouped values in addition to a key function.

https://msdn.microsoft.com/en-us/library/bb534304(v=vs.110).aspx


Rust
~~~~

Rust provides an iterator method ``group_by`` which returns a lazy
``GroupBy`` iterable object which yields iterables for each group. It
behaves similarly to Python's ``itertools.groupby``, which may repeat
keys if the input sequence was not ordered by key.

https://docs.rs/itertools/*/itertools/trait.Itertools.html#method.group_by


Clojure
~~~~~~~

Clojure has ``group-by``, which is nearly identical to this proposal:
``(group-by f coll)``. The choice of the name begs a different order for
the parameters as well, as the phrase "group by key" is quite natural,
inviting a curry.

   user=> (group-by first ["python" "jython" "cython" "pypy" "cpython"])
   {\p ["python" "pypy"], \j ["jython"], \c ["cython" "cpython"]}

https://clojuredocs.org/clojure.core/group-by


Community Libraries
-------------------

Toolz
~~~~~

Toolz' ``groupby`` requires the key-function as the first positional
parameter and the sequence to be grouped as the second. This order may
be more natural if a key-function is always necessary. However, it
breaks the pattern established by builtins ``sorted``, ``min``, ``max``,
and standard library ``itertools.groupby``, which all have the sequence
as the first parameter.

::

   >>> names = ['Alice', 'Bob', 'Charlie', 'Dan', 'Edith', 'Frank']
   >>> groupby(len, names)  
   {3: ['Bob', 'Dan'], 5: ['Alice', 'Edith', 'Frank'], 7: ['Charlie']}

http://toolz.readthedocs.io/en/latest/api.html#toolz.itertoolz.groupby


Pandas
~~~~~~

While Pandas may be most famous for its ``DataFrame``, the better
comparison in this situation would be ``Series.groupby``.

::

    In [1]: import pandas as pd

    In [2]: def mod(x):
    ...:     def modulo(n):
    ...:         return n % x
    ...:     return modulo
    ...:

    In [3]: pd.Series(range(10)).groupby(mod(2)).groups
    Out[3]:
    {0: Int64Index([0, 2, 4, 6, 8], dtype='int64'),
    1: Int64Index([1, 3, 5, 7, 9], dtype='int64')}

http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.groupby.html#pandas.Series.groupby

As with Clojure, it fits naturally with the phrase, "group by key."
Using ``Series.groupby`` as an unbound method does not read nearly as
well.

::

    In [12]: pd.Series.groupby(numbers, mod(2)).groups
    Out[12]:
    {0: Int64Index([0, 2, 4, 6, 8], dtype='int64'),
    1: Int64Index([1, 3, 5, 7, 9], dtype='int64')}

The ``DataFrame.groupby`` handles an interesting sub-category of usage,
when each element of the input sequence is itself a sequence with one or
many key-elements and one or many value-elements. In some cases, the
key-elements should be dropped from these sequences when grouping.

::

    >>> sequence = [[1, 11, 12], [1, 13, 14], [2, 21, 22], [2, 23, 24]]
    >>> dict.grouping(sequence, key=lambda row: row.pop(0))
    {1: [[11, 12], [13, 14]], 2: [[21, 22], [23, 24]]}



Examples
========

::

    >>> mod_2 = lambda x: x % 2
    >>> dict.grouping(range(7), mod_2)
    {0: [0, 2, 4, 6], 1: [1, 3, 5]}


    >>> dict.grouping('ababa')
    {'a': ['a', 'a', 'a'], 'b': ['b', 'b']}


    >>> dict.grouping('aBAb', str.casefold)
    {'a': ['a', 'A'], 'b': ['B', 'b']}


    >>> dict.grouping('aBAbaB', str.casefold)
    {'a': ['a', 'A', 'a'], 'b': ['B', 'b', 'B']}


Group and Aggregate
-------------------

While ``dict.grouping`` creates a dict of lists, preserving the order
that group members were encountered, it is often useful to create
"equivalence classes" which are better modeled as a dictionary of sets.

::

    >>> groups = dict.grouping('aBAbaB', str.casefold)
    >>> {k: sorted(set(g)) for k, g in groups.items()}
    {'a': ['A', 'a'], 'b': ['B', 'b']}


If each group should be a multiset, where repetitions matter but order
does not, then a dictionary of Counters is appropriate.

::

    >>> from collections import Counter
    >>> groups = dict.grouping('aBAbaB', str.casefold)
    >>> {k: Counter(g) for k, g in groups.items()}
    {'a': Counter({'a': 2, 'A': 1}), 'b': Counter({'B': 2, 'b': 1})}


Grouping and performing an aggregation or reduction on the resulting
groups is a very common task.

::

    def aggregate(iterable, reducer, key=None):
        '''
        Apply a ``reducer`` function to each group in an iterable.

            >>> mod_2 = lambda x: x % 2
            >>> aggregate([1, 2, 3, 4], sum, key=mod_2)
            {1: 4, 0: 6}

        This is convenient for creating dict of sets or a dict of Counters.

            >>> g = aggregate('AaaBBb', set, key=str.casefold)
            >>> {k: sorted(v) for k, v in g.items()}
            {'a': ['A', 'a'], 'b': ['B', 'b']}

            >>> aggregate('AaaBBb', Counter, key=str.casefold)
            {'a': Counter({'a': 2, 'A': 1}), 'b': Counter({'B': 2, 'b': 1})}

        '''
        g = Dict.grouping(iterable, key)
        return {k: reducer(v) for k, v in g.items()}


Group and Transform
-------------------

Another very common task is grouping and transforming each group. This
might be to perform a transformation which includes a grouped-
aggregation, like a z-score, or simply to discard unnecessary
information.

::

    def z_score(numbers):
        '''
        Subtract mean and divide by standard deviation.
        '''
        # https://en.wikipedia.org/wiki/Standard_score
        mu = statistics.mean(numbers)
        sigma = statistics.stdev(numbers)
        return [(x - mu) / sigma for x in numbers]



    def transform(iterable, func, key=None):
        '''
        Demultiplex an iterable and transform each element.

            >>> transform('abAB', str.swapcase, key=str.casefold)
            {'a': ['A', 'a'], 'b': ['B', 'b']}

        '''
        g = Dict.grouping(iterable, key)
        return {k: [func(x) for x in v] for k, v in g.items()}


Markov Chain
------------

A stateful key-function can provide some very succinct code to create
interesting data structures.

::

    def markov_chain(iterable):
        '''
        Build a Markov chain model of one or many iterables as if they were
        the output of a Markov process.

            >>> markov_chain([1, 1, 2, 1])
                    {None: [1], 1: [1, 2], 2: [1]}

        The model is represented as a dict of lists. For each key in the
            dictionary, the corresponding list holds its possible transitions in
            proportion to the observed probability from the iterable.

        The ``None`` key shows the initial state. Terminating states are
            those which are present in the dict values, but never in the keys.
            The model can be trained on multiple observations by merging chains
            together.

            >>> a = [1, 1, 2, 1, 0]
                    >>> b = [2, 1, 0]
                    >>> sequences = [a, b]
                    >>> chains = map(markov_chain, sequences)
                    >>> merge(*chains)
                    {None: [1, 2], 1: [1, 2, 0, 0], 2: [1, 1]}

        '''
            t0 = None
            def previous(t1):
                nonlocal t0
                x, t0 = t0, t1
                return x
            return Dict.grouping(iterable, previous)


    def markov_walk(chain, start=None):
        '''
        Markov chain Monte Carlo simulation.

            >>> chain = markov_chain([1, 1, 2, 2, 1, 2, 1, 0])
                    >>> chain
                    {None: [1], 1: [1, 2, 2, 0], 2: [2, 1, 1]}
                    >>> random.seed(42)
                    >>> list(markov_walk(chain))
                    [None, 1, 1, 2, 2, 2, 2, 1, 1, 1, 0]
                '''
                x = start
                while True:
                    yield x
                    try:
                        x = random.choice(chain[x])
                    except KeyError:
                        break


K-Means Clustering
------------------

Grouping is used in many analysis tasks, such as clustering.

::

    def distance(a, b):
        '''
        Euclidean distance between two n-tuples.

            >>> a = 3, 4
                    >>> b = 0, 0
                    >>> distance(a, b)
                    5.0

        '''
            return math.sqrt(sum([(x - y) ** 2 for x, y in zip(a, b)]))


    def nearest(target, rows):
        '''
        Nearest row to the target.

            >>> target = 0, 0
                    >>> rows = [(5, 5), (-4, -4), (1, 1)]
                    >>> nearest(target, rows)
                    (1, 1)
                '''
                return min(rows, key=lambda row: distance(target, row))


    def k_means(k, iterable, iterations=5):
        '''
        K-Means clustering.

            >>> random.seed(42)
                    >>> rows = [(random.random(), random.random()) for i in range(100)]
                    >>> clusters = k_means(3, rows)
                    >>> for i, (centroid, cluster) in enumerate(clusters.items()):
                    ...     print(f'Cluster {i}: size={len(cluster)}, centroid={centroid}')
                    ...
                    Cluster 0: size=46, centroid=(0.3402505165179919, 0.15547949981178155)
                    Cluster 1: size=30, centroid=(0.9895233506365952, 0.6399997598540929)
                    Cluster 2: size=24, centroid=(0.2498064478821005, 0.9232655992760128)

        '''
            rows = list(iterable)
            centroids = random.sample(rows, k)
            for i in range(iterations):
                clusters = Dict.grouping(rows, key=lambda row: nearest(row, centroids))
                centroids = {k: [sum(column) for column in zip(*g)] for k, g in clusters.items()}
            return clusters



How to Teach This
=================




Copyright
=========

This document has been placed in the public domain.
