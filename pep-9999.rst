PEP: 12
Title: High Performance Instrumentation and Monitoring
Author: Mark Shannon <mark@hotpy.org>
Status: Draft
Type: Standards
Content-Type: text/x-rst
Created: 18-Aug-2021
Post-History: xx-Aug-2021


Abstract
========

The performance of Python when using tools that instrument or monitor the runtime
is awful. It does not need to be so bad.
This PEP proposes a set of APIs for instrumentation and monitoring of Python
programs running on CPython that will enable the insertion of instrumentation
and monitoring at low cost.

The expectation is that heavily instrumented code,
such as is needed for profiling and coverage tools would suffer a slowdown 
of no more than 30% and would run under 3.11 at speeds comparable with
uninstrumented code running on 3.10.

For lightly instrumented code or code with a monitoring points, there 
should be no discernable overhead.

This means that code run under a debugger for 3.11 should outperform code run
without a debugger on 3.10.
Programs run with profiling and coverage on 3.11 should perform no more than
10% slower than on 3.10.

Motivation
==========

Developers should not have to pay an unreasonable cost to use debuggers, profilers
and other tools.

C++ and Java developers expect to be able to run a program at full speed
(or very close to it). Python developers should be able to expect it too.

Rationale
=========

It makes sense to add these features to 3.11 because PEP 659 provides us with a way
to dynamically modify executing Python bytecode in a way that has no cost to parts 
of the code that are not modified and only low cost to those parts that are modified.

Specification
=============

There are two parts to this specification, instrumentation and monitoring.

Instrumentation occurs early in a program's life cycle and persists. 
It is expected to be pervasive, but fixed.
Instrumentation is designed to support profiling and coverage tools that 
expect to be active for the entire lifetime.

Monitoring can occur at any point in the program's life and be applied anywhere in
the program. Monitoring points are expected to few. The capabilities of monitoring 
are a superset of that of profiling, but insertion of monitoring points will be much more
expensive that insertion of instrumentation.

Both instrumentation and monitoring is performed by insertion of a checkpoint in a code object.

Checkpoints
-----------

A checkpoint is simply a point in code, that is defined by a ``(codeobject, offset)`` pair.
Everytime a checkpoint is reached, the registered callable is called.

Instrumentation
---------------

Instrumentation supports the bulk insertion of checkpoints,
but does not allow insertion of checkpoints after code has started to execute.

``instrumentation.register(event, func)``

Functions can be unregistered by calling ``instrumentation.register(event, None)``.

#define PyTrace_CALL 0
#define PyTrace_EXCEPTION 1
#define PyTrace_LINE 2
#define PyTrace_RETURN 3
#define PyTrace_C_CALL 4
#define PyTrace_C_EXCEPTION 5
#define PyTrace_C_RETURN 6
#define PyTrace_OPCODE 7

The events are::

  * BRANCH: Any conditional branch is taken, or not. 
  * JUMPBACK: Any backwards, unconditional branch is taken.
  * CALL: A call to a Python function is made.
  * C_CALL: A call to any object that is not a Python function.
  * RETURN: A return from a Python function.
  * C_RETURN: A return from any object that is not a Python function.
  * YIELD: A yield occurs.
  * RESUME: A generator or coroutine resumes after a YIELD.
  * RAISE: An exception is raised.
  * EXCEPT: An exception is handled.
  * UNWIND: An exception cause the frame stack to be unwound.
  * LINE: A new line is reached.

All events are integer powers of two and can be bitwise or-ed together to instrument multiple events.

Code objects can be instrumented by calling:

``instrumentation.instrument(codeobject, events)``

Individual instrumentation check points can be turned on or off with:

``instrumentation.instrument_off(codeobject, offset)``
``instrumentation.instrument_on(codeobject, offset)``

Turning a non-existent checkpoint on or off is a no-op. No exception is raised.

Instrumentation checkpoints cannot be removed.

Callback functions
''''''''''''''''''

When an event occurs the registered function will be called. The arguments provided are as follows:

* BRANCH: ``func(code: CodeType, offset: int, taken:bool)``
* JUMPBACK: ``func(code: CodeType, offset: int)``
* CALL: ``func(code: CodeType, offset: int, callable: object)``
* START: ``func(code: CodeType, offset: int)``
* RETURN: ``func(code: CodeType, offset: int, value: object)``
* YIELD: ``func(code: CodeType, offset: int, value: object)``
* RESUME: ``func(code: CodeType, offset: int)``
* RAISE: ``func(code: CodeType, offset: int, exception: BaseException)``
* EXCEPT: ``func(code: CodeType, offset: int)``

Monitoring
----------

Monitoring allows checkpoints to be inserted or removed at any point in the program's execution.

The following functions are provided:

``instrumentation.insert_monitors(codeobject, *offsets)``
``instrumentation.remove_monitors(codeobject, *offsets)``
``instrumentation.monitor_off(codeobject, offset)``
``instrumentation.monitor_on(codeobject, offset)``

All functions return ``True`` if a monitor checkpoint was present.
Turning a non existent checkpoint on or off is a no-op. No exception is raised.

``instrumentation.monitor_register(func)``

For optimizing virtual machines, such as ``PyPy`` and future versions of CPython, 
calls to ``insert_monitors`` and ``remove_monitors`` may be quite expensive.
Calls may take 100s of milliseconds for a large program, as it they trigger de-optimizations.

Once the call is completed, the impact on performance should be negligible.

Combining checkpoints
---------------------

Only one instrumentation checkpoint and one monitoring checkpoint is allowed per bytecode instruction.
It is possible to have both a monitoring and instrumentation checkpoint on the same instruction;
they are independent. Monitors will be called before instrumentation if both are present.

Backwards Compatibility
=======================

This PEP is fully backwards compatible.
We may seek to remove ``sys.settrace`` in the future once the APIs provided by this PEP
have been widely adopted, but that is outside the scope of this PEP.


Security Implications
=====================

Allowing modification of running code has some security implications,
but no more than the ability to generate and call new code.

All the functions listed above will trigger audit hooks.


Implementation
==============

The implementation of this PEP will be built on top of PEP 659 quickening.
Instrumentation or monitoring of a code object will first cause it to be quickened.
Checkpoints will then be implemented by inserting one of several special ``CHECKPOINT``
instructions into the quickened code. These instructions will call the registered callable
before executing the original instruction.

Note that this can interfere with specialization, which will result in performance degradation
in addition to the overhead of calling the registered callable.

Implementing tools
==================

Debuggers
---------

Most of the features of a debugger are unchanged. Presenting the state of the VM to the user 
depends on introspection, not monitoring. It is the insertion of breakpoints, that differs.

Inserting breakpoints
'''''''''''''''''''''

Breakpoints are simply monitors. To insert a breakpoint at a given line, the matching instruction
offsets should be found from ``codeobject.co_lines()``.
Then a monitor should be added for each of those offsets. To avoid excessive overhead, a single call
should be made to ``instrumentation.insert_monitors`` passing all the offsets at once.

Breakpoints can suspended with ``instrumentation.monitor_off``.

Debuggers can break on exceptions being raised by registering a callable for ``RAISE``:

``instrumentation.register(RAISE, break_on_raise_handler)``

Coverage Tools
--------------

Coverage tools need to track which parts of the control graph have been executed. To do this, they need
to track most events and map those events onto the control flow graph of the code object.
``BRANCH``, ``JUMPBACK``, ``START`` and ``RESUME`` events will inform which basic blocks have started to execute.
The ``RAISE`` event with mark any blocks that did not complete.

This can be then be converted back into a line based report after execution has completed.

Profilers
---------

Simple profilers need to gather information about calls. To do this profilers should register for
the following events:

* CALL: ``func(code: CodeType, offset: int, callable: object)``
* START: ``func(code: CodeType, offset: int)``
* RETURN: ``func(code: CodeType, offset: int, value: object)``
* YIELD: ``func(code: CodeType, offset: int, value: object)``
* RESUME: ``func(code: CodeType, offset: int)``
* RAISE: ``func(code: CodeType, offset: int, exception: BaseException)``
* EXCEPT: ``func(code: CodeType, offset: int)``


Line based profilers
''''''''''''''''''''

Line based profilers will also need to handle ``LINE`` events.
Beware that handling ``LINE`` events will have a large performance impact.

  .. note:

  Instrumenting profilers have a large overhead and will distort the results of profiling.
  Unless you need exact call counts, consider using a statistical profiler.

Open Issues
===========

[Any points that are still being decided/discussed.]


References
==========

[A collection of URLs used as references through the PEP.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End:
