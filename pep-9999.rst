PEP: 9999
Title: User-Defined Type Guards
Version: $Revision$
Last-Modified: $Date$
Author: Eric Traut <erictr at microsoft.com>
BDFL-Delegate: TBD
Discussions-To: Python-Dev <python-dev@python.org>
Status: Provisional
Type: Standards Track
Content-Type: text/x-rst
Created: 07-Oct-2020
Python-Version: 3.10
Post-History: TBD
Resolution: TBD


Abstract
========

This PEP specifies a way for programs to influence conditional type narrowing
employed by a type checker based on runtime checks.


Motivation
=========

Static type checkers commonly employ a technique called "type narrowing" to
determine a more precise type of an expression within a program's code flow.
When type narrowing is applied within a block of code based on a conditional
code flow statement (such as ``if`` and ``while`` statements), the conditional
expression is sometimes referred to as a "type guard". Python type checkers
typically support various forms of type guards expressions.

::

    def func(val: Optional[str]):
        # "is None" type guard
        if val is not None:
            # Type of val is narrowed to str
            ...
        else:
            # Type of val is narrowed to None
            ...

    def func(val: Optional[str]):
        # Truthy type guard
        if val:
            # Type of val is narrowed to str
            ...
        else:
            # Type of val remains Optional[str]
            ...

    def func(val: Union[str, float]):
        # "isinstance" type guard
        if isinstance(val, str):
            # Type of val is narrowed to str
            ...
        else:
            # Type of val is narrowed to float
            ...

    def func(val: Literal[1, 2]):
        # Comparison type guard
        if val == 1:
            # Type of val is narrowed to Literal[1]
            ...
        else:
            # Type of val is narrowed to Literal[2]
            ...

There are cases where type narrowing cannot be applied based on static
information only. Consider the following example:

::

    def is_str_list(val: List[object]) -> bool:
        """Determines whether all objects in the list are strings"""
        return all(isinstance(x, str) for x in val)

    def func1(val: List[object]):
        if is_str_list(val):
            print(" ".join(val)) # Error: invalid type


This code is correct, but a type checker will report a type error because
the value ``val`` passed to the ``join`` method is understood to be of type
``List[object]``. The type checker does not have enough information to
statically verify that the type of ``val`` is ``List[str]`` at this point.

This PEP introduces a way for a function like ``is_str_list`` to be defined as
a "user-defined type guard". This allows code to extend the type guards that
are supported by type checkers.

Using this new mechanism, the ``is_str_list`` function in the above example
would be modified slightly. Its return type would be changed from ``bool``
to ``TypeGuard[List[str]]``.

::

    from typing import TypeGuard

    def is_str_list(val: List[object]) -> TypeGuard[List[str]]:
        """Determines whether all objects in the list are strings"""
        return all(isinstance(x, str) for x in val)


Specification
=============

TypeGuard Type
--------------

This PEP introduces the symbol ``TypeGuard`` exported from the ``typing``
module. ``TypeGuard`` is a type alias for the built-in `bool` type, but it
allows for a single type argument. It is meant to be used to annotate the
return type of a function or method. When it is used in other contexts, it
is treated as a ``bool``.

When ``TypeGuard`` is used to annotate the return type of a function or
method that accepts at least one parameter, that function or method is
assumed by type checkers to be a user-defined type guard. The type argument
provided for ``TypeGuard`` indicates the type that has been validated by
the function.

User-defined type guards can be generic functions, as shown in this example:

::

    _T = TypeVar("_T")

    def is_two_element_tuple(val: Tuple[_T, ...]) -> TypeGuard[Tuple[_T, _T]]:
        return TypeGuard(len(val) == 2)

    def func(names: Tuple[str, ...]):
        if is_two_element_tuple(names):
            reveal_type(names)  # Tuple[str, str]
        else:
            reveal_type(names)  # Tuple[str, ...]


Type checkers should assume that type narrowing should be applied to the
expression that is passed as the first argument to a user-defined type guard.
If the type guard function accepts more than one argument, no type narrowing
is applied to those additional argument expressions.

Here is an example of a user-defined type guard function that accepts more
than one parameter:

::

    def is_str_list(val: List[object], allow_empty: bool) -> TypeGuard[List[str]]:
        if allow_empty and len(val) == 0:
            return True
        return all(isinstance(x, str) for x in val)


The return type of a user-defined type guard function will normally refer to
a type that is strictly "narrower" than the type of the first parameter (that
is, it's a more specific type that can be assigned to the more general type).
However, it is not required that the return type be strictly narrower. This
allows for cases like the example above where ``List[str]`` is not assignable
to ``List[object]``.

Some built-in type guards provide narrowing for both positive and negative
tests (in both the ``if`` and ``else`` clauses). User-defined type guards
apply narrowing only in the positive case (the ``if`` clause).

::

    OneOrTwoStrs = Union[Tuple[str], Tuple[str, str]]
    def func(val: OneOrTwoStrs):
        if is_two_element_tuple(val):
            reveal_type(val)  # Tuple[str, str]
            ...
        else:
            reveal_type(val)   # OneOrTwoStrs
            ...
        
        if not is_two_element_tuple(val):
            reveal_type(val)   # OneOrTwoStrs
            ...
        else:
            reveal_type(val)  # Tuple[str, str]
            ...


Backwards Compatibility
=======================
Existing code that does not use this new functionality will be unaffected.


Reference Implementation
========================

The Pyright type checker supports the behavior described in this PEP.


Rejected Ideas
==============

Decorator Syntax
----------------

The use of a decorator was considered for defining type guards. The proposed
approach was deemed to be easier to understand and simpler to implement.


Enforcing Strict Narrowing
--------------------------

Strict type narrowing enforcement was considered, but this eliminates numerous
valuable use cases for this functionality.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
