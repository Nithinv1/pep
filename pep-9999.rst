PEP: 9999
Title: Virtual wheel based editable installs
Author: Bernát Gábor <gaborjbernat@gmail.com>
Sponsor: Paul Ganssle <paul@ganssle.io>
Discussions-To: https://discuss.python.org/t/draft-pep-editable-installs-for-pep-517-style-build-backends/8510
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 28-May-2021
Post-History: 


Abstract
========

This document describes extensions to the build backend-frontend communication
(as introduced by `PEP-517`_) to allow projects to be installed in editable
mode.

Motivation
==========

Python programmers want to be able to develop packages without having to
install them after every change. Installing a project is made up of
building a wheel from the source directory (as described by `PEP-517`_
and `PEP-518`_) and then install that wheel into a python environment.

Currently users can achieve this by:

- Adding the relevant source directories to ``sys.path`` (configurable from the
  command line interface via the ``PYTHONPATH`` environment variable). Note in
  this case the user have to install the project dependencies themselves and
  entry points or project metadata are not generated.
- `setuptools`_ provides the `setup.py develop`_ mechanism: installs a
  ``pth`` file that injects the project root onto the ``sys.path``
  at interpreter startup time, generates the project metadata and also installs
  project dependencies. `pip`_ exposes calling this mechanism via the
  `pip install -e <project_directory>`_ command line interface.
- `flit`_ provides the `flit install --symlink`_ command that: symlinks the
  project files into the interpreters ``purelib`` folder, generates the project
  metadata and also installs dependencies.

The installation of a project in a way that the code being imported and
executed remains in the source directory is known as the *editable*
installation mode. This mode allows the user to change the code and run it
without needing to reinstall it after every change.

The goal of this PEP is to provide a standardized interface between the build
frontend and backends for building and installing projects in editable mode.
This will allow backends to expose the project in editable mode, and for the
frontends a way to request this, in a generic mode for all build backend and
frontends.

Rationale
=========

`PEP-517`_ deferred "Editable installs" because this would have delayed further
its adoption and there wasn't an agreement how editable installs should be
achieved. Due to the propularity of the `setuptools`_ and `pip`_ projects
the status quo prevailed, and backends could achieve editable mode by providing
a ``setup.py develop`` implementation, which the user could trigger via
`pip install -e <project_directory>`_. By definining an editable interface
between build backend and frontends we can totally eliminate the need of the
``setup.py`` file and communication method.

Terminology and goals
=====================

The editable installation mode implies that the source code of the project
being installed is available in a local directory.

Once the project is installed in editable mode, users expect that changes to
the project code in the local source tree become effective without the need of
a new installation step.

Some kind of changes, such as the addition or modification of entry points, or
the addition of new dependencies, require a new installation step to become
effective. These changes are typically made in build backend configuration
files (such as ``pyproject.toml``), so it is consistent with the general user
expectation that source code is imported from the source tree.

When a project is installed in editable mode, users expect the installation to
behave identically as a regular installation. Depending on the way build build
frontends implement this specification, some minor differences may be visible,
such as the presence of additional files (compared to a regular installation)
either in the source tree or the interpreters installation path. Both the build
backend and frontends are encouraged to document such potential differences.

The Mechanism
=============

Editable mode implementations
-----------------------------

Achieving an editable mode can be done in multiple ways. We'll present a few of
them here.

Alter ``sys.path`` at interpreter startup
-----------------------------------------

This is what `setuptools`_ does with the generation of the ``pth`` file into
the interpreters ``purelib``. This solution is very fast and cross platform
compatible, however puts the entire source tree onto the system, potentially
exposing modules that would not be available in a normal installation case.

This mode is what `pip install -e <project_directory>`_ currently resolves to.
It requires the build backend to provide a folder to expose, and the build
frontend to generate a wheel that once installed willl insert that path
onto the ``sys.path`` at interpreter startup.

Symlink the source code
-----------------------

This is what flit does via its `flit install --symlink`_. This solution
requires the current platform to support symlinks, but allows potentially to
symlink not folders, but also andividual files, which could solve the problem
of exposing files that otherwise would not be exposed.

This mode requires the build backend to provides one or more folder(s)/file(s)
to expose, and the build frontend to create a wheel to symlink them.

Import hook
-----------

One can install an import hook at the interpreter startup, where the new hook
loads the files from the source tree instead of the interpreters ``purelib`` or
``platlib`` folder. This solution is more heavy weight however gives total
and dynamic control. One can at import time decide if a file is allowed to be
loaded or not, or can even compile C-extensions as they are needed and used.

What to put in the wheel
------------------------

Build backends may use different techniques to achive the goals of an editable
install. This section provides examples and is not normative.

* Build backends may choose to place a ``.pth`` file at the root of the ``.whl`` file,
  containing the root directory of the source tree. This approach is simple but
  not very precise, although it may be considered good enough (especially when
  using the ``src`` layout) and is similar to what ``setup.py develop``
  currently does.
* The `editables`_ library shows how to build proxy modules that
  provide a high quality editable installation. It accepts a list of modules
  to include, and hide. When imported, these proxy modules replace themselves
  with the code from the source tree. Path-based methods make all scripts under
  a path importable, often including the project's own ``setup.py`` and other
  scripts that would not be part of a normal installation. The proxy strategy
  can achieve a higher level of fidelity than path-based methods.

Frontend requirements
---------------------

Frontends must install editable wheels in the same way as regular wheels.
This also means uninstallation of editables does not require any special treatment.

Frontends must create a ``direct_url.json`` file in the ``.dist-info``
directory of the installed distribution, in compliance with PEP 610. The
``url`` value must be a ``file://`` url pointing to the project directory
(i.e. the directory containing ``pyproject.toml``), and the ``dir_info`` value
must be ``{'editable': true}``.

Frontends must execute ``get_requires_for_build_wheel_for_editable`` hooks in
an environment which contains the bootstrap requirements specified in the
``pyproject.toml`` file.

Frontends must execute the ``build_wheel_for_editable`` hook in an environment
which contains the bootstrap requirements from ``pyproject.toml`` and those
specified by the ``get_requires_for_build_wheel_for_editable`` hook.

Frontends must not rely on the ``prepare_metadata_for_build_wheel`` hook when
installing in editable mode. They must use ``build_wheel_for_editable`` and
inspect the resulting wheel.

Frontends must not expose the wheel obtained from ``build_wheel_for_editable``
to end users. The wheel must be discarded after installation and must not be
cached nor distributed.

Rejected ideas
==============

This PEP competes with ``PEP-660``, and rejects that proposal because we think the
mechanism of achieving an editable installation should be within the build frontend
rather than the build backend. Furthermore, this approach allows for the ecosystem
to use alternative mechanisms to achieve the editable install effect (instead of implying
just the loose wheel mode from the backends described by that PEP).

References
==========

.. _`PEP-517`: https://www.python.org/dev/peps/pep-0517/
.. _`PEP-518`: https://www.python.org/dev/peps/pep-0518/
.. _`setuptools`: https://setuptools.readthedocs.io/en/latest/
.. _`setup.py develop`: https://setuptools.readthedocs.io/en/latest/userguide/commands.html#develop-deploy-the-project-source-in-development-mode
.. _`pip`: https://pip.pypa.io
.. _`pip install -e <project_directory>`: https://pip.pypa.io/en/stable/cli/pip_install/#install-editable
.. _`flit`: https://flit.readthedocs.io/en/latest/index.html
.. _`flit install --symlink`: https://flit.readthedocs.io/en/latest/cmdline.html#cmdoption-flit-install-s
.. _`editables`: https://pypi.org/project/editables/


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
