PEP: 9999
Title: Support for parsing TOML in the Standard Library
Author: Taneli Hukkinen, Shantanu Jain <hauntsaninja at gmail.com>
Sponsor: TODO
PEP-Delegate: TODO
Discussions-To: TODO
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 01-Jan-2022
Python-Version: 3.11
Post-History: 1900-01-01


Abstract
========

This proposes adding a module, ``tomllib``, to the standard library for
parsing TOML. [1]_


Motivation
==========

The TOML format is the format of choice for Python packaging, as evidenced by
:pep:`517`, :pep:`518` and :pep:`621`. Including TOML support in the standard
library helps avoid bootstrapping problems for Python build tools. Currently
most Python build tools need to vendor a TOML parsing library.

Python tools are increasingly configurable via TOML, for examples: ``black``,
``mypy``, ``pytest``, ``tox``, ``pylint``, ``isort``. Those that are not, such
as ``flake8``, cite the lack of standard library support as a `main reason why
<https://github.com/PyCQA/flake8/issues/234#issuecomment-812800657>`_.

Given the special place TOML already has in the Python ecosystem, it makes sense
for this to be an included battery.

Finally, TOML as a format is increasingly popular (some reasons for this are
outlined in PEP 518). Hence this is likely to be a generally useful addition,
even looking beyond the needs of Python packaging and Python tooling: various
Python TOML libraries have about 2000 reverse dependencies on PyPI. For
comparison, ``requests`` has about 28k reverse dependencies.


Rationale
=========

This PEP proposes basing the standard library support for reading TOML on the
third party library ``tomli`` [2]_.

Many projects have recently switched to using ``tomli``, for example, ``pip``,
``build``, ``pytest``, ``mypy``, ``black``, ``flit``, ``coverage``,
``setuptools-scm``, ``cibuildwheel``.

``tomli`` is actively maintained and well-tested. ``tomli`` is about 800 lines
of code with 100% test coverage and passes all tests in a test suite `proposed as
the official TOML compliance test suite <https://github.com/toml-lang/compliance/pull/8>`.

TODO: check tomli continues to pass https://github.com/BurntSushi/toml-test


Specification
=============

.. code-block::

   def load(fp: SupportsRead[bytes], /, *, parse_float: Callable[[str], Any] = float) -> dict[str, Any]: ...
   def loads(s: str, /, *, parse_float: Callable[[str], Any] = float) -> dict[str, Any]: ...

``tomllib.load`` deserializes a ``.read()``-supporting binary file containing a
TOML document to a Python object.

``tomllib.loads`` deserializes a str instance containing a TOML document to a
Python object.

``parse_float`` is a function that takes a string and returns a float, as with ``json.load``.
For example, ``decimal.Decimal`` in cases where precision is important.

``tomllib.TOMLDecodeError`` is raised in the case of invalid TOML.

Note that we currently do not propose ``tomllib.dump`` or ``tomllib.dumps``
functions, see `<Including an API for writing TOML_>`_ for details.


Maintenance Implications
========================

Stability of TOML
-----------------

The release of TOML v1 in January 2021 indicates stability. Empirically, TOML
has proven to be a stable format even prior to the release of TOML v1. From the
`changelog <https://github.com/toml-lang/toml/blob/master/CHANGELOG.md>`_, we
see TOML has had no major changes since April 2020 and has had two releases in
the last five years.

In the event of changes to the TOML specification, we could treat minor
revisions as bug fixes and update the implementation in place. In the event of
major breaking changes, we should preserve support for TOML v1.

Maintainability of proposed implementation
------------------------------------------

The proposed implementation (``tomli``) is in pure Python, well tested and
weighs under 1000 lines of code. It is minimalist, offering a smaller API
surface area than other TOML implementations.

The author of ``tomli`` is willing to help integrate ``tomli`` into the standard
library and help maintain it, `as per this
<https://github.com/hukkin/tomli/issues/141#issuecomment-998018972>`__.
One CPython core dev has indicated willingness to maintain a read API,
`as per this
<https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/88>`__.

There is unlikely to be demand for an extension module, since there is
relatively less need for performance in parsing TOML: it's rare for application
bottleneck to be reading configuration. Users with extreme performance needs can
use a third party library (as is already often the case with JSON, despite a
stdlib extension module).

TOML support a slippery slope for other things
----------------------------------------------

As discussed in motivations, TOML holds a special place in the Python ecosystem.
This chief reason to include TOML in the standard library does not apply to
other formats, such as YAML or MessagePack.

In addition, the simplicity of TOML can help serve as a dividing line, for
example, YAML is large and complicated.


Backwards Compatibility
=======================

This will have no backwards compatibility issues as it will create a new API.

Note that we avoid using the ``toml`` name for the module, to avoid backwards
compatibility implications for users who have pinned versions of the current
``toml`` PyPI package. For more details, see `<Alternative names for module_>`_.


Security Implications
=====================

Errors in the implementation could cause potential security issues. However, the
implementation will be in pure Python, which reduces surface area of attack.


How to Teach This
=================

The API of ``tomllib`` mimics that of other well-established file format libraries,
such as ``json`` and ``pickle``.


Reference Implementation
========================

Link to any existing implementation and details about its state, e.g. proof-of-concept.

https://github.com/hukkin/tomli

https://github.com/hukkin/tomli-w


Rejected Ideas
==============

Roundtripping style
-------------------

In general, ``tomllib.dumps(tomllib.loads(x))`` may not equal the same string as
``x``, since we make no effort to preserve comments, whitespace or other
stylistic choices.

Style preservation would allow tools to losslessly edit TOML files. Since TOML
is intended as human-readable and human-editable configuration, it's important
to preserve human markup.

However, only a relatively small fraction of use cases require losslessly
editing TOML, as judged by reverse dependencies the style preserving ``tomlkit``
library compared to that of other third party toml libraries. In particular, we
don't need it for the core Python packaging use cases or for tools that merely
need to read configuration.

Since this would make both the implementation and the API more complex, it seems
better to relegate this additional functionality to third party libraries.

Basing on another TOML implementation
-------------------------------------

Potential alternatives include:

* ``tomlkit``.
  ``tomlkit`` is well established, actively maintained and supports TOML v1.
  An important difference is that ``tomlkit`` supports style roundtripping. As a
  result, it has a more complex API and implementation (about 5x as much code as
  ``tomli``). The author does not believe that ``tomlkit`` is a good choice for
  the standard library.

* ``toml``.
  ``toml`` is a widely used library. However, it is not actively maintained,
  does not support TOML v1 and has several known bugs. Its API is more complex
  than that of ``tomli``. It has some very limited and mostly unused ability to
  preserve style through an undocumented decoder API. It has the ability to
  customise output style through a complicated encoder API. For more details on
  API differences to this PEP, refer to `Appendix A`_.

* ``pytomlpp``.
  ``pytomlpp`` is a Python wrapper for the C++ project ``toml++``. Pure Python
  libraries are easier to maintain than extension modules.

* ``rtoml``.
  ``rtoml`` is a Python wrapper for the Rust project ``toml-rs`` and hence has
  similar shortcomings to ``pytomlpp``. In addition, it does not support TOML v1.

* Writing from scratch.
  It's unclear what we would get from this: ``tomli`` meets our needs and the
  author is willing to help with its inclusion in the standard library.

Including an API for writing TOML
---------------------------------

There are several reasons to not include an API for writing TOML:

The ability to write TOML is not needed for the use cases that motivate this
PEP: for core Python packaging use cases or for tools that need to read
configuration.

As discussed in the previous section, use cases that involve editing TOML (as
opposed to writing brand new TOML) are better served by a style preserving
library.

There are several degrees of freedom in how to design a write API. For example,
how much control to allow users over output formatting, over serialization of
custom types, and over input and output validation. While there are reasonable
choices on how to resolve these, the nature of the standard library is such that
one only gets one chance to get things right. See `Appendix B`_. for an overview
of some of the design questions.

Currently no CPython core developers have expressed willingness to maintain a
write API or sponsor a PEP that includes a write API. Since it is hard to change
or remove something in the standard library, it is safer to err on the side of
exclusion and potentially revisit later.

That said, here are reasons to include an API for writing TOML:

Users will likely expect a write API to be available for consistency.

Empirically, writing TOML seems useful. On https://grep.app, there are about
1.3k hits for "toml.load" and "tomli.load", compared to about 400 hits for
"toml.dump" and "tomli_w.dump".

Even a simple API is capable of serving common use cases, such as testing code
that loads TOML or writing out simple or boilerplate TOML.
TODO: estimate prevalence of simple use cases

If we keep feature set narrow, a write API shouldn't be too much additional
burden. The fairly minimal implementation in ``tomli-w`` is about 200 lines
of code.


Assorted API details
--------------------

Types accepted by the first argument of ``tomllib.load``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``toml`` library on PyPI allows passing paths (and lists of path-like
objects, ignoring missing files and merging the documents into a single object).
Doing this would be inconsistent with ``json.load``, ``pickle.load``, etc. If we
agree consistency with other stdlib modules is desirable, allowing paths is
somewhat out of scope for this PEP. This can easily and explicitly be worked
around in user code.

The proposed API takes a ``SupportsRead[bytes]``, while ``toml.load`` takes a
``SupportsRead[str]`` and ``json.load`` takes ``SupportsRead[str | bytes]``.
Using ``SupportsRead[bytes]`` allows us to a) ensure utf-8 is the encoding used,
b) avoid incorrectly parsing single carriage returns as valid TOML due to
universal newlines.

Controlling the type of mappings returned by ``tomllib.load[s]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This would work similarly to common uses for the ``object_hook`` argument in
``json.load[s]``.

Such an argument is not necessary for the core use cases outlined in the
motivation section. The absence of this can be pretty easily worked around using
a wrapper class or transformer function. Finally, support could be added later
in a backward compatible way.

The ``toml`` library on PyPI supports this feature using the ``_dict`` argument.
There are several uses of this on https://grep.app, however, almost all of them
were passing ``_dict=OrderedDict``, which should be unnecessary as of Python
3.7. There were two instances of legitimate use: in one case, a custom class was
passed for friendlier KeyErrors, in another case, the custom class had several
additional lookup and mutation methods (e.g. to help resolve dotted keys).

Removing support for ``parse_float`` in ``tomllib.load[s]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This option is not strictly necessary, since TOML floats are "IEEE 754 binary64
values", which is ``float``. Using ``decimal.Decimal`` thus allows users extra
precision not promised by the TOML format. However, in the author of ``tomli``'s
experience, this is useful in scientific and financial applications. TOML-facing
users may include non-developers who are not aware of the limits of
double-precision float.

TODO: user quotes

Alternative names for module
----------------------------

Ideally, we would be able to use the ``toml`` module name.

However, the ``toml`` package on PyPI is widely used, so there are backward
compatibility concerns. Since the standard library takes precedence over third
party packages, users who have pinned versions of ``toml`` would be broken when
upgrading Python versions by any API incompatibilities.

To further clarify, the user pins are the specific concern here. Even if we were
able to get control over the ``toml`` PyPI package and repurpose it as a
standard library backport, we would still break users who have pinned to
versions of the current ``toml`` package. This is unfortunate, since pinning
would likely be a common response to breaking changes introduced by repurposing
the ``toml`` package as a backport (that is incompatible with today's ``toml``).

There are several API incompatibilities between ``toml`` and the API proposed in
this PEP. Here are the differences that a significant fraction of users are
likely to run into:

* Use of ``toml.dump`` and ``toml.dumps``, since this PEP does not propose
  an API for writing TOML.
* ``toml.load`` accepts a non-overlapping set of types from the proposed API for
  ``tomllib.load``. See `here <Types accepted by the first argument of
  tomllib.load_>`_ for the rationale.
* For invalid TOML, ``toml`` raises ``toml.TomlDecodeError`` vs the proposed
  :pep:`8` compliant ``tomllib.TOMLDecodeError``.

There are other minor or less widely used API differences. If interested, refer
to `Appendix A`_ for a more complete listing.

Finally, the ``toml`` package on PyPI is not actively maintained and `we have
been unable to contact the author <https://github.com/uiri/toml/issues/361>`,
so action here would likely have to be taken without the author's consent.

This PEP proposes ``tomllib``. This mirrors ``plistlib`` (another file format
module in the standard library), as well as several others such as ``pathlib``,
``graphlib``, etc.

Other bikesheds include:

* ``tomlparser``. This mirrors ``configparser``, but is perhaps slightly less
  appropriate if we include a write API in the future.
* ``tomli``. This assumes we use ``tomli`` as the basis for implementation.
* ``toml``, but under some namespace, such as ``parser.toml``. However, this is
  awkward, especially so since existing libraries like ``json``, ``pickle``,
  ``marshal``, ``html`` etc. would not be included in the namespace.


TODO: Random things
===================

Previous discussion:

* https://bugs.python.org/issue40059
* https://mail.python.org/archives/list/python-ideas@python.org/thread/IWJ3I32A4TY6CIVQ6ONPEBPWP4TOV2V7/
* https://mail.python.org/pipermail/python-dev/2019-May/157405.html
* https://github.com/hukkin/tomli/issues/141
* https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/84

Useful https://grep.app searches (note, ignore vendored):

* toml.load[s] usage https://grep.app/search?q=toml.load&filter[lang][0]=Python
* toml.dump[s] usage https://grep.app/search?q=toml.dump&filter[lang][0]=Python
* TomlEncoder subclasses https://grep.app/search?q=TomlEncoder%29%3A&filter[lang][0]=Python


References
==========

.. [1]
   TOML: Tom's Obvious Minimal Language
   https://toml.io/en/

.. [2]
   tomli
   https://github.com/hukkin/tomli

.. [3]
   tomli-w
   https://github.com/hukkin/tomli-w


.. _Appendix A:

Appendix A: Differences between proposed API and ``toml``
=========================================================

This appendix covers the differences between the API proposed in this PEP and
that of the third party package ``toml``. These differences are relevant to
understanding the amount of breakage we could expect if we used the ``toml``
name for the standard library module, as well as to better understand the design
space. Note that this list might not be exhaustive.

#. This PEP currently proposes not to include a write API. That is, there will
   be no equivalent of ``toml.dump`` or ``toml.dumps``.

   Discussed at `<Including an API for writing TOML_>`_.

   If we included a write API, it would be relatively simple to convert most
   code that uses ``toml`` to use the API proposed in this PEP (acknowledging
   that that is very different from a compatible API).

   A significant fraction of ``toml`` users rely on this.

#. Different first argument of ``toml.load``

   ``toml.load`` has the following signature:

   .. code-block::

       def load(
           f: Union[SupportsRead[str], str, bytes, list[PathLike | str | bytes]],
           _dict: Type[MutableMapping[str, Any]] = ...,
           decoder: TomlDecoder = ...,
       ) -> MutableMapping[str, Any]: ...

   This is pretty different from the first argument proposed in this PEP: ``SupportsRead[bytes]``.

   Recapping the reasons for this, previously mentioned at
   `<Types accepted by the first argument of tomllib.load_>`_:

   * Allowing passing of paths (and lists of path-like objects, ignoring missing
     files and merging the documents into a single object) is inconsistent with
     other similar functions in the standard library.
   * Using ``SupportsRead[bytes]`` allows us to a) ensure utf-8 is the encoding used,
     b) avoid incorrectly parsing single carriage returns as valid TOML due to
     universal newlines. TOML specifies file encoding and valid newline
     sequences, and hence is simply stricter format than what text file objects
     represent.

   A significant fraction of ``toml`` users rely on this.

#. Errors

   ``toml`` raises ``TomlDecodeError`` vs the proposed PEP 8 compliant
   ``TOMLDecodeError``.

   A significant fraction of ``toml`` users rely on this.

#. ``toml.load[s]`` accepts a ``_dict`` argument

   Discussed at `<Controlling the type of mappings returned by tomllib.load[s]_>`_.

   As discussed, almost all usage consists of ``_dict=OrderedDict``, which is
   not necessary in Python 3.7 and later.

#. ``toml.load[s]`` support an undocumented ``decoder`` argument

   It seems the intended use case is for an implementation of comment
   preservation. The information recorded is not sufficient to roundtrip the
   TOML document preserving style, the implementation has known bugs, the
   feature is undocumented and I could only find one instance of its use on
   https://grep.app.

   The ``toml.TomlDecoder`` interface exposed is not simple, containing nine methods.
   See `here <https://github.com/uiri/toml/blob/3f637dba5f68db63d4b30967fedda51c82459471/toml/decoder.pyi#L36>`__.

   Users are probably better served by a more complete implementation of style
   preserving parsing and writing.

#. ``toml.dump[s]`` support an ``encoder`` argument

   Note that we currently propose not to include a write API, however if that
   were to change, these differences would likely become relevant.

   This enables two use cases, a) control over how custom types should be
   serialized, b) control over how output should be formatted.

   The first use case is reasonable, however, I could only find two instances of
   this on https://grep.app. One of these two instances used this ability to add
   support for dumping ``decimal.Decimal`` (which a potential standard library
   implementation would support out of the box).

   If needed, this use case could be well served by the equivalent of the
   ``default`` argument in ``json.dump``.

   The second use case is enabled by allowing users to specify subclasses of
   ``toml.TomlEncoder`` and overriding methods to specify parts of the TOML
   writing process. The API consists of five methods and exposes a lot of
   implementation detail. See `here <https://github.com/uiri/toml/blob/3f637dba5f68db63d4b30967fedda51c82459471/toml/encoder.pyi#L9>`__.

   There is some usage of the ``encoder`` API on https://grep.app, however, it
   likely accounts for a tiny fraction of overall usage of ``toml``.

#. Timezones

   ``toml`` uses and exposes custom ``toml.tz.TomlTz`` timezone objects. The
   proposed implementation uses ``datetime.timezone`` objects from the standard
   library.


.. _Appendix B:

Appendix B: Designing a write API
=================================

This appendix discusses some of the degrees of freedom in the design space of
write APIs. This list is not exhaustive.


Providing users control over formatting
---------------------------------------

Values in TOML can be represented in multiple ways. This is a feature of TOML:
it allows users to phrase things to maximize subjective readability.
Inevitably, people will have strong opinions over how to do so.

Here is a non-exhaustive list of potential options users may want control over:

* How much to indent
* How to format strings (single-line or multiple-line, basic or literal)
* Whether newline sequences should be normalized (perhaps depending on ``os.linesep``)
* When to inline arrays or tables
* Whether to reorder contents
* Whether to use dotted keys

This isn't hypothetical, there are several instances in open source code of
users attempting to achieve TOML output with a given formatting.

The ``tomli-w`` library contains only one option to customise output formatting:
controlling whether strings containing newlines are written as multiline
strings. This option is a little tricky (and so defaults to False),
since it loses semantics that guarantee the bytes in newline sequences, for
instance in the case of ``tomli_w.dumps(tomli.loads(r'''s = "\r\n"'''),
multiline_strings=True)``

The ``toml`` library supports output formatting using custom subclasses of
``toml.TomlEncoder``. However, the API exposes a lot of implementation detail,
essentially allowing users to override parts of the TOML writing process. See
`here
<https://github.com/uiri/toml/blob/3f637dba5f68db63d4b30967fedda51c82459471/toml/encoder.pyi#L9>`__.

The ``tomlkit`` library is fully style preserving and allows users to specify
the exact output they want using an imperative document construction API.

It remains an option to make output mostly non-customizable, which should
maximizes forwards compatibility. In addition, in several cases users could
choose to enforce TOML formatting by using an autoformatter of their choice at a
later point.


Providing users control over serialization
------------------------------------------

It needs to be determined which types can be serialized to TOML out of the box.
For instance, ``tomli-w`` supports dumping ``decimal.Decimal``, while ``toml``
does not.

It could be useful to add the equivalent of the ``default`` argument in ``json.dump``
to allow users to specify how custom types should be serialized.

The ``toml`` library on PyPI supports this using subclasses of
``toml.TomlEncoder``. However, this functionality seems not often used in
practice. TOML is used more for configuration than serialization of arbitrary
data, so users are perhaps less likely to require custom serialization than with
say JSON.

It would be easy to add support for this later in a backward compatible way.


Providing users control over validation
---------------------------------------

TODO

Should we guarantee that either output TOML is valid or an error is raised?
(``tomli-w`` does not have this guarantee)

Should we detect circular references? (``toml``does, but ``tomli-w`` does not)


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End:
