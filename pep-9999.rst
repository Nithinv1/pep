PEP: 9999
Title: Editable installs
Author: Bernát Gábor <gaborjbernat@gmail.com>
Sponsor: TBD
Discussions-To: https://discuss.python.org/t/draft-pep-editable-installs-for-pep-517-style-build-backends/8510
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 28-May-2021
Post-History: 


Abstract
========

This document describes extensions to the build backend and frontend communication (as introduced by `PEP-517`_) to allow projects to be installed in editable mode.

Motivation
==========

During development, many Python users prefer to install their libraries so that changes to the underlying source code are automatically reflected in subsequent interpreter invocations without an additional installation step. This mode is usually called "development mode" or "editable installs". Currently, there is no standardized way to accomplish this, as it was explicitly left out of `PEP-517`_ due to the complexity of the actual observed behaviors.

At the moment, users can achieve this in a few ways:

- Adding the relevant source directories to ``sys.path`` (configurable from the command line interface via the ``PYTHONPATH`` environment variable). Note in this case, the users have to install the project dependencies themselves, and entry points or project metadata are not generated.
- `setuptools`_ provides the `setup.py develop`_ mechanism: installs a ``pth`` file that injects the project root onto the ``sys.path`` at interpreter startup time, generates the project metadata, and also installs project dependencies. `pip`_ exposes calling this mechanism via the `pip install -e <project_directory>`_ command-line interface.
- `flit`_ provides the `flit install --symlink`_ command that symlinks the project files into the interpreters ``purelib`` folder, generates the project metadata, and also installs dependencies.

This PEP aims to delineate the frontend and the backend roles clearly and give the developers of each the maximum ability to provide valuable features to their users. In this proposal, the backend's role is to prepare the project for an editable installation and enumerating how the installed layout maps onto the layout on disk; the frontend's role is to take this mapping and expose the relevant files to the target interpreter. Project metadata follows the same responsibility structure as in `PEP-517`_.

Rationale
=========

`PEP-517`_ deferred "Editable installs" because this would have delayed further its adoption, and there wasn't an agreement on how editable installs should be achieved. Due to the popularity of the `setuptools`_ and `pip`_ projects, the status quo prevailed, and the backend could achieve editable mode by providing
a ``setup.py develop`` implementation, which the user could trigger via `pip install -e <project_directory>`_. By defining an editable interface
between the build backend and frontend, we can eliminate the ``setup.py`` file and their current communication method.

Terminology and goals
=====================

The editable installation mode implies that the source code of the project being installed is available in a local directory.

Once the project is installed in editable mode, some changes to the project code in the local source tree will become effective without the need for a new installation step. At a minimum, changes to the text of non-generated files that existed at the installation time should be reflected upon the subsequent import of the package.

Some kinds of changes, such as adding or modifying entry points or new dependencies, require a new installation step to become effective. These changes are typically made in build backend configuration files (such as ``pyproject.toml``). This requirement is consistent with the general user expectation that such modifications will only become effective after re-installation.

While users expect editable installations to behave identically to standard installations, this may not always be possible and may be in tension with other user expectations. Depending on how a frontend implements the editable mode, some differences may be visible, such as the presence of additional files (compared to a typical installation), either in the source tree or the interpreter's installation path. Frontends should seek to minimize differences between the behavior of editable and standard installations and document known differences.

For reference, a non-editable installation works as follows:

1. The **developer** is using a tool, we'll call it here the **frontend**, to drive the project development (e.g., `pip`_). When the user wants to trigger a package build and installation of a project, they'll communicate with the **frontend**.
2. The frontend uses a **build frontend** to trigger the build of a wheel (e.g., `build`_). The build frontend uses `PEP-517`_ to communicate with the **build backend** (e.g. `setuptools`_) - with the build backend installed into a `PEP-518`_ environment. Once invoked, the backend returns a wheel.
3. The frontend takes the wheel and feeds it to an **installer** (e.g.,`installer`_) to install the wheel into the target Python interpreter.

The Mechanism
=============

This PEP adds two optional hooks to the `PEP-517`_ backend interface. One of the hooks is used to specify the build dependencies of an editable install. The other hook returns the necessary information via the build frontend the frontend needs to create an editable install.

get_requires_for_build_editable
-------------------------------

::

  def get_requires_for_build_editable(config_settings=None):
      ...

This hook MUST return an additional sequence of strings containing `PEP-508`_ dependency specifications, above and beyond those specified in the ``pyproject.toml`` file. The frontend must ensure that these dependencies are available in the build environment in which the ``build_editable`` hook is called.

If not defined, the default implementation is equivalent to returning ``[]``.

build_editable
--------------

::

  def build_editable(config_settings=None):
      ...

The function returns an object of type ``EditableInfo`` as defined below:

::

  from typing import Mapping, Sequence, TypedDict


  class RequiredEditableInfo(TypedDict, total=True):
      version: int
      """protocol version of the editable metadata, this PEP defines version 1"""

      metadata_for_build_editable: str
      """distribution information of the package as defined by PEP-491"""

  class EditableInfo(RequiredEditableInfo, total=False):

      purelib_paths: Mapping[str, str]
      """files or folders that should be available under the purelib"""

      platlib_paths: Mapping[str, str]
      """files or folders that should be available under the platlib"""



The ``purelib`` and ``platlib`` paths map from project source absolute paths to target directory relative paths. We allow backends to change the project layout from the project source directory to what the interpreter will see by using the mapping.

Build frontend requirements
---------------------------

The build frontend is responsible for setting up the environment for the build backend to generate the necessary information for an editable build. It's also responsible for communicating with the backend and receiving the ``EditableInfo`` object. All recommendations from `PEP-517`_ for the build wheel hook applies here too.

Frontend requirements
---------------------

The frontend is responsible for ensuring the ``.dist-info`` folder is available at runtime within the target interpreter for the ``importlib.metadata`` and ``importlib.resources`` modules.

The frontend must ensure that all installation requirements specified in the distribution information files are installed as part of the editable installation into the target interpreter. Additionally, the user might also select additional ``extras`` groups that also should be installed as part of the editable installation.

The frontend also must generate entrypoints, which may be for the console or the GUI. Those entrypoints are defined by the distribution information files, which are generated during the editable installation process.

The frontend is responsible for generating the ``RECORD`` file based on the object the build backend returns and their chosen editable implementation. For this reason, the uninstallation of editables should not require any special treatment.

The frontend must create a ``direct_url.json`` file in the ``.dist-info`` directory of the installed distribution, in compliance with PEP 610. The ``url`` value must be a ``file://`` URL pointing to the project directory (i.e., the directory containing ``pyproject.toml``), and the ``dir_info`` value must be ``{'editable': true}``.

The frontend must not rely on the ``prepare_metadata_for_build_wheel`` hook when installing in editable mode. It must instead invoke ``build_editable`` and use the ``.dist-info`` folder returned by that.

Example editable implementations
--------------------------------

To show how this PEP might be used, we'll now present a few case studies. Note the offered solutions are purely for illustrating purpose.

Add the source tree as is to the interpreter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is one of the simplest implementations, it will add the source tree as is into the interpreters schema paths.

::

    {
      "metadata_for_build_editable": "<dir to dist-info>",
      "purelib": {"<project dir>": "<project dir>"}
    }

The frontend then could either:

- Add the source directory onto the target interpreters ``sys.path`` during startup of it. This is done by creating a ``pth`` file into the target interpreters ``purelib`` folder. `setuptools`_ does this today and is what `pip install -e <project_directory>`_ translate too. This solution is fast and cross-platform compatible. However, this puts the entire source tree onto the system, potentially exposing modules that would not be available in a standard installation case.
- Symlink the folder, or the individual files within it. This method is what flit does via its `flit install --symlink`_. This solution requires the current platform to support symlinks. Still, it allows potentially to symlink individual files, which could solve the problem of including files that should be excluded from the source tree.

Using custom importers
~~~~~~~~~~~~~~~~~~~~~~

For a more robust and more dynamic collaboration between the build backend and the target interpreter, we can take advantage of the import system allowing the registration of custom importers. See `PEP-302`_ for more details and `editables`_ as an example of this. The backend can generate a new importer during the editable build (or install it as an additional dependency) and register it at interpreter startup by adding a ``pth`` file.

::

    {
      "metadata_for_build_editable": "<dir to dist-info>",
      "purelib": {
           "<project dir>/.editable/_register_importer.pth": "<project dir>/_register_importer.pth".
           "<project dir>/.editable/_editable_importer.py": "<project dir>/_editable_importer.py"
      }
    }

The backend here registered a hook that is called whenever a new module is imported, allowing dynamic and on-demand functionality. Potential use cases where this is useful:

- Expose a source folder, but honor module excludes: the backend may generate an import hook that consults the exclusion table before allowing a source file loader to discover a file in the source directory or not.
- For a project, let there be two modules, ``A.py`` and ``B.py``. These are two separate files in the source directory; however, while building a wheel, they are merged into one mega file ``project.py``. In this case, with this PEP, the backend could generate an import hook that reads the source files at import time and merges them in memory before materializing it as a module.
- Automatically update out-of-date C-extensions: the backend may generate an import hook that checks the last modified timestamp for a C-extension source file. If it is greater than the current C-extension binary, trigger an update by calling the compiler before import.

Rejected ideas
==============

This PEP competes with ``PEP-660`` and rejects that proposal because we think the mechanism of achieving an editable installation should be within the build frontend rather than the build backend. Furthermore, this approach allows the ecosystem to use alternative means to accomplish the editable installation effect (e.g., insert path on ``sys.path`` or symlinks instead of just implying the loose wheel mode from the backend described by that PEP).

References
==========

.. _`PEP-302`: https://www.python.org/dev/peps/pep-0517/
.. _`PEP-517`: https://www.python.org/dev/peps/pep-0517/
.. _`PEP-508`: https://www.python.org/dev/peps/pep-0508/
.. _`PEP-518`: https://www.python.org/dev/peps/pep-0518/
.. _`setuptools`: https://setuptools.readthedocs.io/en/latest/
.. _`setup.py develop`: https://setuptools.readthedocs.io/en/latest/userguide/commands.html#develop-deploy-the-project-source-in-development-mode
.. _`pip`: https://pip.pypa.io
.. _`installer`: https://pypi.org/project/installer
.. _`build`: https://pypa-build.readthedocs.io
.. _`pip install -e <project_directory>`: https://pip.pypa.io/en/stable/cli/pip_install/#install-editable
.. _`flit`: https://flit.readthedocs.io/en/latest/index.html
.. _`flit install --symlink`: https://flit.readthedocs.io/en/latest/cmdline.html#cmdoption-flit-install-s
.. _`editables`: https://pypi.org/project/editables


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
