PEP: 9999
Title: A rolling feature release stream for CPython
Version: $Revision$
Last-Modified: $Date$
Author: Steve Dower <steve.dower@python.org>, Nick Coghlan <ncoghlan@gmail.com>
Discussions-To: https://discuss.python.org/t/pep-602-annual-release-cycle-for-python/2296
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created: 20-Sep-2019
Python-Version: 3.9


Abstract
========

Rather than proposing a change to CPython's release cadence (as PEP 602 does),
or a change to CPython's policy for when new features can be added to a release
series (as PEP 598 does), this PEP proposes that we instead amend CPython's
pre-release management process as follows:

* Feature freeze, ABI freeze, bytecode format freeze, and maintenance branch
  creation all correspond with the first release candidate for an X.Y.0 release
* The X.Y.0 release candidate period is extended from 3 weeks to 2 months
* Beta releases occur every other month whenever there is no X.Y.0 release in
  the release candidate phase
* During the beta release period, all newly added interfaces are considered
  provisional, and each new release may introduce new deprecation warnings
  (or escalate previous deprecation warnings to errors)
* Routine alpha releases are removed from the process (release managers may
  still choose to publish them if they feel the releases are appropriate)

As part of this change, the current "not for production use" guidance given for
beta releases would be amended to state "suitable for production use only in
environments with sufficiently robust compatibility testing and operational
monitoring capabilities".

This PEP also proposes that the frequency of X.Y.0 releases be adjusted to
target publishing a new release series in August of odd-numbered years
(2021, 2023, etc).


Background
==========

The current CPython pre-release and release management processes were developed
in an era where automated continuous integration and operational monitoring
systems were still relatively immature. Since that time, many organisations
have adopted deployment models that allow them to incorporate new CPython
feature releases without adding substantially more risk than they incur for any other
code change.

In light of those changes in the wider environment, PEP 602 has proposed reducing
the feature delivery latency for the Python standard library and CPython
reference interpreter by increasing the frequency of CPython feature releases
from every 18-24 months to instead occur every 12 months.

Unfortunately, for many organisations, the cost of adopting a new Python release
doesn't automatically scale down with a reduced number of changes in the release,
as the primary costs aren't associated with resolving any discovered issues:
the primary costs are associated with the *search* for issues. This search may
involve manual testing of software systems, human review of written materials,
and other activities where the time required scales with the size of the
existing system, rather than the number of changes between the versions of
Python.

PEP 598 was an initial attempt by one of the authors of this PEP to propose
an alternative scheme to reduce feature delivery latency by adopting a
semantic versioning style policy that allowed for the incremental delivery of
backwards compatible features within a release series, until that series
reached feature complete status. The major difference between that proposal
and this one is to move the incremental feature delivery period into the
pre-release phase of development (before strict API and ABI stability
requirements apply), rather than applying it to the initial X.Y.Z minor
releases within a series.


Example Future Release Schedules
================================

Under this proposal, Python 3.9.0b1 would be released in December 2019, two
months after the Python 3.8.0 baseline feature release in October 2019.

The 3.9.0b2 release would then follow 2 months later in February 2020,
continuing through to 3.9.0b9 in April 2021.

3.9.0rc1 would be published in June 2021, 3.9.0rc2 in July 2021, and then
then the full release published as 3.9.0 in August 2021.

The cycle would start over again in October 2021, with the publication
of 3.10.0b1.

Assuming maintenance releases of 3.9.x were also to occur every other month
(offset from the 3.10.0 beta releases), the overall release timeline
would look like:

* 2019-12: 3.9.0b1
* ... beta releases every other month
* 2021-04: 3.9.0b9
* 2021-06: 3.9.0rc1 (feature freeze, ABI freeze, pyc format freeze)
* 2021-07: 3.9.0rc2
* 2021-08: 3.9.0
* 2021-09: 3.9.1, 3.8.x (final 3.8.x binary maintenance release)
* 2021-10: 3.10.0b1
* 2021-11: 3.9.2
* 2021-12: 3.10.0b2
* ... beta and maintenance releases every other month
* 2022-04: 3.10.0b10
* 2022-05: 3.9.11
* 2022-06: 3.10.0rc1 (feature freeze, ABI freeze, pyc format freeze)
* 2022-07: 3.10.0rc2, 3.9.12
* 2022-08: 3.10.0
* 2022-09: 3.10.1, 3.9.13 (final 3.9.x binary maintenance release)


(The exact schedule of maintenance releases would be up to the release team -
alternating months with the rolling beta releases is just one possibility)

In this model, there are always two or three active maintenance branches, as in
the status quo.


Proposal
========

TODO (more details than the abstract, less detail than the design discussion)

Some specific points to cover (either here or in the design discussion):

- automatically appending "-unstable" to SOABI prior to rc1 to help make it
  clear that only extension modules (and wheel archives) targeting the stable
  C ABI can be reliably used across the different beta releases
- potentially consider doing the same for pyc cache files
- address the pickle forward and backward compatibility question
- consider changing documentation versionadded/changed notes to include the
  beta release version (for the benefit of beta release users)


Caveats and Limitations
=======================

Actual release dates may be adjusted up to a month earlier or later at
the discretion of the release manager, based on release team availability, and
the timing of other events (e.g. PyCon US, or the annual core developer
sprints). However, part of the goal of this proposal is to provide a consistent
cadence for both contributors and end users, so adjustments ideally would be
rare.

Within a release series, the exact frequency of maintenance releases would
still be up to the release manager and the binary release team; this PEP
only proposes an expected cadence for pre-releases and X.Y.0 releases.

However, for the sake of the example timelines, the PEP assumes maintenance
releases every other month, as is being proposed for the rolling beta releases.


Design Discussion
=================

Why this proposal over simply doing more frequent baseline feature releases?
----------------------------------------------------------------------------

For large parts of Python's user base, *availability* of new CPython feature
releases isn't the limiting factor on their adoption of those new releases.
As such, any proposal based on speeding up full feature releases needs to strike
a balance between meeting the needs of users who would be adopting each release
as it became available, and those that would now be in a position of adopting
every 2nd, 3rd, or 4th release, rather than migrating to every release (albeit
potentially with a lag of 12 months or more).

This proposal aims to approach the problem from a different angle by defining a
*new* production-ready release stream that is more specifically tailored to the
interests of operating environments that are in a position to consume new
releases as fast as the CPython core team is prepared to produce them.


Why "continuous beta" rather than "continuous alpha"?
-----------------------------------------------------

The code quality standards upheld by the CPython code review process and
BuildBot fleet make the "beta" label more suitable than the "alpha" label.

Plus folks are more likely to actually use beta releases.


Why not use Calendar Versioning for the rolling release stream?
---------------------------------------------------------------

Steve Dower's initial write-up of this proposal [1_] suggested the use of
calendar versioning for the rolling release stream (so Python 2019.12 rather
than 3.9.0b1, etc).

Paul Moore pointed out [2_] two major practical problems with that proposal:

* it makes it hard for users of the calendar-based versions to know where they
  stand in relation to the traditionally numbered versions
* it breaks ``Python-Requires`` metadata processing (since all calendar
  versions would appear as newer than any standard version)

This PEP aims to address both of those problems by using the established beta
version numbers for the rolling releases.

The beta numbering approach also avoids other questions raised by the calendar
versioning concept, such as how ``sys.version_info``, ``Py_VERSION_HEX``,
``site-packages`` directory naming, and installed binary naming would work.


Implications for Python library development
-------------------------------------------

By using the "beta" labelling rather than the incremental feature release
numbering proposed in PEP 598, the hope would be that consumers of these
new rolling releases would realise that they're likely going to need to build their
own wheel archives from source, and will generally be more prone to encountering
library compatibility issues when updating to a new release.

Library authors who actually want to support the beta stream would have the
option of testing against the latest beta release in their pre-merge test
matrices (just as they test against the latest maintenance release of previously
published versions), with the CPython nightly builds offered by some CI
providers used solely in an advisory capacity for early detection of potential
compatibility problems.


Implications for the proposed Scientific Python ecosystem support period
------------------------------------------------------------------------

Based on discussions at SciPy 2019, a NEP (NumPy Enhancement Proposal) is currently being drafted [3_] to
define a common convention across the Scientific Python ecosystem for dropping
support for older Python versions.

While the exact formulation of that policy is still being discussed, the initial
proposal was very simple: support any Python feature release published within
the last 42 months.

For an 18 month feature release cadence, that works out to always supporting at
least the two most recent feature releases, and then dropping support for all
X.Y.z releases around 6 months after X.(Y+2).0 is released. This means there is
a 6 month period roughly every other year where the three most recent feature
releases are supported.

For a 12 month release cadence, it would work out to always supporting at
least the three most recent feature releases, and then dropping support for all
X.Y.z releases around 6 months after X.(Y+3).0 is released. This means that
for half of each year, the four most recent feature releases would be supported.

For a 24 month release cadence, a 42 month support cycle works out to always
supporting at least the most recent feature release, and then dropping support
for all X.Y.z feature releases around 18 months after X.(Y+1).0 is released.
This means there is a 6 month period every other year where only one feature
release is supported. If the support cycle is increased to 48 months, then
that restores the characteristics of always supporting at least the two most
recent feature releases.


Implications for simple deployment environments
-----------------------------------------------

TODO ()


Implications for complex deployment environments
------------------------------------------------

TODO ()


References
==========

.. [1] Steve Dower's initial "Fast and Stable releases" proposal
       (https://discuss.python.org/t/pep-602-annual-release-cycle-for-python/2296/20)

.. [2] Paul Moore's initial comments on Steve's proposal
       (https://discuss.python.org/t/pep-602-annual-release-cycle-for-python/2296/37)

.. [3] NEP proposing a standard policy for dropping support of old Python versions
       (https://github.com/numpy/numpy/pull/14086)

Copyright
=========

This document has been placed in the public domain.


..
  Local Variables:
  mode: indented-text
  indent-tabs-mode: nil
  sentence-end-double-space: t
  fill-column: 80
  coding: utf-8
  End:
