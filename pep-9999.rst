PEP: 9999
Title: Using TypedDict for more precise **kwargs typing
Author: Franek Magiera <framagie@gmail.com>
Sponsor: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 29-May-2022
Python-Version: 3.12
Post-History: 29-May-2022


Abstract
========

Current specification enables for type hinting ``**kwargs`` as long as all of the keyword arguments specified by them are of the same type. However, that behaviour can be very limiting. Therefore, in this PEP we propose a new way to enable more precise ``**kwargs`` typing. The new approach revolves around using ``TypedDict`` to type ``**kwargs`` that comprise keyword arguments of different types.

Motivation
==========

Currently annotating ``**kwargs`` with a type ``T`` means that the ``kwargs`` type is in fact ``Dict[str, T]``. For example:

::

    def foo(**kwargs: str) -> None: ...

means that all keyword arguments in ``foo`` are strings (i.e. ``kwargs`` is of type ``Dict[str, str]``). This behaviour limits the ability to type annotate ``**kwargs`` only to the cases where all of them are of the same type. However, it is often the case that keyword arguments conveyed by ``**kwargs`` have different types that are dependent on the keyword's name. In those cases type annotating ``**kwargs`` is not possible. This is especially a problem for already existing codebases where the need of refactoring the code in order to introduce proper type annotations may be considered not worth the effort. This in turn prevents the project from getting all of the benefits that type hinting can provide. As a consequence, there has been a lot of discussion around supporting more precise ``**kwargs`` typing [#mypyIssue4441]_ and it became a feature that is necessary for a large part of Python community.

Rationale
=========

PEP 589 introduced the ``TypedDict`` type constructor that supports dictionary types consisting of string keys and values of potentially different types. This makes ``TypedDict`` a perfect candidate to be used for more precise ``**kwargs`` typing. However, specifing ``**kwargs`` type using a ``TypedDict`` means, as mentioned earlier, that each keyword argument specified by ``**kwargs`` is a ``TypedDict`` itself. For instance:

::

    class Movie(TypedDict):
        name: str
        year: int
    
    def foo(**kwargs: Movie) -> None: ...

means that each keyword argument in ``foo`` is itself a ``Movie`` dictionary that has a ``name`` key with a string type value and a ``year`` key with an integer type value. Therefore, in order to support specifing ``kwargs`` type as a ``TypedDict`` without breaking current behaviour, a new syntax has to be introduced.

Specification
=============

To support the aforementioned use case we propose to use the double asterisk syntax inside of the type annotation. The required grammar change is discussed in more detail in section `Grammar Changes`_. Continuing the previous example:

::

    def foo(**kwargs: **Movie) -> None: ...

would mean that the ``**kwargs`` comprise two keyword arguments specified by ``Movie`` (i.e. a ``name`` keyword of type ``str`` and a ``year`` keyword of type ``int``). Then, inside the function itself, appropriate type checking would take place:

::

    def foo(**kwargs: **Movie) -> None:
        kwargs["name"].capitalize()      # OK!
        kwargs["year"] + 42              # OK!
        kwargs["name"] + kwargs["year"]  # WRONG! Unsupported operand types for + ("str" and "int")

The ``kwargs`` parameter inside the function should be treated exactly the same way as any other ``TypedDict``.

Function calls with standard dictionaries
-----------------------------------------

Calling a function that has ``**kwargs`` typed using the ``**kwargs: **Movie`` sytnax with a standard dictionary must raise an error. For example:

::

    def foo(**kwargs: **Movie) -> None: ...

    movie: dict[str, str] = {"name": "Life of Brian", "year": 1979}
    foo(**movie)  # WRONG! Movie is of type dict[str, str]

    typedMovie: Movie = {"name": "The Meaning of Life", "year": 1983}
    foo(**typedMovie)  # OK!


However, if the dictionary is completely untyped it is up to the type checker whether to raise an error or not:

::

    def foo(**kwargs: **Movie) -> None: ...

    movie = {"name": "Life of Brian", "year": 1979} 

    foo(**movie)  # Error/Success dependant on the type checker.


Keyword collisions
------------------

A ``TypedDict`` that is used to type ``**kwargs`` could potentially contain keys that are already defined in the function's signature. If the duplicate name is a standard argument, an error should be raised. If the duplicate name is a positional only argument, no errors should be raised. For example:

::

    def foo(name, **kwargs: **Movie) -> None: ...     # WRONG! "name" will always bind to the first parameter.

    def foo(name, /, **kwargs: **Movie) -> None: ...  # OK! "name" is a positional argument, so **kwargs can contain a "name" keyword


Required and non-required keys
------------------------------

By default all keys in a ``TypedDict`` are required. This behaviour can be overriden by setting the dictionary's ``total`` parameter as ``False``:

::

    class Movie(TypedDict, total=False):
        title: str
        year: int 

    dictionary: Movie = {"title": "Life of Brian"}         # OK! "year" is not required.
    dictionary = {"title": "Life of Brian", "year": 1979}  # OK!

Moreover, PEP 655 introduced new type qualifiers - ``typing.Required`` and ``typing.NotRequired`` - that enable specyfing whether a particular key is required or not:

::

    class Movie(TypedDict):
        title: str
        year: NotRequired[int]

When using a ``TypedDict`` to type ``**kwargs`` all of the required and non-required keys should correspond to required and non-required function keyword parameters. Therefore, if a required key is not supported by the caller, then an error must be raised.

Assignment
----------
A function typed using the ``**kwargs: **Movie`` construct can be assigned to another callable type only if they are compatible. This can happen in the following cases:

1. Both destination and source have a ``**kwargs: **TypedDict`` parameter, the destination ``TypedDict`` is assignable to the source ``TypedDict`` and the rest of the parameters are the compatible.

2. If the destination callable contains traditionally typed ``**kwargs: T`` and the source callable is typed using ``**kwargs: **TypedDict`` then each ``TypedDict`` value has to be assignable to type ``T``. Again, the rest of the parameters has to be compatible.

3. If the destination callable doesn't contain ``**kwargs`` and the source callable contains ``**kwargs: **TypedDict`` then all of the ``TypedDict`` fields should be assignable to individual named parameters. Again, the rest of the parameters has to be compatible. For example:

::

    class MovieBase(TypedDict, total=True):
        title: str
    
    class Movie(MovieBase, total=False):
        year: int
    
    def foo(**kwargs: **Movie): ...
    def bar(title: str, year: int = ...): ...

    bar = foo  # OK!

4. If the destination callable contains ``**kwargs: **TypedDict`` and the source callable containes either untyped or traditionally typed ``**kwargs: T`` then an error should be raised.

5. If the destination callable contains ``**kwargs: **TypedDict`` then source callable should have keyword parameters assignable to the key value pairs in the ``TypedDict``. Again, the rest of the parameters should be compatible.

``TypedDict`` unions
--------------------

It is possible to create unions of typed dictionaries. However, supporting typing ``**kwargs`` with a union of typed dicts would greatly increase the complexity of the implementation of this PEP and there seems to be no compelling use case to justify the support for this. Therefore, using unions of typed dictionaries to type ``**kwargs`` as described in the context of this PEP should result in an error:

::

    class Book(TypedDict):
        genre: str
        pages: int
    
    TypedDictUnion = Movie | Book

    def foo(**kwargs: **TypedDictUnion) -> None: ...  # WRONG! Cannot use a union of TypedDicts to type **kwargs


Additional keys
---------------

A big advantage of using ``**kwargs`` is the ability to pass arbitrary dictionaries containing keyword-value pairs to the function and let the function pick and use only the ones it needs. However, currently, there is no way to define a ``TypedDict`` that would allow additional keys, so supporting this feature would require an addition to the ``TypedDict`` specification. If this limitation blocks the acceptance of this PEP, then the PEP's scope would have to be extended or a new PEP proposing additional keys for ``TypedDict`` would have to be proposed.

Grammar Changes
===============
This PEP requires a grammar change so that the double asterisk syntax is allowed for ``**kwargs`` annotations. The proposed change is to extend the ``kwds`` rule as follows:

Before:

::

    kwds: '**' param_no_default 


After:

::

    kwds:
        | '**' param_no_default_double_star_annotation
        | '**' param_no_default

    param_no_default_double_star_annotation:
        | param_double_star_annotation & ')'

    param_double_star_annotation: NAME double_star_annotation

    double_star_annotation: ':' double_star_expression

    double_star_expression: '**' expression

A new AST node needs to be created so that type checkers can differentiate the semantics of the new syntax and take into account that the ``**kwargs`` should be unpacked. The proposition is to add a new ``DoubleStarred`` AST node. Then, an AST node for the function defined as:

::

    def foo(**kwargs: **Movie): ...

should look as below:

::

    FunctionDef(
      name='foo',
      args=arguments(
        posonlyargs=[],
        args=[],
        kwonlyargs=[],
        kw_defaults=[],
        kwarg=arg(
          arg='kwargs',
          annotation=DoubleStarred(
            value=Name(id='Movie', ctx=Load()),
            ctx=Load())),
        defaults=[]),
      body=[
        Expr(
          value=Constant(value=Ellipsis))],
      decorator_list=[])],
    type_ignores=[])

The runtime annotations should be consistent with the AST. Continuing the previous example:

::

    >>> def foo(**kwargs: **Movie): ...
    ...
    >>> foo.__annotations__
    {'kwargs': **Movie}

In order to make the runtime behaviour consistent with the AST as shown above we propose to:

1. Add a new ``_UnpackedTypedDict`` class to the ``typing`` module and include it in ``_TypedDictMeta`` as a ``_unpacked`` property.
2. Add a special ``__unpack__`` method to the ``_TpedDictMeta`` class that would return an instance of the ``_UnpackedTypedDict``.

Then, specyfing ``def foo(**kwargs: **Movie): ...`` would call an ``__unpack__`` special method on ``Movie``.

To be more precise the changes in the ``typing`` module would look as follows:

::

    class _UnpackedTypedDict:
        def __init__(self, name):
            self._name = name

        def __repr__(self):
            return '**' + self._name 
    
    class _TypedDictMeta(type):
        def __init__(self, name):
            self._name = name
            self._unpacked = _UnpackedTypedDict(name)

        def __unpack__(self):
            return self._unpacked


Implications
------------

With this change some of the allowed annotations would make no sense, for example:

::

    def foo(**kwargs: **int): ...

Those kind of issues should be addressed by static type checkers. Specifically, the new double asterisk syntax should be only used with instances of ``TypedDict``. At runtime the objects that do not have an ``__unpack__`` method should behave as below:

::

    >>> def foo(**kwargs: **int): ...
    ...
    AttributeError: type object 'int' has no attribute '__unpack__'

Backwards Compatibility
-----------------------

Using the double asterisk operator for annotating ``**kwargs`` is a syntax that would be only available in new versions of Python. PEP 646 dealt with the similar problem and its authors introduced a new type operator ``Unpack``. For the purposes of this PEP, the proposition is to reuse ``Unpack`` for more precise ``**kwargs`` typing. For example:

::

    def foo(**kwargs: Unpack[Movie]) -> None: ...

There are several reasons for reusing PEP 646's ``Unpack``. Firstly, the name is quite suitable and intuitive for the ``**kwargs`` typing use case as the keywords arguments are "unpacked" from the ``TypedDict``. Secondly, there would be no need to introduce any new special forms. Lastly, the use of ``Unpack`` for the purposes described in this PEP does not interfere with the use cases described in PEP 646.

Alternatives
------------

Instead of making the grammar change, ``Unpack`` could be the only way to annotate ``**kwargs`` of different types. However, introducing the double asterisk syntax has two advantages. Namely, it is more concise and more intuitive than using ``Unpack``.

Reference Implementation
========================

There is a proof-of-concept implementation of typing ``**kwargs`` using ``TypedDict`` on GitHub [#mypyPull10576]_, [#mypyExtensionsPull22]_ based on mypy. The implementation uses ``Expand`` instead of ``Unpack``.

Pyright type checker provides a provisional support for this feature [#pyrightIssue3002]_, [#pyrightProvisionalImplementation]_.

A proof-of-concept implementation of the cpython grammar changes described in this PEP is available on Github[#cpythonGrammarChangePoc]_.

References
==========

.. [#mypyIssue4441] python/mypy issue #4441:
   https://github.com/python/mypy/issues/4441

.. [#mypyPull10576] python/mypy pull request #10576:
   https://github.com/python/mypy/pull/10576

.. [#mypyExtensionsPull22] python/mypy_extensions pull request #22:
   https://github.com/python/mypy_extensions/pull/22/files

.. [#pyrightIssue3002] pyright issue #3002:
   https://github.com/microsoft/pyright/issues/3002

.. [#pyrightProvisionalImplementation] pyright provisional implementation:
   https://github.com/microsoft/pyright/commit/5bee749eb171979e3f526cd8e5bf66b00593378a

.. [#cpythonGrammarChangePoc] naive grammar change poc implementation:
   https://github.com/python/cpython/compare/main...franekmagiera:annotate-kwargs

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.

..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End: