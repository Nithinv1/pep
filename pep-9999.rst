PEP: 9999
Title: Type Parameter Syntax
Version: $Revision$
Last-Modified: $Date$
Author: Eric Traut <erictr at microsoft.com>
Sponsor: Guido van Rossum <guido@python.org>
Discussions-To: typing-sig@python.org
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 15-Jun-2022
Python-Version: 3.12


Abstract
========

This PEP specifies an improved syntax for specifying type parameters within
a generic class, function or type alias.


Motivation
==========

:pep:`0484` introduced type variables into the language. :pep:`0612` built
upon this concept by introducing parameter specification variables, and
:pep:`0646` added variadic type variables.

Points of Confusion
-------------------

While the use of type variables has become widespread, the manner in which
they are specified within code is the source of significant confusion among
Python developers. There are a couple of factors that contribute to this
confusion.

The scoping rules for type variables are difficult to understand. Type
variables are typically allocated within the global scope, but their semantic
meaning is valid only when used within the context of a generic class,
function or or type alias. A single runtime instance of a type variable may be
reused in multiple generic contexts, and it has a different semantic meaning
in each of these contexts. This PEP proposes to eliminate this source of
confusion by declaring type parameters at a natural place within a class,
function or type alias declaration.

Generic type aliases are often misused because it is not clear to developers
that a type argument must be supplied when the type alias is used. This leads
to an implied type argument of ``Any``, which is rarely the intent. This PEP
proposes to add new syntax that makes generic type alias declarations
clear.

:pep:`0483` and :pep:`0484` introduced the concept of "variance" for a type
variable used within a generic class. Type variables can be invariant,
covariant, or contravariant. The concept of variance is an advanced detail
of type theory that is not well understood by most Python developers, yet
it they are immediately confronted with the concept today when defining their
first generic class. This PEP largely eliminates the need for most developers
to understand the concept of variance when defining generic classes.

The rules for type parameter ordering is confusing. It is normally based on
the order which they first appear within a class declaration, function
or type alias. However, this can be overridden in a class definition by
including a "Generic" or "Protocol" base class. This PEP proposes to make
type parameter ordering explicit in all cases.

There is currently a way to specify the type arguments for a generic class
or type alias explicitly. This is known as "specialization", and it uses
a subscript expression (e.g. ``dict[str, int]`` or ``MyAlias[int]``).
There is currently no way to provide explicit type arguments for a generic
function. This PEP proposes to address this gap and allow functions to be
used in subscript expressions at runtime (e.g. ``my_function[str]``).

The practice of sharing a type variable across multiple generic contexts
creates other problems today. Modern editors provide features like "find
all references" and "rename all references" that are semantically aware, but
these features do not work as intended when the type variable is shared.

Type variables defined within the global scope also need to be given a name
that starts with an underscore to indicate that the variable is private to
the module. Globally-defined type variables are also often given names to
indicate their variance leading to cumbersome names like "_T_contra" and
"_KT_co". The current mechanisms for allocating type variables also requires
the developer to supply a redundant name in quotes (e.g. ``T = TypeVar("T")``).
This PEP eliminates the need for the redundant name and the cumbersome
variable names.

Defining type parameters today requires importing the ``TypeVar`` and 
``Generic`` symbols from the ``typing`` module. Over the past several releases
of Python, efforts have been made to eliminate the need to import ``typing``
symbols for common use cases, and the PEP furthers this goal.


Missing Functionality
---------------------

Most languages that include generics provide a way to supply a default
type argument value. Python currently lacks this functionality, although it
has been frequently requested. This PEP proposes to add the ability to supply
a default type argument value for type parameters.

Another frequently-requested feature in the type system is support for
recursive (self-referential) type aliases. Some Python type checkers already
support this capability, but specifying recursive type aliases is cumbersome
because of the need for enclosing the self reference in quotes. This PEP
proposes a mechanism that defines the rules for recursive type aliases and
makes them easy to define.


Summary Examples
================

Defining a generic class prior to this PEP looks something like this.

::

    from typing import Generic, TypeVar

    _T_co = TypeVar("_T_co", covariant=True, bound=str)

    class MyClass(Generic[_T_co]):
        ...


With the new syntax, it looks like this.

::

    class MyClass[T extends str]:
        ...


Here is an example of a generic function today.

::

    from typing import ParamSpec, TypeVar, Callable

    _P = ParamSpec("_P")
    _R = TypeVar("_R")

    def my_func(cb: Callable[_P, _R], *args: _P.args, **kwargs: _P.kwargs) -> _R:
        ...

And the new syntax.

::

    from typing import Callable

    def my_func[**P, R](cb: Callable[P, R], *args: P.args, **kwargs: P.kwargs) -> R:
        ...


Here is an example of a generic type alias today.

::

    from typing import TypeAlias

    _T = TypeVar("_T")

    MyTypeAlias: TypeAlias = _T | "MyTypeAlias[_T]"


And with the new syntax.

::

    type MyTypeAlias[T] = T | MyTypeAlias[T]


Specification
=============

Type parameter declarations
---------------------------

We propose to add new syntax for declaring type parameters for generic
classes, functions, and type aliases. The syntax adds support for
a comma-delimited list of type parameters in square brackets after
the name of the class, function, or type alias.

Simple (non-variadic) type variables are declared with an unadorned name.
Variadic type variables are preceded by "*". Parameter specifications are
preceded by "**".

::

    # This generic class is parameterized by a ``TypeVar`` T, a
    # ``TypeVarTuple`` Ts, and a ``ParamSpec`` P.
    class ChildClass[T, *Ts, **P]: ...

There is no need to include ``Generic`` as a base class. Its inclusion as
a base class is implied by the presence of type parameters.

Type parameter names within a generic class, function, or type alias must
be unique. Type parameters for a generic function cannot overlap the name
of a function parameter. A duplicate name generates a syntax error at runtime.

::

    class MyClass[T, *T]: ... # Syntax Error

    def my_func[T, **T](): ... # Syntax Error

    def my_func[T](T): ... # Syntax Error


Type Parameter Scopes
---------------------

A type parameter declared as part of a generic class is valid only within the
class body. Type parameters are also accesses when evaluating the argument list
(base classes and any keyword arguments) that comprise the class definition.
This allows base classes to be parameterized by these type parameters. Type
parameters are not accessible outside of the class body, including any class
decorators.

::

    class MyClass[T](BaseClass[T], param = Foo[T]): ...  # OK

    @my_decorator(Foo[T])  # Runtime error: 'T' is not defined
    class MyClass[T]: ...

A type parameter declared as part of a generic function is valid only within
the function body and within parameter and return type annotations. Default
argument values are evaluated outside of this scope, so type parameters are
not accessible in default value expressions. Likewise, type parameters are not
in scope for function decorators.

::

    def my_func[T](a: T) -> T: ...  # OK

    def my_func[T](a = list[T]): ...  # Runtime error: 'T' is not defined

    @my_decorator(list[T])  # Runtime error: 'T' is not defined
    def my_func[T](): ...


Upper Bound Specification
-------------------------

For a non-variadic type parameter, an "upper bound" type can be specified
through the use of the "extends" keyword. If an upper bound is not specified,
it is assumed to be ``object``.

::

    class MyClass[T extends str]: ...

The "extends" keyword is a new soft keyword. It is interpreted as a keyword
only in this part of the grammar. In all other locations, it is assumed to
be an identifier name.

The specified upper bound type must use an expression form that is allowed in
type annotations. More complex expression forms should be flagged
as an error by a type checker. Quoted forward declarations are allowed.

The specified upper bound type must be concrete. An attempt to use a generic
type should be flagged as an error by a type checker.

::

    class MyClass1[T extends dict[str, int]]: ...  # OK

    class MyClass2[T extends "ForwardDeclaration"]: ...  # OK

    class MyClass3[T extends dict[str, V]]: ...  # Type checker error

    class MyClass4[T extends [str, int]]: ...  # Type checker error

    class MyClass5[T extends (str, int)]: ...  # Type checker error

Constrained Type Specification
------------------------------

For a non-variadic type parameter, a set of two or more "constrained types"
can be specified through the use of the "in" keyword followed by a tuple that
contains the constrained types.

If the specified type is not a tuple or the tuple expression includes complex
expression forms that are not allowed in a type annotation, a type checker
should generate an error. Quoted forward declarations are allowed.

The specified constrained types must be concrete. An attempt to use a generic
type should be flagged as an error by a type checker.

::

    class MyClass1[AnyStr in (str, bytes)]: ...  # OK

    class MyClass1[T in ("ForwardDeclaration", bytes)]: ...  # OK

    class MyClass3[T in ()]: ...  # Type checker error

    class MyClass4[T in (str, )]: ...  # Type checker error

    class MyClass5[T in [str, bytes]]: ...  # Type checker error

    class MyClass6[T in (3, bytes)]: ...  # Type checker error

    class MyClass7[T in (list[S], str)]: ...  # Type checker error



Generic Type Alias
------------------

We propose to introduce a new statement for declaring type aliases. Similar
to ``class`` and ``def`` statements, a ``type`` statement defines a scope
for type parameters.

::

    # A non-generic type alias
    type IntOrStr = int | str

    # A generic type alias
    type ListOrSet[T] = list[T] | set[T]


The "type" keyword is a new soft keyword. It is interpreted as a keyword
only in this part of the grammar. In all other locations, it is assumed to
be an identifier name.

Type parameters declared as part of a generic type alias are valid only
when evaluating the right-hand side of the type alias.

As with ``typing.TypeAlias``, type checkers should restrict the right-hand
expression to expression forms that are allowed within type annotations.
The use of more complex expression forms (call expressions, trinary operators,
arithmetic operators, comparison operators, etc.) should be flagged as an
error.

We propose to deprecate the existing ``typing.TypeAlias`` introduced in
:pep:`0613`. The new syntax eliminates its need entirely.


Recursive Type Alias
--------------------

Type aliases declared with a ``type`` statement can be self-referential if
the type alias name is used as a type argument. Direct references to the
type alias (e.g. ``MyAlias = MyAlias | int``) should be flagged as an error
by a type checker, but such recursion will not generate a runtime error.
Runtime type checkers should handle such recursion without crashing.

::

    RecursiveList[T] = T | list[RecursiveList]  # OK

    RecursiveList[T] = RecursiveList[T]  # Error generated by type checker


Mutually-recursive type aliases are also possible, but this use case requires
quotes to handle forward references.

::

    type JsonNode[T] = "JsonAtom" | "JsonObject[T]" | "JsonArray[T]"
    type JsonAtom = str | float
    type JsonObject[T] = dict[str, JsonNode[T]]
    type JsonArray[T] = list[JsonNode[T]]


Variance Inference
------------------

We propose to eliminate the need for variance (invariance, covariance, or
contravariance) to be specified for type parameters. Instead, type checkers
will infer the variance of type parameters based on their usage within a
class. 

[TODO: Describe the detailed algorithm for inferring variance.]

The ``TypeVar`` class constructor accepts keyword parameters named ``covariant``
and ``contravariant``. If both of these are ``False``, the type variable is
assumed to be invariant. We propose to add another keyword parameter named
``auto_variance``. A corresponding instance variable ``__auto_variance__``
can be accessed at runtime to determine whether the variance is inferred.
Type variables that are implicitly allocated using the new syntax will always
have ``__auto_variance__`` set to ``True``.

The ``auto_variance`` keyword is also supported for a ``TypeVar`` allocated
via "traditional" means by calling the ``TypeVar`` constructor explicitly.
This means a generic class that uses the traditional syntax may include
combinations of type variables with specified and inferred variance.

::

    T1 = TypeVar("T1", auto_variance=True)  # Inferred variance
    T2 = TypeVar("T2")  # Invariant
    T3 = TypeVar("T3", covariant=True)  # Covariant

    # A type checker should infer the variance for T1 but use the
    # specified variance for T2 and T3.
    class MyClass[Generic[T1, T2, T3]]: ...


Default Type Arguments
----------------------

There is currently no way to specify default type arguments for a type
parameter. We propose to add support for default type arguments.

When using the new type parameter syntax, a default type argument can be
specified by using an assignment ("=") operator.

Default arguments are allowed for simple (non-variadic) type parameters,
variadic type parameters, and parameter specifiers. The default for a variadic
type parameter must be a tuple type. The default for a parameter specifier
must be a list of parameter types or an ellipsis.

::

    class MyClass[T = int, *Ts = tuple[int, ...], **P = [int, str]]: ...


When the new type parameter syntax is used, type parameters without default
arguments cannot follow type parameters with default arguments. This
is enforced at runtime, and a violation will result in a syntax error.

::

    class MyClass1[A, B = int]: ...  # OK

    class MyClass2[A = int, B]: ...  # Syntax error: B has no default argument


Default type arguments can also be specified with traditional ``TypeVar``,
``TypeVarTuple`` and ``ParamSpec`` classes using a new keyword parameter
``default``.

::

    T = TypeVar("T", default=int)
    Ts = TypeVarTuple("Ts", default=tuple[str, int])
    P = ParamSpec("P", default=...)

If a default type argument is not specified for a simple (non-variadic) type
parameter, it is assumed to be ``Any``. If a default type argument is not
specified for a variadic type parameter, it is assumed to be
``tuple[Any, ...]``. If a default type argument is not specified for a
parameter specifier, it is assumed to be ``...``, which means that the
function accepts any combination of positional and keyword arguments.

If a default type argument is provided for a type parameter with an upper
bound, the type must be compatible with (i.e. a subtype) of the specified
bound. A type checker should generate an error if this restriction is
violated.

If a default type argument is provided for a type parameter with constrained
types, the default type must be one of the constrained types. Subtypes are
not allowed in this case. A type checker should generate an error if this
restriction is violated.

::

        class MyClass1[A extends float = int]: ...  # OK

        class MyClass2[A extends int = float]: ...  # Error: float is not a subtype of int

        class MyClass3[A in (str, float) = int]: ...  # OK

        class MyClass4[A in (str, float) = int]: ...  # Error: int is not one of (str, float)


Compatibility with Traditional TypeVars
---------------------------------------

The existing mechanism for allocating ``TypeVar``, ``TypeVarTuple``, and
``ParamSpec`` is retained for backward compatibility. However, these
"traditional" type variables should not be combined with type parameters
allocated using the new syntax. Such a combination should be flagged as
an error by type checkers. This is necessary because the type parameter
order is ambiguous.

It is OK to combine traditional type variables with new-style type parameters
if the class, function, or type alias does not use the new syntax. The
new-style type parameters must come from an outer scope in this case.

::

    K = TypeVar("K")

    class MyClass[V](dict[K, V]): ...  # Type checker error

    class MyClass[K, V](dict[K, V]): ...  # OK

    class MyClass[V]:
        # This is OK because V comes from an outer scope and K
        # is introduced using the "traditional" generic function
        # mechanism.
        def my_method1(self, a: V, b: K) -> V | K: ...

        # A type checker should generate an error in this case because
        # this method uses the new syntax for type parameters, and
        # ``K`` is not defined by an outer scope.
        def my_method2[M](self, a: M, b: K) -> M | K: ...


Specialization of Generic Functions
-----------------------------------

A generic class or type alias can be "specialized" explicitly by supplying
type arguments in a subscript expression (e.g. ``dict[str, int]`` or
``ListOrSet[int]``).

There is currently no way to explicitly specialize a generic function. We
propose to add support for this capability.

::

    def func[T](a: T) -> T: ...
    reveal_type(func)  # (a: T) -> T

    f_int = func[int]
    reveal_type(f_int)  # (a: int) -> int
    f_int(1)  # OK

    f_str = func[str]
    reveal_type(f_str)  # (a: str) -> str
    f_str(1)  # Type checker error: type violation


Parameter specifiers and variadic type parameters can also be specialized
in this manner, consistent with the specialization of generic classes
and type aliases.

::

    def func[T, R](cb: Callable[P, R]) -> Callable[P, R]: ...

    f_spec1 = func[[str], int]
    reveal_type(f_spec1)  # (cb: Callable[[str], int]) -> Callable[[str], int]: ...

    f_spec2 = func[..., int]
    reveal_type(f_spec2)  # (cb: Callable[..., int]) -> Callable[..., int]: ...


An attempt to specialize a generic function that has already been specialized
should result in a type checker error. This is consistent with the existing
behavior of generic classes and type aliases.

::

    def func[T](a: T) -> T: ...
    f_int = func[int]
    f_int[int]  # Type checker error: f_int is already specialized


If a generic function is defined with an overload, the specialization is
applied to all of the overloaded signatures whose type parameters are
compatible with the supplied type arguments. Some overloads may be
eliminated in the specialization process. If the type arguments are
incompatible with all overloaded signatures, a type checker should generate
an error. 

::
    @overload
    def func() -> None: ...
    @overload
    def func[T](a: T) -> T: ...

    reveal_type(func)  # overload: () -> None, (a: T) -> T
    f_int = func[int]
    reveal_type(f_int)  # (a: int) -> int
    f_int() # Type checker error: Must supply argument for parameter "a"

    f_float = func[int, int]  # Type checker error: No matching signature


Overload elimination should also take into account bounds and constraints.

    @overload
    def func[T extends int](a: T) -> T: ...
    @overload
    def func[T extends str](a: T) -> T: ...

    reveal_type(func)  # overload: (a: T) -> T, (a: T -> T)

    f_int = func[int]
    reveal_type(f_int)  # (a: int) -> int

    f_str = func[str]
    reveal_type(f_str)  # (a: str) -> str

    f_float = func[float]  # Type checker error: No matching signature


If the specialization supplies fewer type arguments than there
are type parameters, the remaining type arguments should be filled in
using default type values if defaults are provided. If a default value
is not provided for a type parameter, the type checker should eliminate
that overload.

::
    
    @overload
    def func[S, T](a: S, b: T) -> S | T: ...
    @overload
    def func[S, T = int](a: S, b: T, c: None) -> S | T | None: ...

    f1 = func[int, int]
    reveal_type(f1)  # overload: (a: int, b: int) -> int, (a: int, b: int, c: None) -> int | None

    f2 = func[int]
    reveal_type(f2)  # (a: int, b: int, c: None) -> int | None


Scoping of Type Variables Used in Return Types
----------------------------------------------

::pep::`0480` does not specify how unsolved type variables should be treated
within a generic function return type. Consider the following examples:

::
    def func1[T]() -> Callable[[T], T]: ...

    def func2[T extends str = str](a: T | int) -> Callable[[T], T]: ...

In the case of ``func1``, there is no opportunity to solve the type variable
``T`` because it does not appear within the type annotation for any input
parameters. In this case, the type variable should be "inherited" by the scope
of the callable return type. The resulting type of the expression ``func1(0)``
is therefore ``Callable[[T], T]``, and the type variable ``T`` is inherited
by the callable. This applies to other (non-callable) generic types as well.
This is useful for callback protocols, for example.

In the case of ``func2``, the type variable ``T`` appears within a type
annotation for an input parameter, so it is assumed that it will be solved as
part of a call to this function. However, it's possible that the type variable
will go unsolved if a caller passes an ``int`` value for the first argument.
In this case, type checkers should assume that ``T`` takes on its default
value. In this case, the default value is ```str``, so the resulting type
of the expression ``func2(0)`` would be ``Callable[[str], str]``.


Runtime Implementation
======================

Grammar Changes
---------------

This PEP introduces two new soft keywords: "extends" and "type". It modifies
the grammar in the following ways:

1. Addition of optional type parameter clause in ``class`` and ``def`` statement.

::
    
    type_params: '[' t=type_param_seq  ']'

    type_param_seq: a[asdl_typeparam_seq*]=','.type_param+ [',']

    type_param:
        | a=NAME b=[type_param_bound] d=[type_param_default]
        | a=NAME c=[type_param_constraint] d=[type_param_default]
        | '*' a=NAME d=[type_param_default]
        | '**' a=NAME d=[type_param_default]

    type_param_bound: "extends" e=expression

    type_param_constraint: 'in' e=expression

    type_param_default: '=' e=expression


2. Addition of new ``type`` statement for defining type aliases.

::

    type_alias[stmt_ty]:
        | "type" n=NAME t=[type_params] '=' b=expression {
            CHECK_VERSION(stmt_ty, 12, "Type statement is", _PyAST_TypeAlias(n->v.Name.id, t, b, EXTRA)) }


AST Changes
-----------

This PEP introduces a new AST node type called "TypeAlias".

::
    TypeAlias(identifier name, typeparam* typeparams, expr value)

It also adds an AST node that represents a type parameter.

::
    typeparam = TypeVar(identifier name, expr? bound, expr? constraint, expr? default)
        | ParamSpec(identifier name, expr? default)
        | TypeVarTuple(identifier name, expr? default)

It also modifies existing AST nodes ``FunctionDef``, ``AsyncFunctionDef`` and
``ClassDef`` to include an additional optional attribute called ``typeparam*``
that includes a list of type parameters associated with the function or class.


Compiler Changes
----------------

If a class or function uses the new type parameter syntax, the compiler will
generate additional byte codes that cause the ``class``, ``def`` or ``type``
statements to be executed within a new scope that defines local variables with
the names of the type parameters. 

Consider the following definitions.

::

    class MyClass[T](BaseClass[T]): ...

    def my_func[T](a: T | None = None) -> T: ...

    type MyTypeAlias[T] = list[T]
    

This is translated by the compiler to a byte code stream that is effectively
equivalent to the following:

::

    MyClass = (lambda T: class MyClass(BaseClass[T]): ...)()

    my_func = (lambda T: def my_func(a: T | None))(defaults=(None, ))

    MyTypeAlias = types.TypeAliasType()
    MyTypeAlias.__value__ = (lambda T: list[T])()

The introduction of an additional lexical scope is necessary to provide the
appropriate scope for the type parameters, preventing them from "leaking" to
other scopes.

One side effect of this approach is that assignment expressions used within
class definition arguments will not apply to the scope that contains the
``class`` definition. We consider this an acceptable tradeoff because we are
unaware of any use cases for an assignment expression within a class argument.

::

    class MyClass1[T]((x := BaseClass[T])):
        ...
    
    # x is not defined in this scope.

    class MyClass2((y := BaseClass[int])):
        ...
    
    # y is defined in this scope.


Similarly, assignment expressions used within a parameter or return type
annotation within a generic function will not apply to the scope that contains
the ``def`` definition. In general, assignment expressions are not allowed
within type annotations. While they are technically allowed within ``Annotated``
expressions, we are unaware of any uses cases that rely on this behavior.

::

    def my_func1[T](a: Annotated[T, (x := 1)]):
        ...

    # x is not defined in this scope.

    def my_func2(a: Annotated[int, (y := 1)]):
        ...

    # y is defined in this scope.


Class and function declaration statements that do not use the new syntax are
executed normally, without the introduction of an additional scope. This
preserves full backward compatibility and limits the potential performance
impact of the new syntax.

All ``type`` statements are executed within a new scope.

TODO: Are there other negative side effects of introducing
a new scope? For example, will this affect debuggers or other runtime
libraries in a negative manner?


New TypeAliasType Class
-----------------------

A ``type`` statement makes use of a new runtime object which is an instance of
``types.TypeAliasType``. This instance is created and assigned to the type
alias name prior to evaluating the type alias expression. This allows for
self references without the need for a quoted forward reference.

Unlike type aliases defined in the traditional manner, type aliases created
through the use of a ``type`` statement cannot generally be used directly in
place of a class. Consider the following.

::

    OldTA: TypeAlias = float
    print(OldTA)  # <class 'float'>
    print(type(OldTA))  # <class 'type'>
    inst = OldTA()

    type NewTA = float
    print(NewTA)  # NewTA
    print(type(NewTA))  # <class 'TypeAliasType'>
    inst = NewTA()  # Runtime Error: TypeAliasType is not callable

Runtime functions that know about type expressions, including ``isinstance``
and ``issubclass`` will need to be modified to handle the expansion of a
``TypeAliasType`` value. Runtime type checking libraries will also need to
be updated to properly handle the expansion of ``TypeAliasType`` values.


Reference Implementation
========================

The Pyright type checker supports the behavior described in this PEP.

A reference implementation for CPython can be found 
`here <https://erictraut/cpython/typeparam>`_.

TODO: Update the above URL once reference implementation is
pushed to github. It is current working as a proof of concept, but there
are aspects of the spec that remain unimplemented.


Rejected Ideas
==============

TODO - need to complete


References
==========

TODO - need to complete


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
