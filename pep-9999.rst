PEP: 9999
Title: TypedMapping: Type Hints for Mappings with a Fixed Set of Keys
Author: Alice Purcell <alicederyn@gmail.com>,
        Daniel Moisset <dfmoisset@gmail.com>
Sponsor: Pablo Galindo <pablogsal@gmail.com>
Discussions-To: https://mail.python.org/archives/list/python-dev@python.org/thread/2P26R4VH2ZCNNNOQCBZWEM4RNF35OXOW/
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 07-Nov-2022
Python-Version: 3.12
Post-History: `30-Sep-2022 <https://mail.python.org/archives/list/typing-sig@python.org/thread/6FR6RKNUZU4UY6B6RXC2H4IAHKBU3UKV/>`__,
              `02-Nov-2022 <https://mail.python.org/archives/list/python-dev@python.org/thread/2P26R4VH2ZCNNNOQCBZWEM4RNF35OXOW/>`__


.. highlight:: rst

Abstract
========

:pep:`589` defines the structural type ``TypedDict``, for dictionaries with a fixed set of keys.
As it defines a mutable type, it is difficult to correctly type methods which accept readonly parameters, without inadvertently preventing valid inputs.
This pep proposes a type constructor ``typing.TypedMapping`` to support this use case.

For example, given the following definition::

    from typing import NotRequired, TypedMapping

    class Movie(TypedMapping):
        name: str
        year: NotRequired[int | None]

    def movie_string(movie: Movie) -> str:
        if movie.get("year") is None:
            return movie["name"]
        else:
            return f'{movie["name"]} ({movie["year"]})'

A type checker should accept this code::

    from typing import TypedDict

    class MovieRecord(TypedDict):
        name: str
        year: int

    movie: MovieRecord = {'name': 'Blade Runner',
                          'year': 1982}
    print(movie_string(movie))


Motivation
==========

Representing an object or structured data using (potentially nested) dictionaries with string keys is a common pattern in Python programs. :pep:`589` allows these to be type checked when the exact type is known up-front, but it is hard to write generic readonly code; for instance, where fields may be optional, or take a range of possible types. This is an especially common issue when writing APIs for services, which may support a wide range of input structures, and will not need to modify its input.

Take for example the function ``movie_string`` defined above. Suppose its its type signature is defined using a ``TypedDict``::

    from typing import NotRequired, TypedDict

    class Movie(TypedDict):
        name: str
        year: NotRequired[int | None]

    def movie_string(movie: Movie) -> str:
        if movie.get("year") is None:
            return movie["name"]
        else:
            return f'{movie["name"]} ({movie["year"]})'

Attempting to pass a ``MovieRecord`` into this function gives (in mypy) the error::

    Argument 1 to "movie_string" has incompatible type "MovieRecord"; expected "Movie"

This incompatibility is due to the unused mutate methods generated on ``Movie``.
This could be avoided by using a :pep:`544` protocol::

    from typing import Literal, Protocol, overload

    class Movie(Protocol):
        @overload
        def get(self, key: Literal["name"]) -> str: ...

        @overload
        def get(self, key: Literal["year"]) -> int | None: ...

        @overload
        def __getitem__(self, key: Literal["name"]) -> str: ...

        @overload
        def __getitem__(self, key: Literal["year"]) -> int | None: ...

This is very repetitive, easy to get wrong, and is still missing important definitions like ``in`` and ``keys()``.

Specification
=============

The ``TypedMapping`` type is a protocol behaving identically to ``TypedDict``, except:

1. instances need not be subclasses of dict
2. no mutate methods will be generated
3. subclasses can narrow field types, in the same manner as other protocols

All current and future features of TypedDict are applicable to TypedMapping, including class-based and alternative syntax, totality, and ``Required`` and ``NotRequired`` from :pep:`655`.

As with :pep:`589`, this PEP provides a sketch of how a type checker is expected to support type checking operations involving TypedMapping and TypedDict objects, but details are left to implementors. In particular, type compatibility should be based on structural compatibility.


Multiple inheritance and TypedDict
----------------------------------

A type that inherits from a TypedMapping subclass and from TypedDict (either directly or indirectly):

4. is the structural intersection of its parents, or invalid if no such intersection exists
5. instances must be a dict subclass
6. adds mutate methods only for fields it explicitly (re)declares

For example::

    class Movie(TypedMapping):
        name: str
        year: int | None

    class MovieRecord(A, TypedDict):
        year: int

    movie: MovieRecord = { "name": "Blade Runner",
                           "year": 1982 }
     
    movie["year"] = 1985  # Fine, mutate methods added in definition
    movie["name"] = "Terminator"  # Error, name mutator not declared


Type Consistency
----------------

Informally speaking, *type consistency* is a generalization of the is-subtype-of relation to support the ``Any`` type. It is defined more formally in :pep:`483`. This section introduces the new, non-trivial rules needed to support type consistency for TypedMapping types.

First, any TypedMapping type is consistent with ``Mapping[str, object]``. Second, a TypedMapping or TypedDict type ``A`` is consistent with TypedMapping ``B`` if ``A`` is structurally compatibly with ``B``. This is true if and only if both of these conditions are satisfied:

* For each key in ``A``, ``B`` has the corresponding key and the corresponding value type in ``B`` is consistent with the value type in ``A``.

* For each required key in ``A``, the corresponding key is required in ``B``.

Discussion:

* Value types behave covariantly, since TypedMapping objects have no mutator methods. This is similar to container types such as ``Mapping``, and different from relationships between two TypedDicts. Example::

    class A(TypedMapping):
        x: Optional[int]

    class B(TypedDict):
        x: int

    def f(a: A) -> None:
        print(a['x'] or 0)

    b: B = {'x': 0}
    f(b)  # Accepted by type checker

* A TypedDict or TypedMapping type with a required key is consistent with a TypedMapping type where the same key is a non-required key, again unlike relationships between two TypedDicts. Example::

    class A(TypedMapping, total=False):
        x: int

    class B(TypedDict):
        x: int

    def f(a: A) -> None:
        print(a.get('x', 0))

    b: B = {'x': 0}
    f(b)  # Accepted by type checker

* A TypedMapping type ``A`` with no key ``'x'`` is not consistent with a TypedMapping type with a non-required key ``'x'``, since at runtime the key ``'x'`` could be present and have an incompatible type (which may not be visible through ``A`` due to structural subtyping). This is the same as for TypedDicts. Example::

    class A(TypedMapping, total=False):
        x: int
        y: int

    class B(TypedMapping, total=False):
        x: int

    class C(TypedMapping, total=False):
        x: int
        y: str

    def f(a: A) -> None:
        print(a.get('y') + 1)

    def g(b: B) -> None:
        f(b)  # Type check error: 'B' incompatible with 'A'

    c: C = {'x': 0, 'y': 'foo'}
    g(c)  # Runtime error: str + int

* A TypedMapping with all ``int`` values is not consistent with ``Mapping[str, int]``, since there may be additional non-``int`` values not visible through the type, due to structural subtyping. This mirrors TypedDict. Example::

    class A(TypedMapping):
        x: int

    class B(TypedMapping):
        x: int
        y: str

    def sum_values(m: Mapping[str, int]) -> int:
        return sum(m.values())

    def f(a: A) -> None:
        sum_values(a)  # Error: 'A' incompatible with Mapping[str, int]

    b: B = {'x': 0, 'y': 'foo'}
    f(b)  # Runtime error: int + str


Rejected Alternatives
=====================

Several variations were considered and discarded:

* A ``readonly`` parameter to ``TypedDict``, behaving much like TypedMapping but with the additional constraint that instances must be dictionaries at runtime. This was discarded as less flexible due to the extra constraint; additionally, the new type nicely mirrors the existing ``Mapping``/``Dict`` types.
* Inheriting from a ``TypedMapping`` subclass and ``TypedDict`` resulting in mutate methods being added for all fields, not just those actively (re)declared in the class body. Discarded as less flexible, and not matching how inheritance works in other cases for TypedDict (e.g. total=False and total=True do not affect fields not specified in the class body).
* A generic type that removes mutate methods from its parameter, e.g. ``Readonly[MovieRecord]``. This would naturally want to be defined for a wider set of types than just ``TypedDict`` subclasses, and also raises questions about whether and how it applies to nested types. We decided to keep the scope of this PEP narrower.

