PEP: 9999
Title: Editable installs
Author: Bernát Gábor <gaborjbernat@gmail.com>
Sponsor: TBD
Discussions-To: https://discuss.python.org/t/discuss-tbd-editable-installs-by-gaborbernat/9071
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 28-May-2021
Post-History:

Abstract
========

This document describes extensions to the build backend and frontend
communication (as introduced by :pep:`517`) to allow projects to be installed in
editable mode.

Motivation
==========

During development, many Python users prefer to install their libraries so that
changes to the underlying source code are automatically reflected in subsequent
interpreter invocations without an additional installation step. This mode is
usually called "development mode" or "editable installs". Currently, there is no
standardized way to accomplish this, as it was explicitly left out of :pep:`517`
due to the complexity of the actual observed behaviors.

At the moment, users can achieve this in a few ways:

-  Adding the relevant source directories to ``sys.path`` (configurable from the
   command line interface via the ``PYTHONPATH`` environment variable). Note in
   this case, the users have to install the project dependencies themselves, and
   entry points or project metadata are not generated.

-  setuptools_ provides the `setup.py develop`_ mechanism: installs a ``pth``
   file that injects the project root onto the ``sys.path`` at interpreter
   startup time, generates the project metadata, and also installs project
   dependencies. pip_ exposes calling this mechanism via the `pip install -e
   <project_directory>`_ command-line interface.

-  flit_ provides the `flit install --symlink`_ command that symlinks the
   project files into the interpreters ``purelib`` folder, generates the project
   metadata, and also installs dependencies.

This PEP aims to delineate the frontend and the backend roles clearly and give
the developers of each the maximum ability to provide valuable features to their
users. In this proposal, the backend's role is to prepare the project for an
editable installation and enumerating how the installed layout maps onto the
layout on disk; the frontend's role is to take this mapping and expose the
relevant files to the target interpreter. Project metadata follows the same
responsibility structure as in :pep:`517`.

Rationale
=========

:pep:`517` deferred "Editable installs" because this would have delayed further
its adoption, and there wasn't an agreement on how editable installs should be
achieved. Due to the popularity of the setuptools_ and pip_ projects, the status
quo prevailed, and the backend could achieve editable mode by providing a
``setup.py develop`` implementation, which the user could trigger via `pip
install -e <project_directory>`_. By defining an editable interface between the
build backend and frontend, we can eliminate the ``setup.py`` file and their
current communication method.

Terminology and goals
=====================

The editable installation mode implies that the source code of the project being
installed is available in a local directory.

Once the project is installed in editable mode, some changes to the project code
in the local source tree will become effective without the need for a new
installation step. At a minimum, changes to the text of non-generated files that
existed at the installation time should be reflected upon the subsequent import
of the package.

Some kinds of changes, such as adding or modifying entry points or new
dependencies, require a new installation step to become effective. These changes
are typically made in build backend configuration files (such as
``pyproject.toml``). This requirement is consistent with the general user
expectation that such modifications will only become effective after
re-installation.

While users expect editable installations to behave identically to standard
installations, this may not always be possible and may be in tension with other
user expectations. Depending on how a frontend implements the editable mode,
some differences may be visible, such as the presence of additional files
(compared to a typical installation), either in the source tree or the
interpreter's installation path. Frontends should seek to minimize differences
between the behavior of editable and standard installations and document known
differences.

For reference, a non-editable installation works as follows:

#. The **developer** is using a tool, we'll call it here the **frontend**, to
   drive the project development (e.g., pip_). When the user wants to trigger a
   package build and installation of a project, they'll communicate with the
   **frontend**.

#. The frontend uses a **build frontend** to trigger the build of a wheel (e.g.,
   build_). The build frontend uses :pep:`517` to communicate with the **build
   backend** (e.g. setuptools_) - with the build backend installed into a
   :pep:`518` environment. Once invoked, the backend returns a wheel.

#. The frontend takes the wheel and feeds it to an **installer**
   (e.g.,`installer`_) to install the wheel into the target Python interpreter.

The Mechanism
=============


This PEP adds two optional hooks to the :pep:`517` backend interface. One of the
hooks is used to specify the build dependencies of an editable install. The
other hook returns the necessary information via the build frontend the frontend
needs to create an editable install.

``get_requires_for_build_editable``
-----------------------------------

.. code::

   def get_requires_for_build_editable(config_settings=None):
       ...

This hook MUST return an additional sequence of strings containing :pep:`508`
dependency specifications, above and beyond those specified in the
``pyproject.toml`` file. The frontend must ensure that these dependencies are
available in the build environment in which the ``build_editable`` hook is
called.

If not defined, the default implementation is equivalent to returning ``[]``.

``build_editable``
------------------

.. code::

   def build_editable(config_settings=None):
       ...

The function returns an object of type ``EditableInfo`` as defined below:

.. code::

   from typing import Mapping, TypedDict

   class SchemaPaths(TypedDict, total=False):
       """
       Files and folders that should be mapped:
       - key is the absolute source path
       - value is the relative path within the target interpreters prefix
       """

       purelib: Mapping[str, str]
       platlib: Mapping[str, str]
       headers: Mapping[str, str]
       scripts: Mapping[str, str]
       data: Mapping[str, str]


   class EditableInfo(TypedDict, total=True):
       version: int
       """protocol version of the editable metadata, this PEP defines version 1"""

       metadata_for_build_editable: str
       """distribution information of the package as defined by PEP-491"""

       paths: SchemaPaths
       """files to expose into the target interpreter"""


The schema paths map from project source absolute paths to target directory
relative paths. We allow backends to change the project layout from the project
source directory to what the interpreter will see by using the mapping.

For example if the backend returns ``"purelib": {"/me/project/src": ""}`` this
would mean that expose all files and modules within ``/me/project/src`` at the
root of the ``purelib`` path within the target interpreter.

Build frontend requirements
---------------------------

The build frontend is responsible for setting up the environment for the build
backend to generate the necessary information for an editable build. It's also
responsible for communicating with the backend and receiving the
``EditableInfo`` object. All recommendations from :pep:`517` for the build wheel
hook applies here too.

Frontend requirements
---------------------

The frontend is responsible for ensuring the ``.dist-info`` folder is available
at runtime within the target interpreter for the ``importlib.metadata`` and
``importlib.resources`` modules.

The frontend must ensure that all installation requirements specified in the
distribution information files are installed as part of the editable
installation into the target interpreter. Additionally, the user might also
select additional ``extras`` groups that also should be installed as part of the
editable installation.

The frontend also must generate entrypoints, which may be for the console or the
GUI. Those entrypoints are defined by the distribution information files, which
are generated during the editable installation process.

The frontend is responsible for generating the ``RECORD`` file based on the
object the build backend returns and their chosen editable implementation. For
this reason, the uninstallation of editables should not require any special
treatment.

The frontend must create a ``direct_url.json`` file in the ``.dist-info``
directory of the installed distribution, in compliance with PEP 610. The ``url``
value must be a ``file://`` URL pointing to the project directory (i.e., the
directory containing ``pyproject.toml``), and the ``dir_info`` value must be
``{'editable': true}``.

The frontend must not rely on the ``prepare_metadata_for_build_wheel`` hook when
installing in editable mode. It must instead invoke ``build_editable`` and use
the ``.dist-info`` folder returned by that.

Example editable implementations
--------------------------------

To show how this PEP might be used, we'll now present a few case studies. Note
the offered solutions are purely for illustrating purpose.

Add the source tree as is to the interpreter
''''''''''''''''''''''''''''''''''''''''''''

This is one of the simplest implementations, it will add the source tree as is
into the interpreters schema paths.

.. code::

   {
     "metadata_for_build_editable": "<dir to dist-info>",
     "purelib": {"<project dir>": "<project dir>"}
   }

The frontend then could either:

-  Add the source directory onto the target interpreters ``sys.path`` during
   startup of it. This is done by creating a ``pth`` file into the target
   interpreters ``purelib`` folder. setuptools_ does this today and is what `pip
   install -e <project_directory>`_ translate too. This solution is fast and
   cross-platform compatible. However, this puts the entire source tree onto the
   system, potentially exposing modules that would not be available in a
   standard installation case.

-  Symlink the folder, or the individual files within it. This method is what
   flit does via its `flit install --symlink`_. This solution requires the
   current platform to support symlinks. Still, it allows potentially to symlink
   individual files, which could solve the problem of including files that
   should be excluded from the source tree.

Using custom importers
''''''''''''''''''''''

For a more robust and more dynamic collaboration between the build backend and
the target interpreter, we can take advantage of the import system allowing the
registration of custom importers. See :pep:`302` for more details and editables_
as an example of this. The backend can generate a new importer during the
editable build (or install it as an additional dependency) and register it at
interpreter startup by adding a ``pth`` file.

.. code::

   {
     "metadata_for_build_editable": "<dir to dist-info>",
     "purelib": {
          "<project dir>/.editable/_register_importer.pth": "<project dir>/_register_importer.pth".
          "<project dir>/.editable/_editable_importer.py": "<project dir>/_editable_importer.py"
     }
   }

The backend here registered a hook that is called whenever a new module is
imported, allowing dynamic and on-demand functionality. Potential use cases
where this is useful:

-  Expose a source folder, but honor module excludes: the backend may generate
   an import hook that consults the exclusion table before allowing a source
   file loader to discover a file in the source directory or not.

-  For a project, let there be two modules, ``A.py`` and ``B.py``. These are two
   separate files in the source directory; however, while building a wheel, they
   are merged into one mega file ``project.py``. In this case, with this PEP,
   the backend could generate an import hook that reads the source files at
   import time and merges them in memory before materializing it as a module.

-  Automatically update out-of-date C-extensions: the backend may generate an
   import hook that checks the last modified timestamp for a C-extension source
   file. If it is greater than the current C-extension binary, trigger an update
   by calling the compiler before import.

Rejected ideas
==============

This PEP competes with :pep:`660` and rejects that proposal because we think the
mechanism of achieving an editable installation should be within the build
frontend rather than the build backend. Furthermore, this approach allows the
ecosystem to use alternative means to accomplish the editable installation
effect (e.g., insert path on ``sys.path`` or symlinks instead of just implying
the loose wheel mode from the backend described by that PEP).

References
==========

.. _build: https://pypa-build.readthedocs.io

.. _editables: https://pypi.org/project/editables

.. _flit: https://flit.readthedocs.io/en/latest/index.html

.. _flit install --symlink: https://flit.readthedocs.io/en/latest/cmdline.html#cmdoption-flit-install-s

.. _installer: https://pypi.org/project/installer

.. _pip: https://pip.pypa.io

.. _pip install -e <project_directory>: https://pip.pypa.io/en/stable/cli/pip_install/#install-editable

.. _setup.py develop: https://setuptools.readthedocs.io/en/latest/userguide/commands.html#develop-deploy-the-project-source-in-development-mode

.. _setuptools: https://setuptools.readthedocs.io/en/latest/

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
