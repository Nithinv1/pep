Abstract
========

This PEP proposes the addition of new list-comprehension syntax, and one built-in function "last", which would allow us to replace the reduce operator with list-comprehension-style syntax, allows us to define a "reduce-map" comprehension, which performs a reduction but saves every intermediate element into a list.  

Rationale
=========

One current awkwardness of Python comes about when you want to perform a chain of operations and save all intermediate processing steps.  Let's use the example:

.. code-block:: python

    def exponential_moving_average(signal: Iterable[float], decay: float, initial_value: float=0.):
        running_average = []
        average = initial_value
        for xt in signal:
            average = (1-decay)*average + decay*xt
            running_average.append(average)
        return running_average
    
    signal = [math.sin(i*0.01) + random.normalvariate(0, 0.1) for i in range(1000)]
    smooth_signal = exponential_moving_average((math.sin(i*0.01,) for i in range(1000)), decay=0.05)


        
A more savvy Pythonista may rewrite this as a generator:

.. code-block:: python

    def exponential_moving_average(signal: Iterable[float], decay: float, initial_value: float=0.):
        average = initial_value
        for xt in signal:
            average = (1-decay)*average + decay*xt
            yield average
    
    signal = [math.sin(i*0.01) + random.normalvariate(0, 0.1) for i in range(1000)]
    smooth_signal = list(exponential_moving_average((math.sin(i*0.01,) for i in range(1000)), decay=0.05))
    
Still, this seems like an awful lot of lines to express such a simple thing.


Proposal
========

We propose the syntax:

.. code-block:: python

    smooth_signal = [average = (1-decay)*average + decay*x for x in signal from average=0.]
    
- The :code:`from` keyword, normally reserved for imports, would be repurposed here to specify an initial value to a reduction. 
- If :code:`average` were not specified in the initial conditions, it could (1) be taken from the scope, or (2) raise a :code:`NameError`.

Because it may be a common case to only want the last element in this expression (as it is when you use reduce), we propose an additional :code:`last` builtin function to handle this nicely.  For example, if you just wanted the last element of the running sum, you could do: 

.. code-block:: python
    
    last_smooth_element = last(average = (1-decay)*average + decay*x for x in signal from average=0.)
    
The :code:`last` builtin would
- Take the final value produced by the iterable (if the iterable yields any items) OR
- Take the initial value otherwise.
