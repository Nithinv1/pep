PEP: 9999 
Title: Distributing and Packaging Type Information
Author: 
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 09-Sep-2017
Python-Version: 3.7
Post-History: 


Abstract
========

PEP 484 introduced type hints to Python, with goals of making typing
gradual and easy to adopt. Currently, distribution of typing information
must be distributed manually. This PEP provides a standardized means to
package and distribute type information and how type checkers should 
collect this information for type checking using existing packaging
architecture.

With a complete distribution solution there are many complexities to
consider such as package version, Python version, source of the type
information. For example, third parties may wish to ship their own stubs
if the package maintainer does not wish to do so. Furthermore, the type
checker may not be running on the same version of Python as the version
of Python it is checking.

There are several motivations and methods of supporting typing in a package.
This PEP recognizes four (4) types of packages that may be created:

1. The package maintainer would like to add type information inline.

2. The package maintainer would like to add type information via stubs.

3. The package maintainer would like to add type information via a mix
of 1 & 2.

4. A third party would like to share stub files for a package, but the
maintainer does not want to include them in the source of the package.

This PEP aims to support these scenarios and make them simple to add to
packaging and deploy.

### TODO: Summarize below once the method is agreed upon.

Rationale
=========

PEP 484 introduced type hints to Python, with goals of making typing
gradual and easy to adopt. PEP 484 introduces a suggestion [1]_ of using
``shared/typehints/pythonX.Y/`` for shipping stub files. However type
annotations can also live within user code. Manually adding a path to
stub files for each third party library does not scale. Additionally,
adding the path to ``site-packages`` will cause type checkers to fail
on packages that are highly dynamic (e.g. sqlalchemy and Django).

Furthermore, package authors are wishing to distribute code that has
inline type information, and there currently is no standard method to
distribute packages with inline type annotations or syntax that can
simultaneously be used at runtime and in type checking.

Specification
=============

The two major parts of this specification are the packaging specifications
and the resolution order for resolving module type information. This spec
is meant to replace the ``shared/typehints/pythonX.Y/`` spec of PEP 484. 

Packaging Type Information
--------------------------

Packages must opt into supporting typing. This will be done though a distutils
extension [2]_, providing a ``typed`` keyword argument to the distutils
``setup()`` command. The argument value will depend on the kind of type
information the package provides. The distutils extension will be added to the
``typing`` package. Therefore a package maintainer may write

::

    setup(
        ...
        setup_requires=["typing"],
        typed="inline",
        ...
    )

For package maintainers wishing to ship stub files containing all of their
type information, it is prefered that the ``*.pyi`` stubs are alongside the
corresponding ``*.py`` files. However, the stubs may be put in a sub-folder
of the Python sources, th the same name the ``*.py`` files are in. For 
example, the ``flyingcircus`` package would have its stubs in the folder
``flyingcircus/flyingcircus/``. This path is chosen so that if stubs are
not found in ``flyingcircus/`` the type checker may treat the subdirectory as
a normal package. The normal resolution order of checking ``*.pyi`` before
``*.py`` will be maintained. The value of the ``typed`` argument to 
``setup()`` is ``"stubs"`` for this type of distribution.

Packages that have inline type annotations simply have to pass the value
``"inline"`` to the ``typed`` argument in ``setup()``.

Third parties seeking to distribute stub files are encouraged to contact the
maintainer of the package about distribution alongside the package. If the
maintainer does not wish to maintain or package stub files or type information
inline, then a "third party stub package" should be created. The structure is
similar, but slightly different from that of stub only packages. If the stubs
are for the library ``flyingcircus`` then the package should be named 
``flyingcircus-stubs`` and the stub files should be put in a sub-directory
named ``flyingcircus``. This allows the stubs to be checked as if they were in
a regular package. These packages should also pass ``"stubs"`` as the value 
of ``typed`` argument in ``setup()``.

Packages wishing to distribute a mix of inline and stub files should put the
stub files alongside their Python sources, and provide the value ``"mixed"``
to the ``typed`` argument in ``setup()``.


Type Checker Module Resolution Order
------------------------------------

The following is the order that type checkers supporting this PEP should
resolve modules containing type information:

1. User code - the files the type checker is running on.

2. Stubs or Python source in ``PYTHONPATH``. This is to allow the user
complete control of which stubs to use, and patch broken stubs/inline
types from packages.

3. Third party stub packages - these packages can supersede the installed
untyped packages. They can be found at ``pkg-stubs`` for package ``pkg``,
however it is encouraged to check their metadata to confirm that they opt
into type checking.

4. Typeshed (if used) - Provides the stdlib types and several third party
libraries

5. Inline packages - finally, if there is nothing overriding the installed
package, and it opts into type checking.


To check if a package has opted into type checking, type checkers are
recommended to use the ``pkg_resources`` module to query the package
metadata. If the ``typed`` package metadata has ``None`` as its value, the
package has not opted into type checking.


References
==========

.. [1] PEP 484, Storing and Distributing Stub Files
   (https://www.python.org/dev/peps/pep-0484/#storing-and-distributing-stub-files)

.. [2] Distutils Extensions, Adding setup() arguments
   (http://setuptools.readthedocs.io/en/latest/setuptools.html#adding-setup-arguments)

Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
