PEP: 9999
Title: Support for TOML in the Standard Library
Author: Taneli Hukkinen, Shantanu Jain <hauntsaninja at gmail.com>
Sponsor: TODO
PEP-Delegate: TODO
Discussions-To: TODO
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 01-Jan-2022
Python-Version: 3.11
Post-History: 1900-01-01


Abstract
========

This proposes adding a module, ``tomllib``, to the standard library for parsing
and writing TOML. [1]_


Motivation
==========

The TOML format is the format of choice for Python packaging, as evidenced by
:pep:`517`, :pep:`518` and :pep:`621`. Including TOML support in the standard
library helps avoid bootstrapping problems for Python build tools. Currently
most Python build tools need to vendor a TOML parsing library.

Python tools are increasingly configurable via TOML, for examples: ``black``,
``mypy``, ``pytest``, ``tox``, ``pylint``, ``isort``. Those that are not, such
as ``flake8``, cite the lack of standard library support as a `main reason why
<https://github.com/PyCQA/flake8/issues/234#issuecomment-812800657>`_.

Given the special place TOML already has in the Python ecosystem, it makes sense
for this to be an included battery.

Finally, TOML as a format is increasingly popular (some reasons for this are
outlined in PEP 518). Hence this is likely to be a generally useful addition,
even looking beyond the needs of Python packaging and Python tooling: various
Python TOML libraries have about 2000 reverse dependencies on PyPI. For
comparison, ``requests`` has about 28k reverse dependencies.


Rationale
=========

This PEP proposes basing the standard library support for TOML on the third party
libraries ``tomli`` [2]_ and ``tomli-w`` [3]_.

Many projects have recently switched to using ``tomli``, for example, ``pip``,
``build``, ``pytest``, ``mypy``, ``black``, ``flit``, ``coverage``,
``setuptools-scm``, ``cibuildwheel``.

These libraries are actively maintained and well-tested. ``tomli`` is about 800
lines of code with 100% test coverage. ``tomli-w`` is about 200 lines of code with
100% test coverage.


Specification
=============

Read API

.. code-block::

   def load(fp: SupportsRead[bytes], /, *, parse_float: Callable[[str], Any] = float) -> dict[str, Any]: ...
   def loads(s: str, /, *, parse_float: Callable[[str], Any] = float) -> dict[str, Any]: ...

``tomllib.load`` deserializes a ``.read()``-supporting binary file containing a
TOML document to a Python object.

``tomllib.loads`` deserializes a str instance containing a TOML document to a
Python object.

``parse_float`` is a function that takes a string and returns a float, as with ``json.load``.
For example, ``decimal.Decimal`` in cases where precision is important.

``tomllib.TOMLDecodeError`` is raised in the case of invalid TOML.

Write API

.. code-block::

   def dump(obj: Mapping[str, Any], fp: SupportsWrite[bytes], /, *, multiline_strings: bool = False) -> None: ...
   def dumps(obj: Mapping[str, Any], /, *, multiline_strings: bool = False) -> str: ...


``tomllib.dumps`` serialize obj as a TOML formatted stream to a
``.write()``-supporting file-like object.

``tomllib.dump`` serializes an object to a TOML formatted str.


``multiline_strings`` controls whether strings containing newlines are written
as multiline strings. This defaults to False in case users wish to ensure
preservation of newline byte sequences.

TODO: describe types supported


Maintenance Implications
========================

Stability of TOML
-----------------

The release of TOML v1 in January 2021 indicates stability. Empirically, TOML
has proven to be a stable format even prior to the release of TOML v1. From the
`changelog <https://github.com/toml-lang/toml/blob/master/CHANGELOG.md>`_, we
see TOML has had no major changes since April 2020 and has had two releases in
the last five years.

In the event of changes to the TOML specification, we could treat minor
revisions as bugfixes and update the implementation in place. In the event of
major breaking changes, we should preserve support for TOML v1.

Maintainability of proposed implementation
------------------------------------------

The proposed implementation (``tomli`` and ``tomli-w``) is in pure Python, well
tested and combined weigh under 1000 lines of code. They are both minimalistic,
offering a smaller API surface area than other TOML implementations.

The author of ``tomli`` is willing to help integrate ``tomli`` into the standard
library and help maintain it, `as per this
<https://github.com/hukkin/tomli/issues/141#issuecomment-998018972>`__. At least
one CPython core dev has indicated potential willingness to maintain it,
`as per this
<https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/88>`__.

There is unlikely to be demand for an extension module, since there is
relatively less need for performance in parsing TOML: it's rare for application
bottleneck to be reading configuration. Users with extreme performance needs can
use a third party library (as is already often the case with JSON, despite a
stdlib extension module).

TOML support a slippery slope for other things
----------------------------------------------

As discussed in motivations, TOML holds a special place in the Python ecosystem.
This chief reason to include TOML in the standard library does not apply to
other formats, such as YAML or MessagePack.

In addition, the simplicity of TOML can help serve as a dividing line, for
example, YAML is large and complicated.


Backwards Compatibility
=======================

This will have no backwards compatibility issues as it will create a new API.

Note that we avoid using the ``toml`` name for the module, to avoid backwards
compatibility implications for users who have pinned versions of the current
``toml`` PyPI package. For more details, see `<Alternative names for module_>`_.


Security Implications
=====================

Errors in the implementation could cause potential security issues. However, the
implementation will be in pure Python, which reduces surface area of attack.


How to Teach This
=================

The API of ``tomllib`` mimics that of other well-established file format libraries,
such as ``json`` and ``pickle``.


Reference Implementation
========================

Link to any existing implementation and details about its state, e.g. proof-of-concept.

https://github.com/hukkin/tomli

https://github.com/hukkin/tomli-w


Rejected Ideas
==============

Roundtripping style
-------------------

In general, ``tomllib.dumps(tomllib.loads(x))`` may not equal ``x``, since we
make no effort to preserve comments, whitespace or other stylistic choices.

Style preservation would allow tools to losslessly edit TOML files. Since TOML
is intended as human-readable and human-editable configuration, it's important
to preserve human markup.

However, only a relatively small fraction of use cases require losslessly
editing TOML, as judged by reverse dependencies the style preserving ``tomlkit``
library compared to that of other third party toml libraries. In particular, we
don't need it for the core Python packaging use cases or for tools that merely
need to read configuration.

Since this would make both the implementation and the API more complex, it seems
better to relegate this additional functionality to third party libraries.

Basing on another TOML implementation
-------------------------------------

Potential alternatives include:

* ``tomlkit``.
  ``tomlkit`` is well established, actively maintained and supports TOML v1.
  An important difference is that ``tomlkit`` supports style roundtripping. As a
  result, it has a more complex API and implementation (about 5x as much code as
  ``tomli``). The author does not believe that ``tomlkit`` is a good choice for
  the standard library.

* ``toml``.
  ``toml`` is a widely used library. However, it is not actively maintained,
  does not support TOML v1 and has several known bugs. Its API is more complex
  than that of ``tomli``. It has some very limited and mostly unused ability to
  preserve style through an undocumented decoder API. It has the ability to
  customise output style through a complicated encoder API. For more details on
  API differences, refer to `Appendix A`_.

* ``pytomlpp``.
  ``pytomlpp`` is a Python wrapper for the C++ project ``toml++``. Pure Python
  libraries are easier to maintain than extension modules.

* ``rtoml``.
  ``rtoml`` is a Python wrapper for the Rust project ``toml-rs`` and hence has
  similar shortcomings to ``pytomlpp``. In addition, it does not support TOML v1.

* Writing from scratch.
  It's unclear what we would get from this: ``tomli`` meets our needs and the
  author is willing to help with its inclusion in the standard library.

Only including an API for reading TOML
--------------------------------------

There are several reasons to not include an API for writing TOML:

The ability to write TOML is not needed for the use cases that motivate this
PEP: for core Python packaging use cases or for tools that need to read
configuration.

As discussed in the previous section, use cases that involve editing TOML (as
opposed to writing brand new TOML) are better served by a style preserving
library.

Values in TOML can be represented in multiple ways. To the extent that users
want control over how the output TOML ends up being formatted (how to format
strings, when to inline arrays or tables, how much to indent, whether to reorder
contents, etc), they will not be served well by the proposed API.

The standard library does not need to do everything and if we feel that most
users are better served by more powerful third party write APIs, exclusion is
acceptable (and could be revisited later).

However, users will likely expect a write API to be available for consistency.
Empirically, writing TOML seems useful, e.g. ``toml.dump`` is used about 30% as
often as ``toml.load`` based on https://grep.app

Even a simple API is capable of serving common use cases, such as testing code
that loads TOML or writing simple or boilerplate TOML.
TODO: about 1/5 uses of ``toml.dump[s]`` are in tests, estimate other simple use cases

If we keep feature set narrow, a write API shouldn't be too much additional
burden. The proposed implementation is about 200 lines of code.


Assorted API details
--------------------

Types accepted by the first argument of ``tomllib.load``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``toml`` library on PyPI allows passing paths (and lists of path-like
objects, reading the first path that exists). Doing this would be inconsistent
with ``json.load``, ``pickle.load``, etc. If we agree consistency with other
stdlib modules is desirable, allowing paths is somewhat out of scope for this
PEP. This can easily and more explicitly be worked around in user code.

The proposed API takes a ``SupportsRead[bytes]``, while ``toml.load`` takes a
``SupportsRead[str]`` and ``json.load`` takes ``SupportsRead[str | bytes]``.
Using ``SupportsRead[bytes]`` allows us to a) ensure utf-8 is the encoding used,
b) avoid incorrectly parsing single carriage returns as valid TOML due to
universal newlines.

Controlling the type of mappings returned by ``tomllib.load[s]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This would work similarly to common uses for the ``object_hook`` argument in
``json.load[s]``.

Such an argument is not necessary for the core use cases outlined in the
motivation section. The absence of this can be pretty easily worked around using
a wrapper class or transformer function. Finally, support could be added later
in a backward compatible way.

The ``toml`` library on PyPI supports this feature using the ``_dict`` argument.
There are several uses of this on https://grep.app, however, almost all of them
were passing ``_dict=OrderedDict``, which should no longer be necessary post
Python 3.7. There were two instances of legitimate use: in one case, a custom
class was passed for friendlier KeyErrors, in another case, the custom class had
several additional lookup and mutation methods (e.g. to help resolve dotted
keys).

Allowing users more control over formatting ``tomllib.dump[s]`` output
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As mentioned, TOML values can be represented in multiple ways, so inevitably,
people will have strong opinions over how to do so.

The ``toml`` library on PyPI supports this using custom subclasses of
``toml.TomlEncoder``. There are a handful of instances of this that can be found
on https://grep.app. However, the API to do this is not particularly clean.

A non-exhaustive list of potential options users may want control over:

* How to format strings
* When to inline arrays or tables
* How much to indent
* Whether to reorder contents
* Whether to use dotted keys

In several cases, users could enforce TOML formatting by using an autoformatter
of their choice at a later point.

We acknowledge that supporting ``multiline_strings`` is something of an
exception to this, if controversial we can err on the side of simplicity and
remove it.

Allowing users more control over ``tomllib.dump[s]`` serialisation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It could be useful to add the equivalent of the ``default`` argument in ``json.dump``
to allow users to specify how custom types should be serialised.

The ``toml`` library on PyPI supports this using custom subclasses of
``toml.TomlEncoder``. However, we could find two instances of using
``toml.TomlEncoder`` to accomplish this kind of thing on https://grep.app, one
of which was to add support to ``toml`` for dumping ``decimal.Decimal``.

TOML is used more for configuration than serialisation of arbitrary data, so
users are perhaps less likely to require custom serialisation than with say
JSON. Support for this could be added in a backward compatible way.

TODO: talk about output validation for ``dump[s]``

Alternative names for module
----------------------------

Ideally, we would be able to use the ``toml`` module name.

However, the ``toml`` package on PyPI is widely used, so there are backward
compatibility concerns. Since the standard library takes precedence over third
party packages, users who have pinned versions of ``toml`` would be broken when
upgrading Python versions by any API incompatibilities.

Note the importance of "pinned". That is, even if we were able to get control
over the ``toml`` PyPI package and repurpose it as a standard library backport,
we would still break users with pinned packages. This is especially unfortunate,
since pinning is a common response to breaking changes.

There are several API incompatibilities between ``toml`` and the API proposed in
this PEP. Here are the differences that a significant fraction of users are
likely to run into:

* Use of ``toml.dump`` and ``toml.dumps``, since this PEP proposes to not
  include an API for writing TOML.
* ``toml.load`` accepts a non-overlapping set of types from the proposed API for
  ``tomllib.load``. See `here <Types accepted by the first argument of
  tomllib.load_>`_ for the rationale.
* For invalid TOML, ``toml`` raises ``toml.TomlDecodeError`` vs the proposed
  :pep:`8` compliant ``tomllib.TOMLDecodeError``.

There are other minor or less widely used API differences. If interested, refer
to `Appendix A`_.

Finally, the ``toml`` package on PyPI is not actively maintained and `we have
been unable to contact the author <https://github.com/uiri/toml/issues/361>`,
so action here would likely have to be done without the author's consent.

This PEP proposes ``tomllib``. This mirrors ``plistlib`` (another file format
module in the standard library), as well as several others such as ``pathlib``,
``graphlib``, etc.

Other bikesheds include:

* ``tomlparser``. This mirrors ``configparser``, but is perhaps slightly less
  appropriate if we include a write API in the future.
* ``tomli``. This assumes we use ``tomli`` as the basis for implementation.
* ``toml``, but under some namespace, such as ``parser.toml``. However, this is
  awkward, especially so since existing libraries like ``json``, ``pickle``,
  ``marshal``, ``html`` etc. would not be included in the namespace.


TODO: Random things
===================

Previous discussion:

* https://bugs.python.org/issue40059
* https://mail.python.org/archives/list/python-ideas@python.org/thread/IWJ3I32A4TY6CIVQ6ONPEBPWP4TOV2V7/
* https://mail.python.org/pipermail/python-dev/2019-May/157405.html
* https://github.com/hukkin/tomli/issues/141
* https://discuss.python.org/t/adopting-recommending-a-toml-parser/4068/84

Useful https://grep.app searches (note, ignore vendored):

* toml.load[s] usage https://grep.app/search?q=toml.load&filter[lang][0]=Python
* toml.dump[s] usage https://grep.app/search?q=toml.dump&filter[lang][0]=Python
* TomlEncoder subclasses https://grep.app/search?q=TomlEncoder%29%3A&filter[lang][0]=Python


References
==========

.. [1]
   TOML: Tom's Obvious Minimal Language
   https://toml.io/en/

.. [2]
   tomli
   https://github.com/hukkin/tomli

.. [3]
   tomli-w
   https://github.com/hukkin/tomli-w


.. _Appendix A:

Appendix A: Differences between proposed API and ``toml``
=========================================================

This appendix covers the differences between the API proposed in this PEP and
that of the third party package ``toml``. These differences are relevant to
understanding the amount of breakage we could expect if we used the ``toml``
name for the standard library module, as well as to better understand the design
space. Note that this list might not be exhaustive.

#. This PEP currently proposes not to include a write API. That is, there will
   be no equivalent of ``toml.dump`` or ``toml.dumps``.

   Discussed at TODO section link.

#. Different first argument of ``toml.load``

   ``toml.load`` has the following signature:

   .. code-block::

       def load(
           f: Union[SupportsRead[str], str, bytes, list[PathLike | str | bytes]],
           _dict: Type[MutableMapping[str, Any]] = ...,
           decoder: TomlDecoder = ...,
       ) -> MutableMapping[str, Any]: ...

   This is pretty different from the first argument proposed in this PEP: ``SupportsRead[bytes]``.

   Recapping the reasons for this, previously mentioned at
   `<Types accepted by the first argument of tomllib.load_>`_:

   * Allowing passing of paths (and lists of path-like objects, reading the first
     path that exists) is inconsistent with other similar functions in the standard
     library.
   * Using ``SupportsRead[bytes]`` allows us to a) ensure utf-8 is the encoding used,
     b) avoid incorrectly parsing single carriage returns as valid TOML due to
     universal newlines. TOML specifies file encoding and valid newline
     sequences, and hence is simply stricter format than what text file objects
     represent.

#. ``toml.load[s]`` accepts a ``_dict`` argument

   Discussed at `<Controlling the type of mappings returned by tomllib.load[s]_>`_.

   As discussed, almost all usage consists of ``_dict=OrderedDict``, which is
   not necessary in Python 3.7 and later.

#. ``toml.load[s]`` support an undocumented ``decoder`` argument

   It seems the intended use case is for an implementation of comment
   preservation. The information recorded is not sufficient to roundtrip the
   TOML document preserving style, the implementation has known bugs, the
   feature is undocumented and I could only find one instance of its use on
   https://grep.app.

   The ``toml.TomlDecoder`` interface exposed is not simple, containing nine methods.
   See `here <https://github.com/uiri/toml/blob/3f637dba5f68db63d4b30967fedda51c82459471/toml/decoder.pyi#L36>`__.

   Users are probably better served by a more complete implementation of style
   preserving parsing and writing.

#. ``toml.dump[s]`` support an ``encoder`` argument

   Note that we currently propose not to include a write API, however if that
   were to change, these differences would likely become relevant.

   This enables two use cases, a) control over how custom types should be
   serialised, b) control over how output should be formatted.

   The first use case is reasonable, however, I could only find two instances of
   this on https://grep.app. One of these two instances used this ability to add
   support for dumping ``decimal.Decimal`` (which a potential standard library
   implementation would support out of the box).

   If needed, this use case could be well served by the equivalent of the
   ``default`` argument in ``json.dump``.

   The second use case is enabled by allowing users to specify subclasses of
   ``toml.TomlEncoder`` and overriding methods to specify parts of the TOML
   writing process. The API consists of five methods and exposes a lot of
   implementation detail. See `here <https://github.com/uiri/toml/blob/3f637dba5f68db63d4b30967fedda51c82459471/toml/encoder.pyi#L9>`__.

   There is some usage of the ``encoder`` API on https://grep.app, however, it
   likely accounts for a tiny fraction of overall usage of ``toml``.

#. Timezones

   ``toml`` uses and exposes custom ``toml.tz.TomlTz`` timezone objects. The
   proposed implementation uses ``datetime.timezone`` objects from the standard
   library.

#. Errors

   ``toml`` raises ``TomlDecodeError`` vs the proposed PEP 8 compliant
   ``TOMLDecodeError``.


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End:
