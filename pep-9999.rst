PEP: 650 or so
Title: Robust overflow handling
Author: Mark Shannon <mark@hotpy.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 05-Dec-2020
Post-History: 


Abstract
========

CPython using a simple recursion depth counter to prevent both runaway recursion and C stack overflow.
However, runaway recursion and machine stack overflow are two different things.

Allowing machine stack overflow is a potential security vulnerability, but limiting recursion depth can prevent 
some Python programs from being to run.

This PEP proposes that runaway recursion and machine stack overflow are handled separately.
This would allow programs to set the maximum recursion depth safely and provide additional safety guarantees
for Python programs using only the standard library and trustworthy third-party modules.
Trustworthy, in this context, means written to use the provided C-API to guard against C stack overflow.

Motivation
==========

Currently, if a program needs to deeply recurse it must manage the maximum recursion depth allowed,
hopefully managing to set it in the region between the minimum needed to run correctly and the maximum that is safe
to avoid a memory protection error.

By separating the checks for C stack overflow from checks for recursion depth,
pure Python programs can safely run whatever level of recursion they require.


Rationale
=========



Specification
=============

StackOverflow exception
-----------------------

A new exception class, ``StackOverflow`` will be added.
This exception will be raised whenever the interpreter or API determines that the C stack
is at or nearing a limit of safety.

Failure modes
-------------

RecursionError
''''''''''''''

A ``RecursionError`` will be raised whenever the recursion depth reaches the recursion limit.
This is same behavior as currently exists for Python programs.

StackOverflow
'''''''''''''

Should the size of the underlying C stack exceed some safe limit, then a ``StackOverflow`` will occur.

Decoupling the Python stack from the C stack
''''''''''''''''''''''''''''''''''''''''''''

In order to provide the above guarantees and ensure that any program that previously worked continues to do so,
the Python and C stack will need to be decoupled.
That is, calls to Python functions, from Python functions, should not consume space on the C stack.
Calls to and from builtin functions will continue to consume space on the C stack.

The size of the C stack will be implementation defined, and may vary from machine to machine.
It may even differ between threads. However, there is an expectation that any code that could run
with the recursion limit set to the previous default value of 1000, will continue to run.


Backwards Compatibility
=======================

[Describe potential impact and severity on pre-existing code.]


Security Implications
=====================

[How could a malicious user take advantage of this new feature?]


Reference Implementation
========================




Rejected Ideas
==============

[Why certain ideas that were brought while discussing this PEP were not ultimately pursued.]


Open Issues
===========

[Any points that are still being decided/discussed.]


References
==========

[A collection of URLs used as references through the PEP.]


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End:

