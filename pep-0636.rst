PEP: 636
Title: Structural Pattern Matching: Tutorial
Version: $Revision$
Last-Modified: $Date$
Author: Daniel F Moisset <dfmoisset@gmail.com>,
        Tobias Kohn <kohnt@tobiaskohn.ch>
BDFL-Delegate:
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created: 12-Sep-2020
Python-Version: 3.10
Post-History: 
Resolution:


Abstract
========

This PEP is a tutorial for the pattern matching introduced by PEP 634.

PEP 622 proposed syntax for pattern matching, which received detailed discussion
both from the community and the Steering Council. A frequent concern was
about how easy would be to explain (and learn) about this feature. This PEP
addresses that concern providing the kind of document which learners could use
to learn about pattern matching in Python.

This is considered supporting material for PEP 634 (the technical specification
for pattern matching) and PEP 635 (the motivation and rational for having pattern
matching and design considerations).

Meta
====

This section is intended to get in sync about style and language with
co-authors. It should be removed from the released PEP

The following are design decisions I made while writing this:

1. Who is the target audience?
I'm considering "People with general Python experience" (i.e. who shouldn't be surprised
at anything in the Python tutorial), but not necessarily involved with the
design/development or Python. I'm assuming someone who hasn't been exposed to pattern
matching in other languages.

2. How detailed should this document be?
I considered a range from "very superficial" (like the detail level you might find about
statements in the Python tutorial) to "terse but complete" like
https://github.com/gvanrossum/patma/#tutorial
to "long and detailed". I chose the later, we can always trim down from that.

3. What kind of examples to use?
I tried to write examples that are could that I might write using pattern matching. I
avoided going
for a full application (because the examples I have in mind are too large for a PEP) but
I tried to follow ideas related to a single project to thread the story-telling more
easily. This is probably the most controversial thing here, and if the rest of
the authors dislike it, we can change to a more formal explanatory style.

Other rules I'm following (let me know if I forgot to):

* I'm not going to reference/compare with other languages
* I'm not trying to convince the reader that this is a good idea (that's the job of
  PEP 635) just explain how to use it
* I'm not trying to cover every corner case (that's the job of PEP 634), just cover
  how to use the full functionality in the "normal" cases.
* I talk to the learner in second person

Tutorial
========

Getting Started
---------------

As an example to motivate this tutorial, you will be writing a text-adventure. That is
a form of interactive fiction where the user enters text commands to interact with a
fictional world and receives text descriptions of what happens. Commands will be
simplified forms of natural language like ``get sword``, ``attack dragon``, ``go north``,
``enter shop`` or ``buy cheese``.

Your main loop will need to get input from the user and split it into words, let's say
a list of strings like this::

   command = input("What are you doing next? ")
   words = command.split()

The next step is to interpret the words. Most of our commands will be two words: an
action and an object. So you may be tempted to do the following::

   [action, obj] = words
   # interpret action, obj

The problem with that line of code is that it's missing something: what if the user
types more or less than 2 words? To prevent this problem you can either check the length
of the list of words, or capture the ``ValueError`` that the statement above would raise.

You can use a matching statement instead::

   match words:
       case [action, obj]:
           # interpret action, obj 

The ``match`` statement evaluates the **subject** after the ``match`` keyword, and checks
it against the **pattern** next to ``case``. A pattern is able to do two different
things:

 * Verify that the subject has certain structure. In your case, the ``[action, obj]``
   pattern matches any sequence of exactly two elements. This is called **matching**
 * It will bind some names in the pattern to component elements of your subject. In
   this case, if the list has two elements, it will bind ``action = words[0]`` and 
   ``obj = words[1]``. This is called **destructuring**

If there's a match, the statements inside the ``case`` clause will be run with the
bound variables. If there's no match, nothing happens and the next statement after
``match`` keeps running.





Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
