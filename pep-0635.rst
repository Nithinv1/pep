PEP: 635
Title: Structural Pattern Matching: Motivation and Rationale
Version: $Revision$
Last-Modified: $Date$
Author: Tobias Kohn <kohnt@tobiaskohn.ch>,
        Guido van Rossum <guido@python.org>
BDFL-Delegate:
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created: 12-Sep-2020
Python-Version: 3.10
Post-History:
Resolution:


Abstract
========

This PEP provides the motivation and rationale for PEP 634
("Structural Pattern Matching: Specification").  First-time readers
are encouraged to start with PEP 636, which provides a gentler
introduction to the concepts, syntax and semantics of patterns.


Motivation (Guido's version)
============================

(Structural) pattern matching syntax is found in many languages, from
Haskell, Erlang and Scala to Elixir and Ruby.  (A proposal for
JavaScript is also under consideration.)

Python already supports a limited form of this through sequence
unpacking assignments, which the new proposal leverages.

Several other common Python idioms are also relevant:

- The ``if ... elif ... elif ... else`` idiom is often used to find
  out the type or shape of an object in an ad-hoc fashion, using one
  or more checks like ``isinstance(x, cls)``, ``hasattr(x, "attr")``,
  ``len(x) == n`` or ``"key" in x`` as guards to select an applicable
  block.  The block can then assume ``x`` supports the interface
  checked by the guard.  For example::

    if isinstance(x, tuple) and len(x) == 2:
        host, port = x
        mode = "http"
    elif isinstance(x, tuple) and len(x) == 3:
        host, port, mode = x
    # Etc.

  Code like this is more elegantly rendered using ``match``::

    match x:
        case host, port:
            mode = "http"
        case host, port, mode:
            pass
        # Etc.

- AST traversal code often looks for nodes matching a given pattern,
  for example the code to detect a node of the shape "A + B * C" might
  look like this::

    if (isinstance(node, BinOp) and node.op == "+"
            and isinstance(node.right, BinOp) and node.right.op == "*"):
        a, b, c = node.left, node.right.left, node.right.right
        # Handle a + b*c

  Using ``match`` this becomes more readable::

    match node:
        case BinOp("+", a, BinOp("*", b, c):
            # Handle a + b*c

- TODO: Other compelling examples?

We believe that adding pattern matching to Python will enable Python
users to write cleaner, more readable code for examples like those
above, and many others.

Pattern matching and OO
-----------------------

Pattern matching is complimentary to the object-oriented paradigm.
Using OO and inheritance we can easily define a method on a base class
that defines default behavior for a specific operation on that class,
and we can override this default behavior in subclasses.  We can also
use the Visitor pattern to separate actions from data.

But this is not sufficient for all situations.  For example, a code
generator may consume an AST, and have many operations where the
generated code needs to vary based not just on the class of a node,
but also on the value of some class attributes, like the ``BinOp``
example above.  The Visitor pattern is insufficiently flexible for
this: it can only select based on the class.

For a complete example, see
https://github.com/gvanrossum/patma/blob/master/examples/expr.py#L231

TODO: Could we say more here?

Pattern and functional style
----------------------------

Most Python applications and libraries are not written in a consistent
OO style -- unlike Java, Python encourages defining functions at the
top-level of a module, and for simple data structures, tuples (or
named tuples or lists) and dictionaries are often used exclusively or
mixed with classes or data classes.

Pattern matching is particularly suitable for picking apart such data
structures.  As an extreme example, it's easy to write code that picks
a JSON data structure using ``match``.

TODO: Example code.

Motivation (Tobias' version)
============================

**This section should explain why we think pattern matching is a good
addition for Python.**

Since Python is a dynamically typed language, Python code frequently
has to deal with data that comes in different forms and shapes.  This,
in turn, gives rise to a high degree of versatility by favouring a
'duck typing' style, imposing only the bare minimum of requirements
on the form and shape of data, i.e. the structure of data objects.
Nonetheless, we find that Python code is often sparkled with
conditions depending on ``isinstance``, ``len``, ``getattr``,
``hasattr``, etc.  Despite the benefits of 'duck typing', actual
code still requires to query the format or type of an object in order
to choose an appropriate processing action or to extract relevant bits
of information.

Unfortunately, the conditions for slightly more complex structures
quickly grow into sequences of partly interdependent bits of
structural tests, hurting readbility and maintability.  Pattern
matching offers here a more direct scheme of expressing the minimal
structure that an objects needs to have in order to allow for further
processing.  Rather than writing a series of manual tests, patterns
follow a _declarative_ style, which is well-known for improved
readability, maintability, and for delegating the burden of efficient
execution on the compiler and interpreter.

The concept of pattern matching is similar to regular expressions,
where succinct patterns describe a textual structure.  A dedicated
compiler then transforms these declarative patterns into highly
efficient finite state machines.  In contrast to regular expressions,
pattern matching targets Python objects rather than textual data,
and builds on _decision trees_ as the driving motor for finding a
match.  Moreover, pattern matching blends the matching of a suitable
pattern with that of a function, i.e. code that is executed in order
to handle and process the information provided by a specific kind of
object.

One of the simplest forms of pattern matching that we find in other
languages comes in the form of _function overloading_.  The type and
number of arguments then determine which implementation of a specific
function will be executed.  Object-oriented languages (including
Python) may also use the _visitor pattern_ to differentiate an action
based on the type or class of an object.  Both of these approaches,
however, are aimed at 'shallow' structures with little or no direct
support for nested structures or structural information that is not
directly encoded in an object's class or type.  For instance, it is
simple to differentiate between an integer, a string, and a tuple, say,
but becomes quite cumbersome and difficult to differentiate between
tuples of different lengths, or between one containing string elements
vs. one containing numeric elements.  This is where pattern matching
shines: for structures that go beyond simple class distinctions.

Although pattern matching is a concept that has been known and used
for decades, we propose a re-interpretation that centres around the
principle of 'duck typing' and builds on existing features of the
Python language such as iterable unpacking.  Patterns adopt the syntax
of parameters as far as possible and, to a somewhat lesser degree,
that of targets in iterable unpacking.  In contrast to iterable
unpacking, pattern matching is a 'conditional' feature that has to
avoid side-effects, i.e. extracting elements from an abstract iterable
(thus working with actual sequences instead) or assigning to non-local
targets such as object attributes or container elements.  Overall, we
followed the guiding principle that patterns be static templates for
the structure and type of objects, i.e. patterns should depend as
little as possible on the surrounding context or current values of
variables (other than the subject to be matched, that is).

Pattern matching is a structure that _maps_ different patterns/templates
to 'function bodies' or actions.  This general mapping structure can be
found in different context as well.  Algol-derived languages usually
provide a switch table that maps ordinal values to actions, whereas Lisp
has a more general mapping from general conditions to actions.  Although
all these constructs share a similar overall structure and some syntax,
their intents and motivation differs highly.  In particular, pattern
matching as proposed here is not intended as or an extension of a switch
structure, although it is possible to emulate it to a large degree with
the syntax proposed here.


Rationale
=========

TBD.

This section should provide the rationale for individual design decisions.
It takes the place of "Rejected ideas" in the standard PEP format.
It is organized in sections corresponding to the specification (PEP 634).



The ``match`` statement
-----------------------

TBD.

The overall syntax of each case clause is similar to that of lambda
functions, although the body of case clauses are blocks of statements
rather than expressions.  Compare, for instance a lambda function to
add two values::

  lambda x, y: x + y
  
with a case clause performing the same operation::

  case x, y:
      return x + y
      
The case clause would, of course, be embedded in a match statement and
ultimately in a function.  Nonetheless, understanding the patterns
following the ``case`` as a generalisation of parameters is a solid
mental model to approach and understand pattern matching.



.. _patterns:

Patterns
--------

Patterns are most aptly described as a generalisation of parameters as
in function definitions.  They also share some characteristics with
targets of iterable unpacking.  Most importantly, however, patterns are
not expressions.  A pattern cannot be evaluated or executed, it is a
static declaration of a structural template.  This declarative nature
is a characteristic it shares with ``global`` statements, for instance,
but also with regular expressions or context-free grammars.

Python's iterable unpacking can assign values to any valid target,
including attributes and subscripts.  This allows you to write, e.g.,
``self.x, self.y = x, y`` in a class' initialisator, or
``a[i+1], a[i] = a[i], a[i+1]`` to swap two elements in a list.  The
same approach, however, does not work for patterns due to their
'conditional' nature.  It is at the very core of pattern matching that
a pattern may safely fail to match a given subject and reject it.  In
order for this to make sense and to reason about patterns, it is
imperative to avoid any side effects (as far as possible within the
bounds of a dynamic language).  Patterns can therefore not assign
values to arbitrary targets, but rather bind _local_ variables to
values extracted from the data provided.

Another consequence of the static declarative nature of patterns is that
they cannot contain expressions.  Nonetheless, as some structures are
discerned by specific _values_ (e.g., an object for 'addition' might be
discerned by the ``operator`` field holding the string value ``'+'``),
patterns can contain such values/constants.  The overall rules, however,
specifically exclude actual expressions and make sure that only specific
values are integrated into patterns.  The value ``-3``, for instance, is
syntactically interpreted as the expression comprising the unary operation
'negate' applied to the positive integer '3' (i.e. Python's syntax does
not support negative numbers as atomic literals).  The overall syntax of
patterns is carefully crafted to ensure that entities such as negative
numbers can be included despite the exclusion of expressions in general.

Nonetheless, it is desirable to express some constant values through named
constants.  ``HttpStatus.OK``, for instance, might be much more readable
than the plain number ``200``.  This poses a challenge, though, because
the Python compiler cannot infer reliable from context, which names are
meant to denote variables/parameters and which are meant to denote named
constants.  Noting that many meaningful constants are organised in specific
modules or enumerations, we follow a pragmatic approach here and interpret
any dotted names as constants (recall that assignments to attributes are
not possible because of side effects, anyway).  We acknowledge that this
rule may seem restrictive as it leaves out support for named constants
coming from the current namespace.  However, all alternatives turned out
to either introduce much more complex rules or additional syntax.  We would
also like to emphasise that better syntactic support for named constants
could still be added in future proposals, thus warranting our focus on a
minimal viable specficiation.





History and Context
===================

Pattern matching emerged in the late 1970s in the form of tuple unpacking
and as a means to handle recursive data structures such as linked lists or
trees (object-oriented languages use the visitor pattern for handling
recursive data structures).  The early proponents of pattern matching
organised structured data in 'tagged tuples' rather than ``struct``s as in
_C_ or the objects introduced later.  A node in a binary tree would, for
instance, be a tuple with two elements for the left and right branches,
respectively, and a ``Node``-tag, written as ``Node(left, right)``.  In
Python we would probably put the tag inside the tuple as
``('Node', left, right)`` or define a data class `Node` to achieve the
same effect.

Using modern syntax, a depth-first search (DFS) would then be written as
follows::

  def DFS(node):
      node match:
          case Node(left, right):
              DFS(left)
              DFS(right)
          case Leaf(value):
              handle(value)

The notion of handling recursive data structures with pattern matching
immediately gave rise to the idea of handling general recursive patterns
with pattern matching.  Pattern matching would thus also be used to define
recursive functions such as::

  def fib(arg):
      match arg:
          case 0:
              return 1
          case 1:
              return 1
          case n:
              return fib(n-1) + fib(n-2)

As pattern matching was repeatedly integrated into new and emerging
programming languages, its syntax slightly evolved and expanded.  The two
first cases in the ``fib`` example above could be written more succinctly
as ``case 0 | 1:`` with ``|`` denoting alternative patterns.  Moreover, the
underscore ``_`` was generally accepted as a wildcard, a filler where neither
the structure nor value of parts of a pattern were of substance.  Since the
underscore is already frequently used in equivalent capacity in Python's
iterable unpacking (e.g., ``_, _, third, _* = something``) we kept these
universal standards.

It is noteworthy that the concept of pattern matching has always been
closely linked to the concept of functions.  The different case clauses
have always been considered as something like semi-indepedent functions
where pattern variables take on the role of parameters.  This becomes
most apparent when pattern matching is written as an overloaded function,
along the lines of::

  def fib( 0 | 1 ):
      return 1
  def fib( n ):
      return fib(n-1) + fib(n-2)

Even though such a strict separation of case clauses into independent
functions does not make sense in Python, we find that patterns share many
syntactic rules with parameters, such as binding arguments to local
variables only or that variable/parameter names must not be repeated for
a particular pattern/function.

With its emphasis on abstraction and encapsulation, object-oriented
programming posed a serious challenge to pattern matching.  In short: in
object-oriented programming, we can no longer view objects as tagged tuples.
The arguments passed into the constructor do not necessarily specify the
attributes or fields of the objects.  Moreover, there is no longer a strict
ordering of an object's fields and some of the fields might be private and
thus inaccessible.  And on top of this, the given object might actually be
an instance of a subclass with slightly different structure.

To address this challenge, patterns became increasingly independent of the
original tuple constructors.  In a pattern like ``Node(left, right)``,
``Node`` is no longer a passive tag, but rather a function that can actively
check for any given object whether it has the right structure and extract a
``left`` and ``right`` field.  In other words: the ``Node``-tag becomes a
function that transforms an object into a tuple or returns ``None`` to
indicate that it is not possible.

In Python, we simply use ``isinstance()`` together with the ``__match_args__``
field of a class to check whether an object has the correct structure and
then transform some of its attributes into a tuple.  For the `Node` example
above, for instance, we would have ``__match_args__ = ('left', 'right')`` to
indicate that these two attributes should be extracted to form the tuple.
That is, ``case Node(x, y)`` would first check whether a given object is an
instance of ``Node`` and then assign ``left`` to ``x`` and ``right`` to ``y``,
respectively.

Paying tribute to Python's dynamic nature with 'duck typing', however, we
also added a more direct way to specify the presence of, or constraints on
specific attributes.  Instead of ``Node(x, y)`` you could also write
``object(left=x, right=y)``, effectively eliminating the ``isinstance()``
check and thus supporting any object with ``left`` and ``right`` attributes.
Or you would combine these ideas to write ``Node(right=y)`` so as to require
an instance of ``Node`` but only extract the value of the `right` attribute.



Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
