PEP: 9999
Title: Support for indexing with keyword arguments
Version: $Revision$
Last-Modified: $Date$
Author: Stefano Borini, Jonathan Fine
Sponsor: 
Discussions-To: python-ideas@python.org
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 24-Aug-2020
Python-Version: 3.10
Post-History: 
Resolution: 

Abstract
========

This PEP proposed extending python to allow keyword-like arguments to be
accepted during indexing operations. Notations in the form ``a[42, K=3, R=2]``
would become legal syntax.  A final strategy will be proposed in terms of
semantics and implementation.

This PEP is a rework and expansion of PEP 472, where an extension of the
indexing operation to support keyword arguments was analysed.Â PEP 472 was
Rejected due to apparent lack of interest back in 2019. However, renewed
interest has prompted a re-analysis and therefore this PEP.

Overview
========

Background
----------

PEP 472 was opened in 2014. The PEP focused on various use cases and was extracted
from a broad discussion on implementation strategies. The PEP was eventually rejected
in 2019 [#rejection]_ mostly due to lack of interest despite its 5 years of existence.

However, with the introduction of type hints in PEP 484 [#pep-0484]_ the
square bracket notation has been used consistently to enrich the typing
annotations, e.g. to specify a list of integers as Sequence[int]. Additionally,
there has been an expanded growth of packages for data analysis such as pandas
and xarray, which use names to describe columns in a table (pandas) or axis in
an nd-array (xarray). These packages allow users to access specific data by
names, but cannot currently use index notation ([]) for this functionality.

As a result, a renewed interest in a more flexible syntax that would allow for
named information has been expressed in many different threads.

During the investigation of PEP 472, many different strategies have been
proposed to expand the language, but no real consensus was reached. Many corner
cases have been examined more closely and felt awkward, backward incompatible
or both. Renewed interest was prompted by Caleb Donovick [#request-1]_ in 2019 
and Andras Tantos [#request-2]_ in 2020. These requests prompted a strong activity
on the python-ideas mailing list, where various options have been discussed and
a general consensus has been reached.

Use cases
---------

The following practical use cases present different cases where a keyworded
specification would improve notation and provide additional value:

1. To provide a more communicative meaning to the index, preventing e.g. accidental
   inversion of indexes

   ::

     >>> grid_position[x=3, y=5, z=8]
     >>> rain_amount[time=0:12, location=location]
     >>> matrix[row=20, col=40]
     

2. To enrich the typing notation with keywords, especially during the use of generics

   :: 

     def function(value: MyType[T=int]):


3. In some domain, such as computational physics and chemistry, the use of a
   notation such as ``Basis[Z=5]`` is a Domain Specific Language notation to represent
   a level of accuracy

   ::

     >>> low_accuracy_energy = computeEnergy(molecule, BasisSet[Z=3])

4. Pandas currently uses a notation such as

   ::
    
     >>> df[df['x'] == 1]

   which could be replaced with df[x=1].

5. xarray has named dimensions. Currently these are handled with functions .isel:

   :: 
   
     >>> data.isel(row=10)  # Returns the tenth row

   which could also be replaced with `data[row=10]`. A more complex example:

   ::

     >>> # old syntax
     >>> da.isel(space=0, time=slice(None, 2))[...] = spam  
     >>> # new syntax
     >>> da[space=0, time=:2] = spam  # new syntax


It is important to note that how the notation is interpreted is up to the
implementation. This PEP only defines and dictates the behavior of python
regarding passed keyword arguments, not how these arguments should be
interpreted and used by the implementing class.

Syntax and Semantics
====================

Current status
--------------

Before attacking the problem of detailing the new syntax and semantics to the
indexing notation, it is relevant to analyse how the indexing notation works
today, in which contexts, and how it is different from a function call.

Subscripting obj[x] is, effectively, an alternate and specialised form of
function call syntax with a number of differences and restrictions compared to
obj(x). The current python syntax focuses exclusively on position to express
the index, and also contains syntactic sugar to refer to non-punctiform
selection (slices). Some common examples:

::

    >>> a[3]       # returns the fourth element of a
    >>> a[1:10:2]  # slice notation (extract a non-trivial data subset)
    >>> a[3, 2]    # multiple indexes (for multidimensional arrays)

This translates into a __(get|set|del)item__ dunder call which is passed a single
parameter containing the index (for __getitem__ and __delitem__) or two parameters
containing index and value (for __setitem__).

The behavior of the indexing call is fundamentally different from a function call
in various aspects:

The first difference is in meaning to the reader.  A function call says
"arbitrary function call potentially with side-effects". An indexing operation
says "lookup", typically to point at a subset or specific sub-aspect of an
entity (as in the case of typing notation).  This fundamental difference means
that, while we cannot prevent abuse, implementors should be aware that the
introduction of keyword arguments to alter the behavior of the lookup may
violate this intrinsic meaning.

The second difference of the indexing notation compared to a function 
is that indexing can be used for both getting and setting operations.
In python, a function cannot be on the left hand side of an assignment. In
other words, both of these are valid

   :: 

     >>> x = a[1, 2]
     >>> a[1, 2] = 5

but only the first one of these is valid

   ::

     >>> x = f(1, 2)
     >>> f(1, 2) = 5  # invalid

This asymmetry is important to understand that there is a natural imbalance
between the two forms, and therefore it is not a given that the two should
behave transparently and symmetrically. 
    
The third difference is that functions have names assigned to their
arguments, unless the passed parameters are captured with *args, in which case
they end up as entries in the args tuple. In other words, functions already
have anonymous argument semantic, exactly like the indexing operation. However,
__(get|set|del)item__ is not always receiving a tuple as the `index` argument
(to be uniform in behavior with *args).  In fact, given a trivial class:


   ::

     class X:
         def __getitem__(self, index):
             print(index)

The index operation basically forwards the content of the square brackets "as is" 
in the `index` argument:

   ::

     >>> x=X()
     >>> x[0]
     0
     >>> x[0, 1]
     (0, 1)
     >>> x[(0, 1)]
     (0, 1)
     >>> 
     >>> x[()]
     ()
     >>> x[{1, 2, 3}]
     {1, 2, 3}
     >>> x["hello"]
     hello
     >>> x["hello", "hi"]
     ('hello', 'hi')

The fourth difference is that the indexing operation knows how to convert
colon notations to slices, thanks to support from the parser. This is valid

   ::

     a[1:3]

this one isn't
  
   ::
    
     f(1:3)

The fifth difference is that there's no zero-argument form. This is valid

colon notations to slices, thanks to support from the parser. This is valid

   ::

     f()

this one isn't
  
   ::
    
     a[]
    

Compatibility Hard Points
-------------------------

Any change to the current behavior 
After discussion, it was found out that the new syntax will have a fixed set of hard points, no matter
the final implementation:

* Invoking indexing _must_ accept some object. E.g. `a[]` is still syntax error.
* It must be possible to mix single values and named indexes, e.g. `a[1, 2, foo=3]`
* No walrus allowed. E.g. `a[foo:=3] is disallowed.


New Proposal
------------

We propose to allow notations involving keyword arguments in the indexing
operation, e.g.

::

    >>> a[K=3, R=2]

which would allow a more flexible way to indicise content.

One must additionally consider the extended form that allows both positional
and keyword specification

::

    >>> a[3, R=3, K=4]


We also ensure that the current semantic for slices is applied to keyword arguments
as well. This syntax is valid:

::

    >>> a[3, R=3:10, K=4]



Syntax and semantics (Ricky Teachey's proposal)
===============================================

This proposal introduces new dunders __(get|set|del)item_ex__ 
that are invoked over the __(get|set|del)item__ triad, if they are present.

The rationale around this choice is to make the intuition around how to add kwd
arg support to square brackets more obvious and in line with the function
behavior. It would also make writing code for specialized libraries that tend
to use item dunders, like pandas and xarray, much easier. Right now such
libraries have to rely on their own efforts to break up a key, or use
"functions in stead" (e.g. iloc())



Problems with this approach:

* __setitem_ex__ value would need to be the first element, because the index is of arbitrary length.


Alternative Syntax and Semantics
================================

Steven's proposal


Rejected Ideas
==============

PEP 472 presents a good amount of ideas that are now all to be considered Rejected. A personal email from D'Aprano to the Author
specifically said:

"I have now carefully read through PEP 472 in full, and I am afraid I
cannot support any of the strategies currently in the PEP."

Moreover, additional ideas and discussion occurred during the re-evaluation of the PEP:

1. create a new "kwslice" object




References
==========

.. [#rejection] "Rejection of PEP 472"
       (https://mail.python.org/pipermail/python-dev/2019-March/156693.html)
.. [#pep-0484] "PEP 484 -- Type hints" 
       (https://www.python.org/dev/peps/pep-0484)
.. [#request-1] "Allow kwargs in __{get|set|del}item__"
       (https://mail.python.org/archives/list/python-ideas@python.org/thread/EUGDRTRFIY36K4RM3QRR52CKCI7MIR2M/)
.. [#request-2] "PEP 472 -- Support for indexing with keyword arguments"
       (https://mail.python.org/archives/list/python-ideas@python.org/thread/6OGAFDWCXT5QVV23OZWKBY4TXGZBVYZS/)


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
