PEP: 735
Title: Dependency Groups in pyproject.toml
Author: Stephen Rosen <sirosen0@gmail.com>
Sponsor: Brett Cannon <brett@python.org>
Discussions-To: https://discuss.python.org/t/39233
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 20-Nov-2023
Post-History: `20-Nov-2023 <https://discuss.python.org/t/39233>`__, `14-Nov-2023 <https://discuss.python.org/t/29684>`__

Abstract
========

This PEP specifies a mechanism for storing package requirements in
pyproject.toml files such that it is not included in any built distribution of
the project.

This is suitable for creating named groups of dependencies, similar to
``requirements.txt`` files, which launchers, IDEs, and other tools can find and
identify by name.

The feature defined here is referred to as "Dependency Groups".

Motivation
==========

The Python packaging toolchain is oriented towards the production of wheel and
sdist files, containing project source for installation. However, not all
projects are designed or intended for this mode of distribution. Primary
examples include webapps (which often run from source), and data science
projects (which may start as collections of scripts and only later evolve
package structures). This PEP seeks to offer these projects a way to specify
their package dependencies in a way which is not constrained by the
requirements of distribution building -- for example, a data science project
does not need to declare a version or authors in order for these data to be
valid.

The pre-existing solution which is most similar to this proposal is the use of
``requirements.txt`` files. Many projects may define one or more of these files,
and may arrange them either at the project root (e.g. ``requirements.txt`` and
``test-requirements.txt``) or else in a directory (e.g.
``requirements/base.txt`` and ``requirements/test.txt``). However, there are
two major issues with the use of requirements files in this way: (1) there is no
standardized naming convention such that tools can discover or use these files
by name and (2) ``requirementst.txt`` files are *not standardized*, but instead
provide options to ``pip``. Therefore, their use is not portable to any new
installer or tool which wishes to process them without relying upon ``pip``.
Additionally, ``requirements.txt`` files may be viewed as a heavyweight
solution for very small dependency sets of only one or two items, and a terser
declaration will be beneficial to projects with a number of small groups of
dependencies.

Although one primary goal of this PEP is to support some of the needs of
projects which do not build distributions, there are benefits in this proposal
for projects which *are* intended to build distributions. Because these
requirements data are explicitly defined to not be included in any built
distribution, two common use-cases are addressed by this addition. The first is
the use of ``extras`` for development requirements -- because these are published
data, package developers often restrain themselves to a single extra or a small
number of extras, and are concerned about ensuring that their development
extras are not confused with user-facing extras. The second is the use of
``requirements.txt`` files for libraries and applications, which takes a similar
form to their use in non-distribution-building projects.

Rationale
=========

This PEP defines the storage of requirements data in lists within a
``[requirements.packages]`` table. The naming is motivated by two major
factors. First, the desire to lay claim to a namespace which can be extended
later. Discussions about project needs have included mention of python version
requirements and other potential metadata. These could be added to the
``[requirements]`` table as siblings of the ``[requirements.packages]`` table.
Second, the desire for this format to be as simple and learnable as possible,
having a format very similar to existing ``requirements.txt`` files. Each list
in ``[requirements.packages]`` is defined as a list of package specifiers.

The format does not support non-package data from ``requirements.txt`` files,
such as ``pip`` options for package servers or hashes. Including them in the
initial stage complicates this proposal and it is not clear that the majority
of use-cases require them. Future expansions to this specification may enable
the use of object declarations, rather than strings, in the
``[requirements.packages]`` values. This specification is written to allow for
this by specifying a valid object format with only one well-defined key.

The following use cases are considered important targets for this PEP:

* A web application (e.g. a django or flask app) which does not build a
  distribution, but bundles and ships its source to a deployment toolchain. The
  app has runtime dependencies, testing dependencies, and development
  environment dependencies. All of these dependency sets should be declared
  independently, and none of these runtime contexts should require that the
  project be built into a wheel.
* A library which builds a distribution, but has a variety of testing and
  development environments it wishes to declare. Some of these rely on the
  library's own dependencies (``test`` and ``typing`` environments) while
  others do not (``docs`` and ``lint`` environments).
* A data science project which consists of multiple scripts on the same suite
  of core libraries (e.g. ``numpy``, ``pandas``, ``matplotlib``), and which
  also has additional libraries, sometimes conflicting, for specific scripts
  (e.g. ``scikit-learn==1.3.2`` for one script and ``scikit-learn==0.24.2`` for
  another).
* *Input data* to a lockfile generator. Because there is no standardized
  lockfile format, it is still the prerogative of tools like ``poetry`` and
  ``pip-compile`` to describe their own formats. However, it should be possible
  for the data from this PEP to be used as an input to these tools.
  Furthermore, tools may define their own structures and conventions such that
  the generated lockfiles can be referenced by the names of their originating
  dependency groups in ``pyproject.toml``.
* *Input data* to a ``tox``, ``nox``, or ``hatch`` environment, as can
  currently be achieved, for example, with ``deps = -r requirements.txt`` in
  ``tox.ini``. These tools will need to add additional options for processing
  Dependency Groups.
* Embeddable data for ``pyproject.toml`` within a script (as in PEP 723). This
  PEP does not define exactly how PEP 723 should be modified, but being
  consumable by that interface is a stated goal.

Regarding Poetry Dependency Groups
----------------------------------

Poetry already offers a feature which it calls "Dependency Groups", but using
non-standard data belonging to the ``poetry`` tool.

This PEP is not guaranteed to be a perfectly substitutable solution for the
same problem space. However, the ideas are extremely similar, and it should be
possible for Poetry to support at least some PEP-735-standardized Dependency
Group configurations using its own Dependency Group nomenclature.

A level of interoperability with Poetry is a goal of this PEP, but certain
features and behaviors defined here may not be supported by Poetry. Matching
the existing Poetry *semantics* for Dependency Groups is a non-goal.

Specification
=============

This PEP defines a new section (table) in ``pyproject.toml`` files named
``requirements``. The ``requirements`` table contains exactly one key,
``packages``, which is a table. All other keys in ``requirements`` are reserved
for future use.

The ``packages`` table contains an arbitrary number of user-defined keys, each of
which has, as its value, a list of requirements specifiers (defined below).
These keys must match the following regular expression:
``[a-z0-9][a-z0-9-]*[a-z0-9]``. Meaning that they must be all lower-case
alphanumerics, with ``-`` allowed only in the middle, and at least
two characters long. These requirements are chosen so that the normalization
rules used for pypi package names do not apply, as the names are already
normalized.

Requirements specifiers will use a definition which extends PEP 508. Therefore,
it is first necessary to define a string format, a "PEP 735 Dependency". These
are defined as strings in one of the three following formats:

* a PEP 508 specification, e.g., ``numpy>1``
* a comma-delimited list of Dependency Group names, enclosed in square
  brackets, e.g., ``[test,docs]`` to refer to other Dependency Groups named
  ``test`` and ``docs``
* a single dot, ``.``, which refers to the current project as a package
  (similar to ``pip install .``)
* a single dot, followed by square brackets enclosing a list of extra names,
  which refers to the current project as a package including some extras, e.g.,
  ``.[mysql]`` to refer to the current package with its ``mysql`` extra

Requirement specifiers can now be defined as one of the following:

* A string, which is a valid PEP 735 Dependency Specifier. e.g., ``numpy>1``
* An object, which has exactly one key, ``spec``, which is a valid PEP 735
  Dependency Spec. e.g., ``{spec = "numpy>1"}``

Any additional keys in a requirement specifier object are reserved for future
use.

The following is an example of a ``pyproject.toml`` section which uses this to
define four dependency groups: ``test``, ``docs``, ``typing``, and
``typing-test``:

.. code:: toml

    [requirements.packages]
    test = ["pytest", "coverage", "."]
    docs = ["sphinx", "sphinx-rtd-theme"]
    typing = ["mypy", "types-requests", ".[types]"]
    typing-test = ["[typing,test]", "useful-types"]

Note how ``test`` and ``typing`` are able to refer to the current package
while ``docs`` does not. This reflects the ability of Dependency Groups to be used
in the same manner as extras, adding to dependencies, or completely
independently. ``typing-test`` is defined as a union of two existing groups,
plus an additional package. ``typing`` includes an extra, ``types``.

Implementation Requirements
---------------------------

Tools which support Dependency Groups MUST support both string and object
representations of requirements.

They MAY emit warnings when unrecognized keys are encountered in requirement
specifiers or in the ``requirements`` table.

When installing the current package (``.``) from a dependency group, tools
SHOULD prefer editable installs over non-editable installs. They MAY provide
users with options to configure this behavior.

Reference Implementation
========================

TODO! STUB!

Planned reference implementation:
A very simple "environment manager" which can be used to build virtualenvs from
specified Dependency Groups. It will therefore need to fully support parsing of
Dependency Groups.

Backwards Compatibility
=======================

At time of writing, the ``requirements`` table is reserved for use by PEPs,
meaning that this lays claim to a previously unused namespace.
There should therefore be no direct backwards compatibility concerns.

Security Implications
=====================

This PEP introduces new syntaxes and data formats for specifying dependency
information in projects. However, it does not introduce newly specified
mechanisms for handling or resolving dependencies.

It therefore does not carry security concerns other than those inherent in any
tools which may already be used to install dependencies -- i.e. malicious
dependencies may be specified here, just as they may be specified in
``requirements.txt`` files.

How to Teach This
=================

This feature should be referred to by its canonical name, "Dependency Groups".

The basic form of usage should be taught as a variant on typical
``requirements.txt`` data. PEP 508 package specifiers can be added to a named
list. Rather than asking ``pip`` to install from a ``requirements.txt`` file,
either ``pip`` or a relevant workflow tool will install from a named Dependency
Group.

For new python users, they may be taught directly to create a section in
``pyproject.toml`` containing their dependency groups, similarly to how they
are currently taught to use ``pyproject.toml``.

Rejected Ideas
==============

Why not define python-requires as part of the requirements table?
-----------------------------------------------------------------

Discussion around PEP 722 and PEP 723, as well as discussions of projects which
do not produce wheels, have often raised the need to define the python version
which will be used.

This PEP explicitly does not define such a key -- doing so must define
interoperability semantics with respect to the existing packaging-oriented
python-requires key.
It is treated as out-of-scope for the sake of simplicity.

The Dependency Groups data can be defined here and intentionally leaves space
for the addition of new keys in ``[requirements]`` for future PEPs.

Why not define each Dependency Group as a table?
------------------------------------------------

If the goal is to allow for future expansion, then defining each Dependency
Group as a subtable, thus enabling us to attach future keys to each group,
allows for the greatest future flexibility.

However, it also makes the structure nested more deeply, and therefore harder
to teach and learn. One of the goals of this PEP is to be an easy replacement
for many ``requirements.txt`` use-cases.

Why not restrict dependencies to PEP 508 only?
----------------------------------------------

There are valid use-cases for

* including one dependency group in another
* including the current package (if the project is a package)
* including the current package with extras (if the project is a package)

These are not satisfiable without some expansion of syntax beyond what is
possible with PEP 508.

Why not define keys in dependency specifications for common options seen in ``requirements.txt`` (e.g. ``--hash``)?
-------------------------------------------------------------------------------------------------------------------

It is currently unclear which options will be the most necessary and beneficial.

Certain problems, e.g. package hashing, are the domain of lockfiles.
The data in this PEP is meant to be lockfile *input*, not necessarily lockfile *output*.
Therefore, hashing should not be privileged, nor should other options.

The PEP defines space for future expansion of the data format and mandates that
tools support and parse it such that expansion will be a non-breaking change.

Why not restrict dependency specifications to strings only?
-----------------------------------------------------------

Failing to establish the object format at this stage would lead to a breaking
change if it were ever introduced.
Rather than having a smooth degradation path, users would experience breakage
if the object format were introduced and only some tools supported it.

Open Issues
===========

None at this point.

Footnotes
=========

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
