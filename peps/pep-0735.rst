PEP: 735
Title: Dependency Groups in pyproject.toml
Author: Stephen Rosen <sirosen0@gmail.com>
Sponsor: Brett Cannon <brett@python.org>
Discussions-To: https://discuss.python.org/t/39233
Status: Draft
Type: Standards Track
Topic: Packaging
Created: 20-Nov-2023
Post-History: `14-Nov-2023 <https://discuss.python.org/t/29684>`__, `20-Nov-2023 <https://discuss.python.org/t/39233>`__

Abstract
========

This PEP specifies a mechanism for storing package requirements in
``pyproject.toml`` files such that it is not included in any built distribution of
the project.

This is suitable for creating named groups of dependencies, similar to
``requirements.txt`` files, which launchers, IDEs, and other tools can find and
identify by name.

The feature defined here is referred to as "Dependency Groups".

Motivation
==========

There are two major use-cases for which the Python community has no
standardized answer:

* How should development dependencies be defined for packages?

* How should dependencies be defined for projects which do not build
  distributions (non-package projects)?

In the absence of any standard, two known workflow tools, PDM and Poetry, have
defined their own solutions for Dependency Groups to address the first of these
two needs. Their definitions are very similar to one another, although PDM
structures them much more similarly to extras than Poetry does.
Neither of them addresses the needs of non-package projects, and neither can be
referenced natively from other tools like ``tox``, ``nox``, or ``pip``.

There are two pre-existing solutions which are similar to this proposal: the
use of ``requirements.txt`` files and package extras.

Regarding ``requirements.txt``, many projects may define one or more of these files,
and may arrange them either at the project root (e.g. ``requirements.txt`` and
``test-requirements.txt``) or else in a directory (e.g.
``requirements/base.txt`` and ``requirements/test.txt``). However, there are
two major issues with the use of requirements files in this way:

* There is no standardized naming convention such that tools can discover or
  use these files by name.

* ``requirementst.txt`` files are *not standardized*, but instead provide
  options to ``pip``.

Therefore, their use is not portable to any new
installer or tool which wishes to process them without relying upon ``pip``.
Additionally, ``requirements.txt`` files may be viewed as a heavyweight
solution for very small dependency sets of only one or two items, and a terser
declaration will be beneficial to projects with a number of small groups of
dependencies.

Regarding extras, the use of extras to define development dependencies is a
widespread practice, but it has two major downsides.

* An extra is defined as an additive group of dependencies for a package.
  This means that it cannot be installed without installing all of the package
  dependencies, and the project must be defined as a package.

* Many developers view their extras as part of the public interface for their
  package. Because these are published data, package developers often are
  concerned about ensuring that their development extras are not confused with
  user-facing extras. Therefore, their development needs are not appropriate to
  publish in the manner of extras.

Providing a standardized place to store dependency data which matches the
typical use-cases of ``requirements.txt`` files will allow for better
cross-compatibility between tools and will onboard beginning users into
``pyproject.toml`` data more quickly (before they learn about the
``build-system`` table, for example). It will also resolve the long-standing
ambiguity and tension within the Python community about whether or not extras
should be used to declare development dependencies.

Supported Project Types
-----------------------

This PEP aims to serve the needs of two distinct project types:

* libraries and other packages which want to define development dependencies

* projects which do not build distributions which want a standardized way to
  declare their dependency data

The Python packaging toolchain is oriented towards the production of wheel and
sdist files, containing project source for installation. However, not all
projects are designed or intended for this mode of distribution. Primary
examples include webapps (which often run from source), and data science
projects (which may start as collections of scripts and only later evolve
package structures). This PEP seeks to offer these projects a way to specify
their package dependencies in a way which is not constrained by the
requirements of distribution building -- for example, a data science project
does not need to declare a version or authors in order for these data to be
valid, nor does it need to define an installable package source tree.

Simultaneously, this PEP should benefit projects which *are* intended to build
distributions. Because these requirements data are explicitly defined to not be
included in any built distribution, two common use-cases are addressed by this
addition:

* the use of ``extras``, as discussed above

* the use of ``requirements.txt`` files for distributed libraries and
  applications, which takes a similar form to their use in
  non-distribution-building projects

Rationale
=========

This PEP defines the storage of requirements data in lists within a
``[requirements.packages]`` table. The naming is motivated by two major
factors:

* The desire to lay claim to a namespace which can be extended
  later. Discussions about project needs have included mention of python version
  requirements and other potential metadata. These could be added to the
  ``[requirements]`` table as siblings of the ``[requirements.packages]`` table.

* The desire for this format to be as simple and learnable as possible,
  having a format very similar to existing ``requirements.txt`` files. Each list
  in ``[requirements.packages]`` is defined as a list of package specifiers.

The format does not support non-package data from ``requirements.txt`` files,
such as ``pip`` options for package servers or hashes. Including them in the
initial stage complicates this proposal and it is not clear that the majority
of use-cases require them. Future expansions to this specification may enable
the use of object declarations, rather than strings, in the
``[requirements.packages]`` values. This specification is written to allow for
this by specifying a valid object format with only one well-defined key.

The following use cases are considered important targets for this PEP:

* A web application (e.g. a Django or Flask app) which does not build a
  distribution, but bundles and ships its source to a deployment toolchain. The
  app has runtime dependencies, testing dependencies, and development
  environment dependencies. All of these dependency sets should be declared
  independently, and none of these runtime contexts should require that the
  project be built into a wheel.
* A library which builds a distribution, but has a variety of testing and
  development environments it wishes to declare. Some of these rely on the
  library's own dependencies (``test`` and ``typing`` environments) while
  others do not (``docs`` and ``lint`` environments).
* A data science project which consists of multiple scripts on the same suite
  of core libraries (e.g. ``numpy``, ``pandas``, ``matplotlib``), and which
  also has additional libraries, sometimes conflicting, for specific scripts
  (e.g. ``scikit-learn==1.3.2`` for one script and ``scikit-learn==0.24.2`` for
  another).
* *Input data* to a lockfile generator. Because there is no standardized
  lockfile format, it is still the prerogative of tools like ``poetry`` and
  ``pip-compile`` to describe their own formats. However, it should be possible
  for the data from this PEP to be used as an input to these tools.
  Furthermore, tools may define their own structures and conventions such that
  the generated lockfiles can be referenced by the names of their originating
  dependency groups in ``pyproject.toml``.
* *Input data* to a tox, Nox, or Hatch environment, as can
  currently be achieved, for example, with ``deps = -r requirements.txt`` in
  ``tox.ini``. These tools will need to add additional options for processing
  Dependency Groups.
* Embeddable data for ``pyproject.toml`` within a script (as in :pep:`723`). This
  PEP does not define exactly how PEP 723 should be modified, but being
  consumable by that interface is a stated goal.
* IDE discovery of requirements data. e.g. VS Code could look for a dependency
  group named ``test`` to use when running tests.

Regarding Poetry and PDM Dependency Groups
------------------------------------------

Poetry and PDM already offer a feature which each calls "Dependency Groups",
but using non-standard data belonging to the ``poetry`` and ``pdm`` tools.
(PDM also uses extras for some Dependency Groups, and overlaps the notion
heavily with extras.)

This PEP is not guaranteed to be a perfectly substitutable solution for the
same problem space for each tool. However, the ideas are extremely similar, and
it should be possible for Poetry and PDM to support at least some
PEP-735-standardized Dependency Group configurations using their own Dependency
Group nomenclature.

A level of interoperability with Poetry and PDM is a goal of this PEP, but
certain features and behaviors defined here may not be supported by Poetry and
PDM. Matching the existing Poetry and PDM *semantics* for Dependency Groups is
a non-goal.

Dependency Groups are not Hidden Extras
---------------------------------------

One could be forgiven for thinking that Dependency Groups are just extras which
go unpublished.

However, there are two major features they have which distinguish them from
extras:

* they support non-package projects

* installation of a dependency group does not imply installation of a package's
  dependencies (or the package itself)

Specification
=============

This PEP defines a new section (table) in ``pyproject.toml`` files named
``requirements``. The ``requirements`` table contains exactly one key,
``packages``, which is a table. All other keys in ``requirements`` are reserved
for future use.

The ``packages`` table contains an arbitrary number of user-defined keys, each of
which has, as its value, a list of requirements specifiers (defined below).
These keys must match the following regular expression:
``[a-z0-9][a-z0-9-]*[a-z0-9]``. Meaning that they must be all lower-case
alphanumerics, with ``-`` allowed only in the middle, and at least
two characters long. These requirements are chosen so that the normalization
rules used for PyPI package names are unnecessary as the names are already
normalized.

Requirements specifiers will use a definition based on :pep:`508`. This PEP
also proposes extending the syntax to define a string format, a
"PEP 735 Dependency". These are defined as strings in one of the following
formats:

* a PEP 508 specification, e.g., ``numpy>1``
* a comma-delimited list of Dependency Group names, enclosed in square
  brackets, e.g., ``[test,docs]`` to refer to other Dependency Groups named
  ``test`` and ``docs`` as specified in ``[requirements.packages]``
* a single dot, ``.``, which refers to the current project as a package
  (similar to ``pip install .``)
* a single dot, followed by square brackets enclosing a list of extra names,
  which refers to the current project as a package including some extras, e.g.,
  ``.[mysql]`` to refer to the current package with its ``mysql`` extra

Requirement specifiers are one of the following:

* A string, which is a valid PEP 735 Dependency Specifier. e.g., ``numpy>1``
* An object, which has exactly one key, ``spec``, which is a valid PEP 735
  Dependency Spec. e.g., ``{spec = "numpy>1"}``

Any additional keys in a requirement specifier object are reserved for future
use.

The following is an example of a ``pyproject.toml`` section which uses this to
define four dependency groups: ``test``, ``docs``, ``typing``, and
``typing-test``:

.. code:: toml

    [requirements.packages]
    test = ["pytest", "coverage", "."]
    docs = ["sphinx", "sphinx-rtd-theme"]
    typing = ["mypy", "types-requests", ".[types]"]
    typing-test = ["[typing,test]", "useful-types"]

Note how ``test`` and ``typing`` are able to refer to the current package
while ``docs`` does not. This reflects the ability of Dependency Groups to be used
in the same manner as extras, adding to dependencies, or completely
independently. ``typing-test`` is defined as a union of two existing groups,
plus an additional package. ``typing`` includes an extra, ``types``.

Implementation Requirements
---------------------------

Build backends MUST NOT include dependency group data in built distributions.

Tools which support Dependency Groups MUST support both string and object
representations of requirements.

When unrecognized keys are encountered in requirement specifiers or the
``requirements`` table, tools MUST NOT fail. They SHOULD emit warnings.

When installing the current package (``.``) from a dependency group, tools
SHOULD prefer editable installs over non-editable installs. They MAY provide
users with options to configure this behavior.

Use of Dependency Groups
------------------------

Tools which support Dependency Groups are expected to provide new options and
interfaces to allow users to install from Dependency Groups. Implementations
may wish to treat them similarly to their current treatments of
``requirements.txt`` files, or more similarly to extras.

No syntax is defined for expressing the dependency group of a package, for two
reasons:

* it would not be valid to refer to the dependency groups of a third-party
  package from pypi (because the data is defined to be unpublished)

* there is not guaranteed to be a current package for dependency groups -- part
  of their purpose is to support non-package projects

For example, a possible pip interface for installing dependency groups
would be:

.. code:: shell

    pip install --dependency-groups=test,typing

Note that this is only an example. This PEP does not declare any requirements
for how tools support the installation of Dependency Groups.

Reference Implementation
========================

There is currently no reference implementation/consumer of this specification.

Backwards Compatibility
=======================

At time of writing, the ``requirements`` namespace within a
``pyproject.toml`` file is unused. Since the top-level namespace is
reserved for use only by standards specified at packaging.python.org,
there should be no direct backwards compatibility concerns.

Future Compatiiblity
--------------------

This PEP defines explicit behaviors for tools when encountering unknown keys
which must be followed in order to remain spec-compliant. These behaviors are
meant to ensure that future PEPs can extend the data with very clear
expectations about how existing tools will behave.

Security Implications
=====================

This PEP introduces new syntaxes and data formats for specifying dependency
information in projects. However, it does not introduce newly specified
mechanisms for handling or resolving dependencies.

It therefore does not carry security concerns other than those inherent in any
tools which may already be used to install dependencies -- i.e. malicious
dependencies may be specified here, just as they may be specified in
``requirements.txt`` files.

How to Teach This
=================

This feature should be referred to by its canonical name, "Dependency Groups".

The basic form of usage should be taught as a variant on typical
``requirements.txt`` data. :pep:`508` package specifiers can be added to a named
list. Rather than asking pip to install from a ``requirements.txt`` file,
either pip or a relevant workflow tool will install from a named Dependency
Group.

For new Python users, they may be taught directly to create a section in
``pyproject.toml`` containing their dependency groups, similarly to how they
are currently taught to use ``pyproject.toml``.

Rejected Ideas
==============

Why not define python-requires as part of the requirements table?
-----------------------------------------------------------------

Discussion around :pep:`722` and :pep:`723,` as well as discussions of projects which
do not produce wheels, have often raised the need to define the python version
which will be used.

This PEP explicitly does not define such a key -- doing so must define
interoperability semantics with respect to the existing packaging-oriented
python-requires key.
It is treated as out-of-scope for the sake of simplicity.

The Dependency Groups data can be defined here and intentionally leaves space
for the addition of new keys in ``[requirements]`` for future PEPs.

Why not define each Dependency Group as a table?
------------------------------------------------

If the goal is to allow for future expansion, then defining each Dependency
Group as a subtable, thus enabling us to attach future keys to each group,
allows for the greatest future flexibility.

However, it also makes the structure nested more deeply, and therefore harder
to teach and learn. One of the goals of this PEP is to be an easy replacement
for many ``requirements.txt`` use-cases.

Why not restrict dependencies to PEP 508 only?
----------------------------------------------

There are valid use-cases for:

* including one dependency group in another
* including the current package (if the project is a package)
* including the current package with extras (if the project is a package)

These are not satisfiable without some expansion of syntax beyond what is
possible with :pep:`508`.

Why not define keys in dependency specifications for common options seen in ``requirements.txt`` (e.g. ``--hash``)?
-------------------------------------------------------------------------------------------------------------------

It is currently unclear which options will be the most necessary and beneficial.

Certain problems, e.g. package hashing, are the domain of lockfiles.
The data in this PEP is meant to be lockfile *input*, not necessarily lockfile *output*.
Therefore, hashing should not be privileged, nor should other options.

The PEP defines space for future expansion of the data format and mandates that
tools support and parse it such that expansion will be a non-breaking change.

Why not restrict dependency specifications to strings only?
-----------------------------------------------------------

Failing to establish the object format at this stage would lead to a breaking
change if it were ever introduced.
Rather than having a smooth degradation path, users would experience breakage
if the object format were introduced and only some tools supported it.

Why is the table not named ``[run]``, ``[dependency_groups]``, ...?
-------------------------------------------------------------------

There are many possible names for this concept.
It will have to live alongside the already existing ``[project.dependencies]``
and ``[project.optional-dependencies]`` tables, and possibly a new
``[external]`` dependency table as well (at time of writing, :pep:`725` is in
progress).

``[run]`` was a leading proposal in earlier discussions, but its proposed usage
centered around a single set of runtime dependencies. This PEP explicitly
outlines multiple groups of dependencies, which makes ``[run]`` a less
appropriate fit -- this is not just dependency data for a specific runtime
context, but for multiple contexts.

``[dependency_groups]`` is a reasonable name, but it fails to namespace the
dependency group data under a related umbrella term. As a result, it would be
harder to extend in the future to include other data, such as python version
requirements.

Why is pip's planned implementation of ``--only-deps`` not sufficient?
----------------------------------------------------------------------

pip currently has a feature on the roadmap to add an
`--only-deps flag <pip only-deps_>`_. This flag is intended to allow users to
install package dependencies and extras without installing the current package.

It does not address the needs of non-package projects, nor does it allow for
the installation of an extra without the package dependencies.

Therefore, while it may be a useful feature for pip to pursue, it does not
address the same use-cases addressed here.

Why isn't <environment manager> a solution?
-------------------------------------------

Existing environment managers like tox, Nox, and Hatch already have
the ability to list inlined dependencies as part of their configuration data.
This meets many development dependency needs, and clearly associates dependency
groups with relevant tasks which can be run.
These mechanisms are *good* but they are not *sufficient*.

First, they do not address the needs of non-package projects.

Second, there is no standard for other tools to use to access these data. This
has impacts on high-level tools like IDEs and Dependabot, which cannot support
deep integration with these dependency groups. (For example, at time of writing
Dependabot will not flag dependencies which are pinned in ``tox.ini`` files.)

Open Issues
===========

Section Naming
--------------

The name of the section is not yet finalized. The current proposal is
``[requirements.packages]``.

Some commenters have suggested that ``requirements`` should be avoided, and
others have suggested that ``requirements`` is fine but ``packages`` is too
vague/generic.

Syntax For Groups Including Groups
----------------------------------

One of the current outstanding concerns is that ``.[test]`` (an extra) and
``[test]`` (a dependency group) are too similar.

The syntax for Dependency Groups to refer to one another is not yet finalized.

References
==========

.. _pip only-deps: https://github.com/pypa/pip/issues/11440

Footnotes
=========

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
