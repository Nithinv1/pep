PEP: 724
Title: Stricter Type Guards
Author: Rich Chiodo <rchiodo at microsoft.com>, 
        Eric Traut <erictr at microsoft.com>, 
        Erik De Bonte <erikd at microsoft.com>
Sponsor: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Discussions-To: https://mail.python.org/archives/list/typing-sig@python.org/thread/EMUD2D424OI53DCWQ4H5L6SJD2IXBHUL/
Status: Draft
Type: Standards Track
Topic: Typing
Content-Type: text/x-rst
Created: 28-Jul-2023
Python-Version: 3.13
Post-History: 
Resolution: 


Abstract
========

:pep:`647` introduced the concept of ``TypeGuard`` functions which return
``True`` if their input parameter matches their target type. For example, a
function that returns ``TypeGuard[str]`` is assumed to return ``True`` if and
only if its input parameter is a ``str``. This allows type checkers to narrow
types when a ``TypeGuard`` function returns ``True``.

This PEP further refines :pep:`647` by allowing type checkers to also narrow
types when a ``TypeGuard`` function returns ``False``.

Motivation
==========

``TypeGuards`` are used throughout Python libraries to allow a type checker to
narrow the type of something when the ``TypeGuard`` returns ``True``.

However, in the ``False`` case, :pep:`647` doesn't prescribe what the type
might be:

.. code-block:: python

    def is_str(val: str | int) -> TypeGuard[str]:
        return isinstance(val, str)

    def func(val: str | int):
        if is_str(val):
            # Type checkers can assume val is a 'str' in this branch
        else:
            # Type here is not narrowed. It is still 'str | int' 


Specification
=============

This PEP proposes some modifications to :pep:`647` in order to allow a type
checker to further narrow what a ``TypeGuard`` is indicating when it returns
``False``.

* When the output type of a ``TypeGuard`` is consistent [#isconsistent]_ with
  the type of its first input parameter, type checkers will apply stricter type
  semantics:

.. code-block:: python
    
    # Stricter TypeGuard possible (Kangaroo | Koala is consistent with Animal)
    def is_marsupial(val: Animal) -> TypeGuard[Kangaroo | Koala]: 
        return isinstance(val, Kangaroo | Koala)

    # Stricter TypeGuard not possible (list[T] is not consistent with 
    # list[T | None])
    def has_no_nones(val: list[T | None]) -> TypeGuard[list[T]]: 
        return None not in val

* When stricter semantics are possible, the output type for the ``False`` case
  can be determined:

.. code-block:: python

    def is_str(val: str | int) -> TypeGuard[str]: # Stricter mode possible
        return isinstance(val, str)

    def func(val: str | int):
        if is_str(val):
            # Type checkers can assume val is a 'str' in this branch
        else:
            # Type checkers can assume val is an 'int' in this branch

* When the output type of the ``TypeGuard`` is a union, the type checker can
  apply additional type narrowing based on the type of the first input
  argument, eliminating union elements that are impossible given the input
  argument type:

.. code-block:: python

    def is_cardinal_direction(val: str) -> TypeGuard[Literal["N", "S", "E", "W"]]:
        return val in ("N", "S", "E", "W")

    def func(direction: Literal["NW", "E"]):
        if is_cardinal_direction(direction):
            # Literal["E"] The type cannot be "N", "S" or "W" here because of
            # argument type
        else:
            # Literal["NW"]

Backwards Compatibility
=======================

The new ``False`` case for a ``TypeGuard`` can lead to incorrect assumptions.
As an example:

.. code-block:: python

    def is_positive_int(val: int | str) -> TypeGuard[int]:
        return isinstance(val, int) and val > 0

    def func(val: int | str):
        if is_positive_int(val):
            # Type checker assumes int here
        else:
            # Type checker assumes str here

A type checker will assume in the ``False`` case that the value is ``str``.
This is a change in behavior from :pep:`647` but as that PEP stated, there are
many ways a determined or uninformed developer can subvert type safety.

A better way to handle this example would be something like so:

.. code-block:: python

    PosInt = NewType('PosInt', int)

    def is_positive_int(val: PosInt | int | str) -> TypeGuard[PosInt]:
        return isinstance(val, int) and val > 0

    def func(val: int | str):
        if is_positive_int(val):
            # Type checker assumes PosInt here
        else:
            # Type checker assumes str | int here

The assumption is that anyone using stricter ``TypeGuards`` will be able to
understand these limitations.

How to Teach This
=================

We assert that users unfamiliar with ``TypeGuard`` will expect the behavior
outlined in this PEP, therefore making ``TypeGuard`` easier to teach and
explain.


Reference Implementation
========================

A reference `implementation`__ of this idea exists in Pyright.

__ https://github.com/microsoft/pyright/commit/9a5af798d726bd0612cebee7223676c39cf0b9b0


Rejected Ideas
==============

Originally a new ``StrictTypeGuard`` construct was proposed. A
``StrictTypeGuard`` would be similar to to a ``TypeGuard`` except it would
explicitly state that output type was consistent [#isconsistent]_ with the
input type. Type checkers would validate that the output type was consistent
[#isconsistent]_ of the input type.

See this comment: `StrictTypeGuard proposal`__

__ https://github.com/python/typing/discussions/1013#discussioncomment-1966238

This was rejected because for most cases it's not necessary. Most people assume
when the ``TypeGuard`` returns ``False``, that the input type has been narrowed
to its other type. Why not just change the specification to match their
assumptions?

Footnotes
=========

.. [#isconsistent] :pep:`PEP 483's discussion of is-consistent <483#summary-of-gradual-typing>`

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
