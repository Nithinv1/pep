PEP: 692
Title: Using TypedDict for more precise \*\*kwargs typing
Author: Franek Magiera <framagie@gmail.com>
Sponsor: Jelle Zijlstra <jelle.zijlstra@gmail.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 29-May-2022
Python-Version: 3.12
Post-History: 29-May-2022


Abstract
========

Current specification enables for type hinting ``**kwargs`` as long as all of
the keyword arguments specified by them are of the same type. However, that
behaviour can be very limiting. Therefore, in this PEP we propose a new way to
enable more precise ``**kwargs`` typing. The new approach revolves around using
``TypedDict`` to type ``**kwargs`` that comprise keyword arguments of different
types.

Motivation
==========

Currently annotating ``**kwargs`` with a type ``T`` means that the ``kwargs``
type is in fact ``dict[str, T]``. For example:

::

    def foo(**kwargs: str) -> None: ...

means that all keyword arguments in ``foo`` are strings (i.e., ``kwargs`` is of
type ``dict[str, str]``). This behaviour limits the ability to type annotate
``**kwargs`` only to the cases where all of them are of the same type. However,
it is often the case that keyword arguments conveyed by ``**kwargs`` have
different types that are dependent on the keyword's name. In those cases type
annotating ``**kwargs`` is not possible. This is especially a problem for
already existing codebases where the need of refactoring the code in order to
introduce proper type annotations may be considered not worth the effort. This
in turn prevents the project from getting all of the benefits that type hinting
can provide. As a consequence, there has been a lot of discussion around
supporting more precise ``**kwargs`` typing [#mypyIssue4441]_ and it became a
feature that is necessary for a large part of Python community.

Rationale
=========

PEP 589 introduced the ``TypedDict`` type constructor that supports dictionary
types consisting of string keys and values of potentially different types. A
function's keyword arguments represented by a formal parameter that begins with
double asterisk, such as ``**kwargs``, are received as a dictionary. This makes
``TypedDict`` a perfect candidate to be used for more precise ``**kwargs``
typing. In addition, with ``TypedDict`` keyword names can be taken into account
during static type analysis. However, specifying ``**kwargs`` type with a
``TypedDict`` means, as mentioned earlier, that each keyword argument specified
by ``**kwargs`` is a ``TypedDict`` itself. For instance:

::

    class Movie(TypedDict):
        name: str
        year: int
    
    def foo(**kwargs: Movie) -> None: ...

means that each keyword argument in ``foo`` is itself a ``Movie`` dictionary
that has a ``name`` key with a string type value and a ``year`` key with an
integer type value. Therefore, in order to support specifying ``kwargs`` type
as a ``TypedDict`` without breaking current behaviour, a new syntax has to be
introduced.

Specification
=============

To support the aforementioned use case we propose to use the double asterisk
syntax inside of the type annotation. The required grammar change is discussed
in more detail in section `Grammar Changes`_. Continuing the previous example:

::

    def foo(**kwargs: **Movie) -> None: ...

would mean that the ``**kwargs`` comprise two keyword arguments specified by
``Movie`` (i.e. a ``name`` keyword of type ``str`` and a ``year`` keyword of
type ``int``). Then, inside the function itself, the type checkers should treat
the ``kwargs`` parameter as a ``TypedDict``:

::

    def foo(**kwargs: **Movie) -> None:
        assert_type(kwargs, Movie)  # OK!


Using the new annotation will not have any runtime effect - it should only be
taken into account by the type checkers.

Function calls with standard dictionaries
-----------------------------------------

Calling a function that has ``**kwargs`` typed using the ``**kwargs: **Movie``
syntax with a standard dictionary must generate an error. For example:

::

    def foo(**kwargs: **Movie) -> None: ...

    movie: dict[str, object] = {"name": "Life of Brian", "year": 1979}
    foo(**movie)  # WRONG! Movie is of type dict[str, object]

    typedMovie: Movie = {"name": "The Meaning of Life", "year": 1983}
    foo(**typedMovie)  # OK!


Keyword collisions
------------------

A ``TypedDict`` that is used to type ``**kwargs`` could potentially contain keys
that are already defined in the function's signature. If the duplicate name is a
standard argument, an error should be reported. If the duplicate name is a
positional only argument, no errors should be generated. For example:

::

    def foo(name, **kwargs: **Movie) -> None: ...     # WRONG! "name" will
                                                      # always bind to the first
                                                      # parameter.

    def foo(name, /, **kwargs: **Movie) -> None: ...  # OK! "name" is a
                                                      # positional argument,
                                                      # so **kwargs can contain
                                                      # a "name" keyword.


Required and non-required keys
------------------------------

By default all keys in a ``TypedDict`` are required. This behaviour can be
overridden by setting the dictionary's ``total`` parameter as ``False``.
Moreover, PEP 655 introduced new type qualifiers - ``typing.Required`` and
``typing.NotRequired`` - that enable specyfing whether a particular key is
required or not:

::

    class Movie(TypedDict):
        title: str
        year: NotRequired[int]

When using a ``TypedDict`` to type ``**kwargs`` all of the required and
non-required keys should correspond to required and non-required function
keyword parameters. Therefore, if a required key is not supported by the caller,
then an error must be reported.

Assignment
----------
Assignments of a function typed with the ``**kwargs: **Movie`` construct and
another callable type should pass type checking only if they are compatible.
This can happen in the following cases:

1. Both destination and source functions have a ``**kwargs: **TypedDict``
parameter and the destination function's ``TypedDict`` is assignable to the
source function's ``TypedDict`` and the rest of the parameters are compatible:

::

    class Animal(TypedDict):
        name: str
    
    class Dog(Animal):
        breed: str

    def accept_animal(**kwargs: **Animal): ...
    def accept_dog(**kwargs: **Dog): ...

    accept_dog = accept_animal  # OK! Expression of type Dog can be
                                # assigned to a variable of type Animal.

    accept_animal = accept_dog  # WRONG! Expression of type Animal
                                # cannot be assigned to a variable of type Dog.

2. The destination callable doesn't contain ``**kwargs``, the source callable
contains ``**kwargs: **TypedDict`` and the destination function's keyword
arguments are assignable to the corresponding keys in source function's
``TypedDict``. Moreover, not required keys should correspond to optional
function arguments, whereas required keys should correspond to required function
arguments. Again, the rest of the parameters have to be compatible. Continuing
the previous example: 

::

    class Example(TypedDict):
        animal: Animal 
        string: str
        number: NotRequired[int]
    
    def src(**kwargs: **Example): ...
    def dest(animal: Dog, string: str, number: int = ...): ...

    dest = src  # OK!

3. The destination callable contains ``**kwargs: **TypedDict``, the source
callable doesn't contain ``**kwargs`` and the destination function's
``TypedDict`` fields are assignable to the corresponding keyword arguments in
the source function. Again, required and not required keys should be compatible
with the keyword arguments and the rest of the parameters should be compatible.
For example:

::

    class Example(TypedDict):
        animal: Dog
        string: str
        number: NotRequired[int]

    def src(animal: Animal, string: str, number: int = ...): ...
    def dest(**kwargs: **Example): ...

    dest = src  # OK!

4. The destination callable contains ``**kwargs: **TypedDict`` and the source
callable contains untyped ``**kwargs``:

::

    def src(**kwargs): ...
    def dest(**kwargs: **Movie): ...

    dest = src  # OK!

5. The destination callable contains ``**kwargs: **TypedDict``, the source
callable contains traditionally typed ``**kwargs: T`` and each of the
destination function ``TypedDict``\'s fields is assignable to a variable of type
``T``.

On the other hand, if the destination callable contains either untyped or
traditionally typed ``**kwargs: T`` and the source callable is typed using
``**kwargs: **TypedDict`` then an error should be generated, because
traditionally typed ``**kwargs`` aren't checked for keyword names.

To sum up points, functions' parameters should behave contravariantly. In
addition, functions' return types should behave covariantly. 

Grammar Changes
===============
This PEP requires a grammar change so that the double asterisk syntax is allowed
for ``**kwargs`` annotations. The proposed change is to extend the ``kwds`` rule
as follows:

Before:

::

    kwds: '**' param_no_default 

After:

::

    kwds:
        | '**' param_no_default_double_star_annotation
        | '**' param_no_default

    param_no_default_double_star_annotation:
        | param_double_star_annotation & ')'

    param_double_star_annotation: NAME double_star_annotation

    double_star_annotation: ':' double_star_expression

    double_star_expression: '**' expression

A new AST node needs to be created so that type checkers can differentiate the
semantics of the new syntax and take into account that the ``**kwargs`` should
be unpacked. The proposition is to add a new ``DoubleStarred`` AST node. Then,
an AST node for the function defined as:

::

    def foo(**kwargs: **Movie): ...

should look as below:

::

    FunctionDef(
      name='foo',
      args=arguments(
        posonlyargs=[],
        args=[],
        kwonlyargs=[],
        kw_defaults=[],
        kwarg=arg(
          arg='kwargs',
          annotation=DoubleStarred(
            value=Name(id='Movie', ctx=Load()),
            ctx=Load())),
        defaults=[]),
      body=[
        Expr(
          value=Constant(value=Ellipsis))],
      decorator_list=[])],
    type_ignores=[])

The runtime annotations should be consistent with the AST. Continuing the
previous example:

::

    >>> def foo(**kwargs: **Movie): ...
    ...
    >>> foo.__annotations__
    {'kwargs': **Movie}

The double asterisk operator should call the ``__unpack__`` special method on
the object it was used on. This means that ``def foo(**kwargs: **T): ...`` is
equivalent to ``def foo(**kwargs: T.__unpack__()): ...``.

Backwards Compatibility
-----------------------

Using the double asterisk operator for annotating ``**kwargs`` is a syntax that
would be only available in new versions of Python. PEP 646 dealt with the
similar problem and its authors introduced a new type operator ``Unpack``. For
the purposes of this PEP, the proposition is to reuse ``Unpack`` for more
precise ``**kwargs`` typing. For example:

::

    def foo(**kwargs: Unpack[Movie]) -> None: ...

There are several reasons for reusing PEP 646's ``Unpack``. Firstly, the name is
quite suitable and intuitive for the ``**kwargs`` typing use case as the
keywords arguments are "unpacked" from the ``TypedDict``. Secondly, there would
be no need to introduce any new special forms. Lastly, the use of ``Unpack`` for
the purposes described in this PEP does not interfere with the use cases
described in PEP 646.

Alternatives
------------

Instead of making the grammar change, ``Unpack`` could be the only way to
annotate ``**kwargs`` of different types. However, introducing the double
asterisk syntax has two advantages. Namely, it is more concise and more
intuitive than using ``Unpack``.

How to Teach This
=================

This PEP could be linked in the ``typing`` module's documentation. Moreover, a
new section on using ``Unpack`` as well as the new double asterisk syntax could
be added to the aforementioned docs. Similar sections could be also added to the
mypy's documentation.

Reference Implementation
========================

There is a proof-of-concept implementation of typing ``**kwargs`` using
``TypedDict`` on GitHub [#mypyPull10576]_, [#mypyExtensionsPull22]_ based on
mypy. The implementation uses ``Expand`` instead of ``Unpack``.

Pyright type checker provides a provisional support for this feature
[#pyrightIssue3002]_, [#pyrightProvisionalImplementation]_.

A proof-of-concept implementation of the cpython grammar changes described in
this PEP is available on Github[#cpythonGrammarChangePoc]_.

Rejected Ideas
==============

``TypedDict`` unions
--------------------

It is possible to create unions of typed dictionaries. However, supporting
typing ``**kwargs`` with a union of typed dicts would greatly increase the
complexity of the implementation of this PEP and there seems to be no compelling
use case to justify the support for this. Therefore, using unions of typed
dictionaries to type ``**kwargs`` as described in the context of this PEP can
result in an error:

::

    class Book(TypedDict):
        genre: str
        pages: int
    
    TypedDictUnion = Movie | Book

    def foo(**kwargs: **TypedDictUnion) -> None: ...  # ERROR! Unsupported use
                                                      # of a union of TypedDicts
                                                      # to type **kwargs

Instead, a function that expects a union of ``TypedDict``\s can be overloaded:

::

    @overload
    def foo(**kwargs: **Movie): ...

    @overload
    def foo(**kwargs: **Book): ...


References
==========

.. [#mypyIssue4441] python/mypy issue #4441:
   https://github.com/python/mypy/issues/4441

.. [#mypyPull10576] python/mypy pull request #10576:
   https://github.com/python/mypy/pull/10576

.. [#mypyExtensionsPull22] python/mypy_extensions pull request #22:
   https://github.com/python/mypy_extensions/pull/22/files

.. [#pyrightIssue3002] pyright issue #3002:
   https://github.com/microsoft/pyright/issues/3002

.. [#pyrightProvisionalImplementation] pyright provisional implementation:
   https://github.com/microsoft/pyright/commit/5bee749eb171979e3f526cd8e5bf66b00593378a

.. [#cpythonGrammarChangePoc] naive grammar change poc implementation:
   https://github.com/python/cpython/compare/main...franekmagiera:annotate-kwargs

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.

..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End: