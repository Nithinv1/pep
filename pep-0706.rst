PEP: 706
Title: Filter for tarfile.extractall
Author: Petr Viktorin <encukou@gmail.com>
Discussions-To:
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 09-Feb-2023
Python-Version: 3.12
Post-History: `25-Jan-2023 <https://discuss.python.org/t/23149>`__,


Abstract
========

The extraction methods in ``tarfile`` gain a ``filter`` argument,
which allows rejecting files or modifying metadata as the archive is extracted.
Three built-in named filters are provided, aimed at limiting features that
might be surprising or dangerous.
These can be used as-is, or serve as a base for custom filters.

After a deprecation period, a strict (but safer) filter will become the default.

The API is meant to set a precedent for other archive libraries, such as
``zipfile``.


Motivation
==========

The ``tar`` format is used for several use cases, many of which have different
needs. For example:

- A backup of a UNIX workstation should faithfully preserve all kinds of
  details like file permissions, symlinks to system configuration, and various
  kinds of special files.
- When unpacking a data bundle, it’s much more important that the unpacking
  will not have unintended consequences – like exposing a password file by
  symlinking it to a public place.

To support all its use cases, the ``tar`` format has many features.
In many cases, it's best to ignore or disallow some of them when extracting
an archive.

Python allows extracting ``tar`` archives using
``tarfile.TarFile.extractall()``, whose docs warn to
*never extract archives from untrusted sources without prior inspection*.
However, it’s not clear what kind of inspection should be done.
Indeed, it’s quite tricky to do such an inspection correctly.
As a result, many people don’t bother, or do the check incorrectly, resulting in
security issues such as `CVE-2007-4559`_.

Since :mod:`tarfile` was first written, it's become more accepted that warnings
in documentation are not enough.
Whenever possible, an unsafe operation should be *explicitly requested*;
potentially dangerous operations should *look* dangerous.
However, ``TarFile.extractall`` looks benign in a code review.

Tarfile extraction is also exposed via ``shutil.unpack_archive``, which allows
the user to not care about the kind of archive they're dealing with.
The API is very inviting for extracting archives without prior inspection,
even though the docs again warn against it.

It has been argued that Python is not wrong -- it behaves exactly as
documented -- but that's beside the point.
Let's improve the situation rather than assign/avoid blame.
Python and its docs are the best place to improve things.


Rationale
=========

How do we improve things?
Unfortunately, we will need to change the defaults, which implies
breaking backwards compatibility. ``TarFile.extractall()`` is what people reach
for when they need to extract a tarball. Its default behaviour needs to change.

What would be the best behaviour? That depends on the use case.
So, we'll add several general “policies” to control extraction.
They are based on *use cases*, and ideally they should have straightforward
security implications:

- Current behavior: trusting the archive. Suitable e.g. as a building block
  for libraries that do the check themselves, or extracting an archive you just
  made yourself.
- Unpacking a UNIX archive: roughly following GNU ``tar``, e.g. stripping
  leading ``/`` from filenames.
- Unpacking a general data archive: the ``shutil.unpack_archive`` use case,
  where it's not important to preserve details specific to ``tar`` or
  Unix-like filesystems.

After a deprecation period, the last option -- the most limited
but most secure one -- will become the default.

Even with better general defaults, users should still verify the archives
they extract, and perhaps modify some of the metadata.
Superficially, the following looks like a reasonable way to do this today:

* Call ``TarFile.getmembers()``
* Verify or modify each member's ``TarInfo``
* Pass the result to ``extractall``'s ``members``

However, there are some issues with this approach:

- ``TarInfo`` does not officially allow modification. You can modify it, but you
  can get surprising results since ``TarInfo`` objects are cached/shared.
- Calling ``getmembers`` can be expensive and it 
  `requires a seekable archive <https://github.com/python/cpython/issues/45385#issuecomment-1255615199>`__.
- When verifying members in advance, it may be necessary to track how each
  member would have changed the filesystem, e.g. how symlinks are being set up.
  This is hard. We can't expect users to do it.

To solve these issues we'll:

- Provide a supported way to modify ``TarInfo`` when needed,
  without unnecessary work when not.
  A ``replace`` method, similar to :func:`dataclasses.replace`
  or :func:`namedtuple._replace <collections.namedtuple._replace>`
  should do the trick.
- Provide a “filter” hook in ``extractall``'s loop that can modify or discard
  members before they are processed.
- Require that this hook is called just before extracting each member,
  so it can scan the *current* state of the disk. This will greatly simplify
  the implementation of policies (both in stdlib and user code),
  at the cost of not being able to do a precise “dry run”.

The hook API will be very similar to the existing ``filter`` argument
for :meth:`tarfile.TarFile.add`.
We'll also name it ``filter``.
(In some cases “policy” would be a more fitting name,
but the API can be used for more than security policies.)

The built-in policies/filters described above will be implemented using the
public filter API, so they can be used as building blocks or examples.


Setting a precedent
-------------------

If and when other libraries for archive extraction, such as ``zipfile``,
gain similar functionality, they should mimic this API as much as it's
reasonable.

To enable this for simple cases, the built-in filters will have string names;
e.g. users can pass ``filter='data'`` instead of a specific function that deals
with ``TarInfo`` objects.

The ``shutil.extract_archive()`` function will get a ``filter`` argument,
which it will pass to ``extractall``.

Adding function-based API that would work across archive formats is
out of scope of this PEP.


Full disclosure & redistributor info
------------------------------------

The PEP author works for Red Hat, a redistributor of Python with different
security needs and support periods than CPython in general.
Such redistributors may want to carry vendor patches to:

* Allow configuring the defaults system-wide, and
* Change the default as soon as possible, even in older Python versions.

The proposal makes this easy to do, and it allows users to query
the settings.


Specification
=============

Modifying and forgetting member metadata
----------------------------------------

The ``TarInfo`` class will gain a new method, ``replace()``,
which will work similarly to ``dataclasses.replace``.
It will return a *deep* copy of the ``TarInfo`` object with attributes
replaced as specified by keyword-only arguments:

* ``name``
* ``mtime``
* ``mode``
* ``linkname``
* ``uid``
* ``gid``
* ``uname``
* ``gname``

Any of these, except ``name`` and ``linkname``, will be allowed to be set
to ``None``.
When ``extract`` or ``extractall`` encounters such a ``None``, it will not
set that piece of metadata, leaving it as if the file was created by ``open()``.
When ``addfile`` encounters such a ``None``, it will raise an error.
(It could also not store the attribute, if the format allows it,
but that's a possible future enhancement.)

The documentation will mention why the method is there:
``TarInfo`` objects retrieved from ``TarFile.getmembers()`` are “live”;
modifying them directly will affect subsequent unrelated operations.


Filters
-------

``TarFile.extract`` and ``TarFile.extractall`` methods will grow a ``filter``
parameter, which takes a function with the signature::

    filter(member: TarInfo) -> TarInfo|None

When used it will be called on each member as it is extracted,
and extraction will work with the result.
If it returns ``None``, the member will be skipped.

The function can also raise an exception.
This can, depending on ``Tarfile.errorlevel``, abort the extraction or cause
the member to be skipped.

We will also provide a set of defaults for common use cases.
In addition to a function, the ``filter`` argument can be one
of the following strings:

* ``'fully_trusted'``: Current behavior: honor the metadata as is.
  Should be used if the user trusts the archive completely, or implements their
  own complex verification.
* ``'tar'``: Roughly follow defaults of the GNU ``tar`` command
  (when run as a normal user):

  * Strip leading ``/`` from filenames
  * Refuse to extract files with a ``..`` component in the filename
  * Refuse to extract files whose absolute path (after following symlinks)
    would end up outside the destination.
    (Note that GNU ``tar`` instead delays creating some links.)
  * Clear high mode bits (setuid, setgid, sticky) and group/other write bits
    (``S_IWGRP|S_IWOTH``).
    (This is an approximation of ``tar``'s default, which limits the mode by
    the current ``umask`` setting.)

* ``'data'``:  Extract a "data" archive, disallowing common attack vectors
  but limiting functionality.
  In particular, many features specific to UNIX-style filesystems (or
  equivalently, to the ``tar`` archive format) are ignored, making this a good
  filter for cross-platform archives.
  In addition to ``tar``:

  * Refuse to extract links (hard or soft) which end up linking to a path
    outside of the destination.
    (On systems that don't support links, ``tarfile`` will, in most cases,
    fall back to creating regular files.
    This proposal doesn't change that behaviour.)
  * Refuse to extract device files (including pipes).
  * For regular files and hard links:

    * Set the owner read and write permissions (``S_IRUSR|S_IWUSR``).
      (By now only the *executable* bits depend on information in the archive.)
    * Remove the group & other *executable* permission (``S_IXGRP|S_IXOTH``)
      if the user doesn't have it (``S_IXUSR``).

  * For other files (directories), ignore mode entirely (set it to ``None``).
  * Ignore user and group info (set ``uid``, ``gid``, ``uname``, ``gname``
    to ``None``).

* ``'legacy_warning'``: Like ``'fully_trusted'``, but emit a 
  ``DeprecationWarning`` for each member that would be changed or removed under
  ``'data'``.

The corresponding filter functions will be available as
``tarfile.fully_trusted_filter()``, ``tarfile.tar_filter()``, etc., so
they can be easily used in custom policies.

FilterError
-----------

A new exception, ``FilterError``, will be added.
It'll have several new subclasses, one for each of the refusal reasons above.
``FilterError``'s ``member`` attribute will contain the relevant ``TarInfo``.

In the lists above, “refusing" to extract a file means that a ``FilterError``
will be raised.
As with other extraction errors, if the ``TarFile.errorlevel`` is 1 or more,
this will abort the extraction; with ``errorlevel=0`` the error will be
logged and the member will be ignored, but extraction will continue.
Note that ``extractall()`` may leave the archive partially extracted;
it is the user's responsibility to clean up.


Defaults and their configuration
--------------------------------

``TarFile`` will get a new class member ``extraction_filter``, with the
default filter.
This will be ``tarfile.legacy_warning_filter`` in Python 3.12 and 3.13,
and ``tarfile.data_filter`` from Python 3.14 on.

Applications and system integrators may wish to change ``extraction_filter``
to suit their requirements.
Users may also assign the ``extraction_filter`` attribute of an individual
``TarFile`` instance to specify the default filter.
Note that the attribute should be set to a filter function, not a string name.

.. note::

  Allowing strings would encourage code like
  ``my_tarfile.extraction_filter = 'data'``.
  On Python versions without this feature, this would do nothing,
  silently ignoring a security-related request.


Hints for further verification
------------------------------

Even with the proposed changes, ``tarfile`` will not be suited for extracting
untrusted files without prior inspection.
Among other issues, the proposed policies don't prevent denial-of-service
attacks.
Users should do additional checks.

New docs will tell users to consider:

* extracting to a new empty directory,
* checking filenames against an allow-list of characters (to filter out control
  characters, confusables, etc.),
* checking that filenames have expected extensions (discouraging files that
  execute when you “click on them”, or extension-less files like Windows
  special device names),
* limiting the total size of extracted data, size of individual files,
  and number of files,
* checking for files that would be shadowed on case-insensitive filesystems.

Also, the docs will note that:

* tar files commonly contain multiple versions of the same file: later ones are
  expected to overwrite earlier ones on extraction,
* ``tarfile`` does not protect against issues with “live” data, e.g. an attacker
  tinkering with the destination directory while extracting (or adding) is
  going on (see the `GNU tar manual <https://www.gnu.org/software/tar/manual/html_node/Live-untrusted-data.html#Live-untrusted-data>`__
  for more info).

This list is not comprehensive, but the documentation is a good place to
collect such general tips.
It can be moved into a separate document if grows too long or if it needs to
be consolidated with ``zipfile`` or ``shutil`` (which is out of scope for
this proposal).


Other archive libraries
-----------------------

This PEP is meant to set a precedent.

If and when other archive libraries, such as ``zipfile``, grow similar
functionality, their extraction functions should use a ``filter`` argument
that takes, at least, the strings ``'fully_trusted'`` and ``'data'``, with
semantics similar to the ones in ``tarfile``.

Standardizing a function-based filter API is out of scope of this PEP.


Shutil
------

``shutil.unpack_archive`` will gain a ``filter`` argument.
If it's given, it will be passed to the underlying extraction function.
Passing it for a ``zip`` archive will fail for now (until ``zipfile`` gains a
``filter`` argument).

If ``filter`` is not specified (or left as ``None``), it won't be passed
on, so extracting a tarball will use the default filter
(``'legacy_warning'`` for a deprecation period, then ``'data'``).


Backwards Compatibility
=======================

The proposal follows Python's :pep:`backwards compatibility policy <387>`,
using the shortest allowed deprecation period (two years) for the
incompatible change.


Backporting & Forward Compatibility
===================================

This feature may be backported to older versions of Python.

In CPython, we don't add warnings to patch releases, so the default
filter should be changed to ``'fully_trusted'`` in backports.

Other than that, *all* of the changes to ``tarfile`` should be backported, so
``hasattr(tarfile, 'data_filter')`` becomes a reliable check for all
of the new functionality.

Note that CPython's usual policy is to avoid adding new APIs in security
backports.
This feature does not make sense without a new API
(``TarFile.extraction_filter`` and the ``filter`` argument),
so we'll make an exception.
(See `Discourse comment 23149/16 <https://discuss.python.org/t/23149/16>`__
for details.)

Here are examples of code that takes into account that ``tarfile`` may or may
not not have the proposed feature.

When copying these snippets, note that setting ``extraction_filter``
will affect subsequent operations.

* Fully trusted archive::

    my_tarfile.extraction_filter = (lambda member: member)
    my_tarfile.extractall()

* Use the ``'data'`` filter if available, but revert to Python 3.11 behavior
  (``'fully_trusted'``) if this feature is not available::

    my_tarfile.extraction_filter = getattr(tarfile, 'data_filter', lambda member: member)
    my_tarfile.extractall()

  (This is an unsafe operation, so it should be spelled out explicitly,
  ideally with a comment.)

* Use the ``'data'`` filter; *fail* if it is not available::

    my_tarfile.extractall(filter=tarfile.data_filter)

  or::

    my_tarfile.extraction_filter = tarfile.data_filter
    my_tarfile.extractall()

* Use the ``'data'`` filter; *warn* if it is not available::

   if hasattr(tarfile, 'data_filter'):
       my_tarfile.extractall(filter='data')
   else:
       # remove this when no longer needed
       warn_the_user('Extracting may be unsafe; consider updating Python')
       my_tarfile.extractall()


Security Implications
=====================

This proposal improves security, at the expense of backwards compatibility.
In particular, it will help users avoid `CVE-2007-4559`_.


How to Teach This
=================

The API, usage notes and tips for further verification will be added to
the documentation.
These should be usable for users who know how to extract an archive, but are
not familiar with the specifics of UNIX filesystems nor the related security
issues.


Reference Implementation
========================

XXX None yet.


Rejected Ideas
==============

SafeTarFile
-----------

An initial idea from Lars Gustäbel was to provide a separate class that
implements security checks (see `gh-65308`_).
There are two major issues with this approach:

* The name is misleading. General archive operations can never be made “safe”
  from all kinds of unwanted behavior, without impacting legitimate use cases.
* It does not solve the problem of unsafe defaults.

However, many of the ideas behind SafeTarFile were reused in this PEP.

Add absolute_path option to tarfile
-----------------------------------

A minimal change to check the “CVE resolved” box doesn't go far enough to
protect the unaware, nor to empower the diligent and curious.


Open Issues
===========

How far should this be backported?


Thanks
======

This proposal is based on prior work and discussions by many people,
in particular Lars Gustäbel, Gregory P. Smith, Larry Hastings, Joachim Wagner,
Jan Matejek, Jakub Wilk, Daniel Garcia, Lumír Balhar, Miro Hrončok,
and many others.

References
==========

.. _CVE-2007-4559: https://nvd.nist.gov/vuln/detail/CVE-2007-4559

.. _gh-65308: https://github.com/python/cpython/issues/65308

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
