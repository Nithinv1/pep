PEP: 620
Title: Hide implementation details from the C API
Author: Victor Stinner <vstinner@python.org>,
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 19-June-2020
Python-Version: 3.10

Abstract
========

Reorganize the C API header files to have a clear separation between
the limited C API, the CPython C API and the internal C API.

Structures members of the C API must only be accessed with getter and
setter functions: structures become opaque.

Macros are converted to static inline functions.

``Py_TYPE()``, ``Py_REFCNT()`` and ``Py_SIZE()`` can not be used as
l-value: new functions ``Py_SET_TYPE()``, ``Py_SET_REFCNT()`` and
``Py_SET_SIZE()`` must be used instead.

A new ``pythoncapi_compat.h`` header file is distributed with Python to
provide new Python functions for old Python versions.

A process is defined to reduce the number of broken C extensions when
incompatible changes are introduced in the C API.


Motivation
==========

Same CPython design since 1990: structures and reference counting
-----------------------------------------------------------------

When the CPython project was created, it was written with one principle:
keep the implementation simple enough so it can be maintained by a
single developer. CPython complexity grew a lot and many
micro-optimizations have been implemented, but CPython core design has
not changed.

Members of ``PyObject`` and ``PyTupleObject`` structures have not
changed since the "Initial revision" commit (1990)::

    #define OB_HEAD \
        unsigned int ob_refcnt; \
        struct _typeobject *ob_type;

    typedef struct _object {
        OB_HEAD
    } object;

    typedef struct {
           OB_VARHEAD
           object *ob_item[1];
    } tupleobject;

Only names changed: ``object`` was renamed to ``PyObject`` and
``tupleobject`` was renamed to ``PyTupleObject``.

CPython still tracks objects lifetime using reference counting
internally and for third party C extensions (through the Python C API).

All Python objects must be allocated on the heap and cannot be moved.

Why is PyPy more efficient than CPython?
----------------------------------------

The PyPy project is a Python implementation which is 4.2x faster than
CPython in average. PyPy developers chose to not fork CPython, but start
from scratch to have more freedom in terms of optimization choices.

PyPy does not use reference counting, but a tracing garbage collector
which moves objects. Objects can be allocated on the stack, rather than
always having to be allocated on the heap.

Objects layouts are designed with performance in mind. For example, a
list strategy stores integers directly as integers, rather than objects.

Moreover, PyPy also has a JIT compiler which emits fast code thanks to
the efficient PyPy design.

PyPy bottleneck: the Python C API
---------------------------------

While PyPy is way more efficient than CPython to run pure Python code,
it is as efficient or slower than CPython to run C extensions.

Since the C API requires ``PyObject*`` and allows to access directly
structure members, PyPy has to associate a CPython object to PyPy
objects and maintain both consistent. Converting a PyPy object to a
CPython object is inefficient. Moreover, reference counting also has to
be implemented on top on PyPy tracing garbage collector.

These conversions are required because the Python C API is too close to
the CPython implementation: there is no high-level abstraction.
example, structures members are part of the public C API and nothing
prevents a C extension to get or set directly
``PyTupleObject.ob_item[0]`` (the first item of a tuple).

The C API blocks CPython evolutions
-----------------------------------

Adding or removing members of C structures is causing multiple
implementation issues.

Adding a new member breaks the stable ABI (PEP 384), especially for
types declared statically with::

    static PyTypeObject MyType = {...};

The ``PyTypeObject.tp_print`` member, deprecated since Python 3.0
released in 2009, has been removed in the Python 3.8 development cycle.
But the change broke many C extensions and it had to be reverted before
3.8 final release. The member was removed again in Python 3.9.


Rationale
=========

Hide implementation details
---------------------------

Hiding implementation details from the C API has multiple advantages:

* It becomes possible to experiment in CPython more advanced
  optimizations than just micro-optimizations.
* Adding new features in CPython becomes easier.
* PyPy should be able to avoid conversions to CPython objects in more
  cases: keep efficient PyPy objects.
* It becomes easier to implement the C API for a new Python
  implementation.
* More C extensions will be compatible with Python implementations other
  than CPython.

Relationship with the limited C API
-----------------------------------

The PEP 384 "Defining a Stable ABI" is in Python 3.4. It introduces the
"limited C API": a subset of the C API. When the limited C API is used,
it becomes possible to build a C extensions only once and uses it on
multiple Python versions: that's the stable ABI.

The main limitation of the PEP 384 is that C extensions have to opt-in
for the limited C API. Only very few projects made this choice,
usually to ease distribution of binaries, especially on Windows.

This PEP moves the C API towards the limited C API.

Ideally, the C API will become the limited C API and all C extensions
will use the stable ABI, but this is out of this PEP scope.


Specification
=============

Changes summary
---------------

* Reorganize the C API header files: create ``Include/cpython/`` and
  ``Include/internal/`` subdirectories.
* Make structures like ``PyObject`` or ``PyTypeObject`` opaque.
* Convert macros to static inline functions.
* Add new functions ``Py_SET_TYPE()``, ``Py_SET_REFCNT()`` and
  ``Py_SET_SIZE()``. The ``Py_TYPE()``, ``Py_REFCNT()`` and
  ``Py_SIZE()`` macros become functions which cannot be used as l-value.
* Deprecate ``PySequence_Fast_ITEMS()``.
* Convert ``PyTuple_GET_ITEM()`` and ``PyList_GET_ITEM()`` macros
  to static inline functions.
* Provide ``pythoncapi_compat.h`` header file.

Reorganize the C API header files
---------------------------------

The first consumer of the C API was Python itself. There is no clear
separation between APIs which must not be used outside Python, and API
which are public on purpose.

Header files must be reorganized in 3 API:

* ``Include/`` is the limited C API: no implementation details, structures are opaque. C
  extensions using it get a stable ABI.
* ``Include/cpython/`` is the CPython C API: less "portable" API,
  depends more on the Python version, expose some implementation
  details, few incompatible changes can happen.
* ``Internal/internal/`` is the internal C API: implementation details,
  incompatible changes are likely at each Python release.

``Include/cpython/`` header files must not be included directly. C
extensions continue to include ``Python.h``. This directory is excluded
if the ``Py_LIMITED_API`` macro is defined.

The internal C API is installed and can be used for specific usage like
debuggers and profilers which must access structures members without
executing code. C extensions using the internal C API are tightly
coupled to a Python version and must be recompiled at each Python
version.

Make structures opaque
----------------------

All structures of the C API should become opaque: C extensions must
use getter or setter functions to get or set structure members. For
example, ``tuple->ob_item[0]`` must be replaced with
``PyTuple_GET_ITEM(tuple, 0)``.

To be able to move away from reference counting, ``PyObject`` must
become opaque. Currently, the reference counter ``PyObject.ob_refcnt``
is exposed in the C API. All structures must become opaque, since they
"inherit" from PyObject. Example::

    typedef struct {
        PyObject ob_base;
        double ob_fval;
    } PyFloatObject;

Issues to prepare the C API to make structures opaque:

* ``PyGC_Head``: https://bugs.python.org/issue40241
  (done in Python 3.9)
* ``PyObject``: https://bugs.python.org/issue39573
* ``PyTypeObject``: https://bugs.python.org/issue40170
* ``PyThreadState``: https://bugs.python.org/issue39947
  (some getters and setters added to Python 3.9)
* ``PyInterpreterState``: https://bugs.python.org/issue35886
  (done in Python 3.8)

Convert macros to static inline functions
-----------------------------------------

Converting macros to static inline functions have multiple advantages:

* Functions have well defined parameter types and return type.
* Functions can use variables with a well defined scope (the function).
* Debugger can be put breakpoints on functions and profilers can display
  the function name in the call stacks. In most cases, it works even
  when a static inline function is inlined.
* Functions don't have `macros pitfalls
  <https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html>`_.

Converting macros to static inline functions should only impact very few
C extensions which use macros in unusual ways.

For backward compatibility, functions must continue to accept any type,
not only ``PyObject*``, to avoid compiler warnings, since most macros
cast their parameters to ``PyObject*``.

Python 3.6 requires C compilers to support static inline functions: the
PEP 7 requires a subset of C99.

Disallow using Py_TYPE() as l-value
-----------------------------------

The ``Py_TYPE()`` function gets an object type, its ``PyObject.ob_type``
member. It is implemented as a macro which can be used as an l-value to
set the type: ``Py_TYPE(obj) = new_type``. This code relies on the
assumption that ``PyObject.ob_type`` can be modified directly. It
prevents to make the ``PyObject`` structure opaque.

New setter functions ``Py_SET_TYPE()``, ``Py_SET_REFCNT()`` and
``Py_SET_SIZE()`` are added and must be used instead.

The ``Py_TYPE()``, ``Py_REFCNT()`` and ``Py_SIZE()`` macros must be
converted to static inline functions which can not be used as l-value.

For example, the ``Py_TYPE()`` macro::

    #define Py_TYPE(ob)             (((PyObject*)(ob))->ob_type)

becomes::

    #define _PyObject_CAST_CONST(op) ((const PyObject*)(op))

    static inline PyTypeObject* _Py_TYPE(const PyObject *ob) {
        return ob->ob_type;
    }

    #define Py_TYPE(ob) _Py_TYPE(_PyObject_CAST_CONST(ob))

Avoid borrowed references for new functions
-------------------------------------------

When a function returns a borrowed reference, Python cannot track when
the caller stops using this reference.

For example, if the Python ``list`` type is specialized for small
integers, store directly "raw" numbers rather than Python objects,
``PyList_GetItem()`` has to create a temporary Python object. The
problem is to decide when it is safe to delete the temporary object.

The general guidelines is to avoid returning borrowed references for new
C API functions.

No function returning borrowed functions is scheduled for removal by
this PEP.

Avoid functions returning PyObject**
------------------------------------

The ``PySequence_Fast_ITEMS()`` function gives a direct access to an
array of ``PyObject*`` objects. The function is deprecated in favor of
``PyTuple_GetItem()`` and ``PyList_GetItem()``.

``PyTuple_GET_ITEM()`` can be abused to access directly the
``PyTupleObject.ob_item`` member::

    PyObject **items = &PyTuple_GET_ITEM(0);

The ``PyTuple_GET_ITEM()`` and ``PyList_GET_ITEM()`` macros are
converted to static inline functions to disallow that.

New pythoncapi_compat.h header file
-----------------------------------

Making structures opaque require to add getter and setter functions. C
extensions must be modified to use these new functions. The practical
issue is how to handle backward compatibility.

In Python 3.10, it is no longer possible to use ``Py_TYPE()`` as an
l-value. The new ``Py_SET_TYPE()`` function must be used instead.
Example::

    #if PY_VERSION_HEX >= 0x030900A4
        Py_SET_TYPE(&MyType, &PyType_Type);
    #else
        Py_TYPE(&MyType) = &PyType_Type;
    #endif

This code may ring a bell to developers who ported their Python code
base from Python 2 to Python 3.

Python will distribute a new ``pythoncapi_compat.h`` header file which
provides new functions for old Python versions. Example::

    #if PY_VERSION_HEX < 0x030900A4
    static inline void
    _Py_SET_TYPE(PyObject *ob, PyTypeObject *type)
    {
        ob->ob_type = type;
    }
    #define Py_SET_TYPE(ob, type) _Py_SET_TYPE((PyObject*)(ob), type)
    #endif  // PY_VERSION_HEX < 0x030900A4

Using this header file, ``Py_SET_TYPE()`` can be used on old Python
versions as well.

Developers can decide to copy this file in their project, or even to
only copy/paste the few functions needed by the C extension.

Process to introduce incompatible changes in the C API
------------------------------------------------------

* Estimate how many popular C extensions are affected by this
  change.
* Coordinate with maintainers of broken C extensions to prepare their
  code for the future incompatible change.
* Introduce the incompatible changes in Python. The documentation must
  explain how to port existing code. It is recommended to merge such
  changes at the beginning of a development cycle to have more time to
  test.
* Changes which are the most likely to break a large number of C
  extensions should be announced on the capi-sig mailing list to notify
  C extensions maintainers to prepare their project for the next Python.
* If the change breaks too many projects, reverting the change should be
  discussed, taking in account the number of broken packages, their
  importance in the Python commmunity, and the importance of the change.

Future incompatible changes can be announced by deprecating a function
in the documentation and by annotating the function with
``Py_DEPRECATED()``. Making a structure opaque and preventing the usage
of a macro as l-value cannot be deprecated with ``Py_DEPRECATED()``.

The important part is coordination and balance the tradeoff between
CPython evolutions and backward compatibility.

If a change is reverted, we move back to the coordination step to better
prepare the change. Once more C extensions are ready, the incompatible
change can be reconsidered.

Test popular C extensions on the next Python version
----------------------------------------------------

Projects are adviced to be tested by a continuous integration on the
next version of Python: the "master" branch of Python, sometimes known
as the "nightly" version.

The more feedback we get, smoother will be the the migration to the new
C API with incompatible changes.


Reference Implementation
========================

The reorganization of header files is done: it started in Python 3.7 and
was completed in Python 3.8.

The ``PyInterpreterState`` was made opaque in Python 3.8 and the
``PyGC_Head`` was made opaque in Python 3.9.

Many macros have been converted to static inline functions in Python
3.8.

New functions ``Py_SET_TYPE()``, ``Py_SET_REFCNT()`` and
``Py_SET_SIZE()`` were added to Python 3.9. In Python 3.10,
``Py_TYPE()``, ``Py_REFCNT()`` and ``Py_SIZE()`` can no longer be used
as l-value in Python 3.10 and the new setter functions must be used
instead.

The implementation of this PEP is expected to be done slowly on multiple
Python versions. Its completion depends on popular C extensions and the
`Process to introduce incompatible changes in the C API`_.

The ``pythoncapi_compat.h`` header file is currently developer at:
https://github.com/pythoncapi/pythoncapi_compat


Copyright
=========

This document has been placed in the public domain.
