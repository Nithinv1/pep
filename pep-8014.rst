PEP: 8014
Title: The Commons Governance Model
Author: Jack Jansen
Status: Active
Type: Informational
Content-Type: text/x-rst
Created: 2018-09-16


.. note:: This is just a placeholder until the actual governance PEPs are
          written.  It is possible that the title, content, model proposed,
          and authorship will change once the PEP is actually written.


Abstract
========

This PEP proposes a governnance model with as few procedures, defined terms and
percentages as possible. It may also be called *The Anarchist Governance Model*
but uses *Commons* for now because of possible negative connotations of the
term *Anarchist* to some audiences.

The rationale for the model is that everything that is cast in concrete will
have unintended negative side effects. For example, a governance model that
assigns voting rights to, say, Python committers may cause individuals not
to be accepted as a committer because there are already a lot of committers
from the company the new candidate works for. As another example, setting
a fixed percentage for PEP acceptance may lead to party-formation amongst
the voters and individual PEPs no longer be being judged on individual merit
but along party lines (if you support my PEP I will support yours). 

Introduction
============

The Commons Governance Model tries to ensure that all decisions are endorsed by,
or at least acceptable to, a sufficient majority of the Python community.

Unfortunately the previous paragraph has two terms that are very hard to
quantify in the general case: *sufficient majority* and *Python community*.
This is because both terms in reality depend on the *specific* case that is
being decided. To give an example of this difficulty: for a PEP that proposes
a backward-compatible change to some API a simple majority of the core
developers that were interested in voting on the PEP in the first place is
probably sufficient. But for a change that has more farreaching consequences
such as a Python3 to Python4 transition a real majority may be wanted, and
a demonstration that at least there seems to be sufficient support in the user
base. And for a change that transcends the Python-the-language, such as decisions
on abolishing non-inclusive language, it becomes very vague.

The Commons Governance Model attempts to sidestep this issue by *not* defining
what the terms *sufficient majority* and *Python community* mean in the
general case, by proposing a body that will decide so in *specific* cases.

The model proposes creating a *Council of Elders* that oversees the decision
process, determining whether a specific proposal has enough support on a
case by case basis. There will be a vote on every individual PEP (or PEP-like
decision), and the Council of Elders will declare whether the outcome of
the vote is sufficient to carry the decision.

The Commons Governance Model shares some principles with some of the other
proposed models, and I can imagine it being merged with those.

Decision Process
================

All decisions go through a PEP process (if it turns out that this pollutes
the PEP namespace too much we create another namespace, Python Decision
Proposal, with a very similar structure). Each PEP has someone responsible
for it, called the author here, but that does not have to be a single
person, and it does not have to be the person that actually wrote the text.
So for author you could also read "champion" or "shepard" or something like
that.

The PEP author is responsible for organizing a vote on the PEP. This vote is 
public, i.e. the voters are identified and the results are known to all. Voting
may be simple +1/0/-1, but might also be extended with +2/-2 with a very terse
explanation why the voter feels very strong about the issue. Voters are annotated 
with their community status (core developer, etc). 

The vote is clearly separated from the discussion,  either by using a
special mailing list or special subject, or a different technical method
(such as a website vote.python.org where people have to log in so their
community status can be automatically added, and their identity can be somewhat
confirmed).

The PEP author presents the PEP and the vote results to the Council of Elders. 
The council ponders the PEP content and its implications and the vote results.
They pronounce a tentative decision and this decision is published.

If the decision is that the vote results do not demonstrate enough support for
the decision from the community the burden is on the author to try and gather
more support and resubmit the vote at a later date. Alternatively the author
can retract the proposal.

If the tentative decision is that the results *do* demonstrate enough support
a fairly short waiting period starts (in the order of weeks). During this
period anyone can appeal to the Council of Elders, but *only* on the grounds
that the vote does not reflect a sufficient majority of the community.
After the waiting period the council pronounces a final decision. The PEP
is either accepted or, if the council is swayed by an appeal, goes back to
the state where more support has to be demonstrated.


Council of Elders
=================

The intention of the Councel of Elders is that they, together, are capable
of judging whether the will of the Python community is upheld in a specific
vote. The Council of Elders is *not* a replacement of the BDFL by a group
of people with the same power as the BDFL (although it may well be that in the
past Guido as BDFL followed a somewhat similar decision process, at least in
some cases). The Council of Elders is *not* like the US Supreme Court, which
has actual decision power, it only oversees the voting process to ensure that
the community is represented in the vote. And the Council of Elders is most
definitely not like the Spanish Inquisition, because fear, surprise and ruthless
efficiency are things we can do without. The council is somewhat like the
dutch "Hoge Raad" (which is unfortunately often translated as Supreme Court in 
English) in that they judge the process and the procedures followed and can
only send cases back for a renewed judgement.

Composition
-----------

The council should not be too big nor too small, probably somewhere between 5
and 10 members. The members should be knowledgeable about Python and the Python
community, and willing to be impartial _while operating as part of the council_.

Everyone in the community should feel represented by the council so it would be
good if the council is diverse: scientists and technologists, members with
different cultural backgrounds, different genders, etc. But this should hold
for the council as a whole, individual council members should not be seen as
representing a specific interest group.

Council membership
------------------

Because the powers of the council are purely procedural it is probably good
if members serve for a fairly long time, and there are no things like yearly
re-elections with fixed terms and all that. 


Why no new BDFL?
================

(this section may go)

- explain about old model appearing to be 2-step process (PEP writing, BDFL
verdict) but was really a 3-step process (PEP writing, enough discussion,
BDFL verdict)
- worked because of Guido's personality:
	- language elegance vs. usability
	- language progress vs. stability
	- open eye for community and members
- all those skills are available in the community, but asking for it in one
person is a bit much. And the load is too big.
	
	

Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
