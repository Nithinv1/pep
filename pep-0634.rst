PEP: 634
Title: Structural Pattern Matching: Specification
Version: $Revision$
Last-Modified: $Date$
Author: Brandt Bucher <brandtbucher@gmail.com>,
        Guido van Rossum <guido@python.org>
BDFL-Delegate:
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 12-Sep-2020
Python-Version: 3.10
Post-History:
Replaces: 622
Resolution:


Abstract
========

This PEP provides the technical specification for the ``match``
statement.  It replaces PEP 622, which is hereby split in three parts:

- PEP 634: Specification
- PEP 635: Motivation and Rationale
- PEP 636: Tutorial

This PEP is intentionally devoid of commentary; all explanations of
design choices are in PEP 635.  First-time readers are encouraged to
start with PEP 636, which provides a gentler introduction to the
concepts, syntax and semantics of patterns.


Syntax and Semantics
====================

See `Appendix A`_ for the complete grammar.

Overview and terminology
------------------------

The pattern matching process takes as input a pattern (following
``case``) and a subject value (following ``match``).  Phrases to
describe the process include "the pattern is matched with (or against)
the subject value" and "we match the pattern against (or with) the
subject value".

The primary outcome of pattern matching is success or failure.  In
case of success we may say "the pattern succeeds", "the match
succeeds", or "the pattern matches the subject value".

In many cases a pattern contains subpatterns, and success or failure
is determined by the success or failure of matching those subpatterns
against the value (e.g., for OR patterns) or against parts of the
value (e.g., for sequence patterns).  This process typically processes
the subpatterns from left to right until the overall outcome is
determined.  E.g., an OR pattern succeeds at the first succeeding
subpattern, while a sequence patterns fails at the first failing
subpattern.

A secondary outcome of pattern matching may be one or more name
bindings.  We may say "the pattern binds a value to a name".  When
subpatterns tried until the first success, only the bindings due to
the successful subpattern are valid; when trying until the first
failure, the bindings are merged.  Several more rules, explained
below, apply to these cases.


The ``match`` statement
-----------------------

A ``match`` statement has the following top-level syntax::

  match_stmt: "match" match_expr ':' NEWLINE INDENT case_block+ DEDENT
  match_expr:
      | star_named_expression ',' star_named_expressions?
      | named_expression
  case_block: "case" patterns [guard] ':' block
  guard: 'if' named_expression

The rules ``star_named_expression``, ``star_named_expressions``,
``named_expression`` and ``block`` are part of the `standard Python
grammar <https://docs.python.org/3.10/reference/grammar.html>`_.

The rule ``patterns`` is specified below.

For context, ``match_stmt`` is a new alternative for
``compound_statement``::

  compound_statement:
      | if_stmt
      ...
      | match_stmt


The ``match`` and ``case`` keywords are soft keywords, i.e. they are
not reserved words in other grammatical contexts (including at the
start of a line if there is no colon where expected).  This implies
that they are recognized as keywords when part of a ``match``
statement or ``case`` block only, and are allowed to be used in all
other context as variable or argument names.


Match semantics
^^^^^^^^^^^^^^^

TODO: Make the language about choosing a block more precise.

The overall semantics for choosing the match is to choose the first
matching pattern (including guard) and execute the corresponding
block.  The remaining patterns are not tried.  If there are no
matching patterns, execution continues at the following statement.

Name bindings made during a successful pattern match outlive the
executed block and can be used after the ``match`` statement.

During failed pattern matches, some subpatterns may succeed. For
example, while matching the pattern ``(0, x, 1)`` with the value ``[0,
1, 2]``, the subpattern ``x`` may succeed if the list elements are
matched from left to right.  The implementation may choose to either
make persistent bindings for those partial matches or not. User code
including a ``match`` statement should not rely on the bindings being
made for a failed match, but also shouldn't assume that variables are
unchanged by a failed match.  This part of the behavior is left
intentionally unspecified so different implementations can add
optimizations, and to prevent introducing semantic restrictions that
could limit the extensibility of this feature.

The precise pattern binding rules vary per pattern type and are
specified below.


.. _patterns:

Patterns
--------

TODO: I dislike that "or_pattern" can refer to both something that
*definitely* has a ``|`` in it (in the specification of OR patterns)
and to something that merely has *operator precedence* allowing ``|``
in it (in the specification of walrus patterns).  But to fix this we'd
need to come up with a new name for the latter.

The top-level syntax for patterns is as follows::

  patterns: open_sequence_pattern | pattern
  pattern: walrus_pattern | or_pattern
  walrus_pattern: NAME ':=' or_pattern
  or_pattern: '|'.closed_pattern+
  closed_pattern:
      | literal_pattern
      | capture_pattern
      | wildcard_pattern
      | constant_pattern
      | group_pattern
      | sequence_pattern
      | mapping_pattern
      | class_pattern


.. _literal_pattern:

Literal Patterns
^^^^^^^^^^^^^^^^

Syntax::

  literal_pattern:
      | signed_number
      | signed_number '+' NUMBER
      | signed_number '-' NUMBER
      | strings
      | 'None'
      | 'True'
      | 'False'
  signed_number: NUMBER | '-' NUMBER

The rule ``strings`` and the token ``NUMBER`` are defined in the
standard Python grammar.

Triple-quoted strings are supported.  Raw strings and byte strings
are supported.  F-strings are not supported.

The forms ``signed_number '+' NUMBER`` and ``signed_number '-'
NUMBER`` are only permitted to express complex numbers; they require a
real number on the left and an imaginary number on the right.

A literal pattern succeeds if the subject value compares equal to the
value expressed by the literal, using the following comparisons rules:

- Numbers and strings are compared using the ``==`` operator.

- The singleton literals ``None``, ``True`` and ``False`` are compared
  using the ``is`` operator.


.. _capture_pattern:

Capture Patterns
^^^^^^^^^^^^^^^^

Syntax::

  capture_pattern: !"_" NAME

The single underscore (``_``) is not a capture pattern (this is what
``!"_"`` expresses).  It is treated as a `wildcard pattern`_.

A capture pattern always succeeds.  It binds the subject value to the
name using the scoping rules for name binding established for the
walrus operator in PEP 572.  (Summary: the name becomes a local
variable in the nearest function scope unless there's an applicable
``nonlocal`` or ``global`` statement.)

In a given pattern, a given name may be bound only once.  This
disallows for example ``case x, x: ...`` but allows ``case [x] | x:
...``.

.. _wildcard_pattern:

Wildcard Pattern
^^^^^^^^^^^^^^^^

Syntax::

    wildcard_pattern: "_"

A wildcard pattern always succeeds.  It binds no name.

.. _constant_value_pattern:

Constant Value Patterns
^^^^^^^^^^^^^^^^^^^^^^^

TODO: Rename to Value Patterns?  (But ``value[s]_pattern`` is already
a grammatical rule.)

Syntax::

  constant_pattern: attr
  attr: name_or_attr '.' NAME
  name_or_attr: attr | NAME

The dotted name in the pattern is looked up using the standard Python
name resolution rules.  However, when the same constant pattern occurs
multiple times in the same ``match`` statement, the interpreter may cache
the first value found and reuse it, rather than repeat the same
lookup.  (To clarify, this cache is strictly tied to a given execution
of a given ``match`` statement.)

The pattern succeeds if the value found thus compares equal to the
subject value (using the ``==`` operator).


Group Patterns
^^^^^^^^^^^^^^

Syntax:

  group_pattern: '(' pattern ')'

(For the syntax of ``pattern``, see Patterns above.  Note that it
contains no comma -- a parenthesized series of items with at least one
comma is a sequence pattern, as is ``()``.)

A parenthesized pattern has no additional syntax.  It allows users to
add parentheses around patterns to emphasize the intended grouping.


.. _sequence_pattern:

Sequence Patterns
^^^^^^^^^^^^^^^^^

Syntax::

  sequence_pattern:
    | '[' [values_pattern] ']'
    | '(' [open_sequence_pattern] ')'
  open_sequence_pattern: value_pattern ',' [values_pattern]
  values_pattern: ','.value_pattern+ ','?
  value_pattern: star_pattern | pattern
  star_pattern: '*' (capture_pattern | wildcard_pattern)

(Note that a single parenthesized pattern without a trailing comma is
a group pattern, not a sequence pattern.  However a single pattern
enclosed in ``[...]`` is still a sequence pattern.)

There is no semantic difference between a sequence pattern using
``[...]``, a sequence pattern using ``(...)``, and an open sequence
pattern.

A sequence pattern may contain at most one star subpattern.  The star
subpattern may occur in any position.  If no star subpattern is
present, the sequence pattern is a fixed-length sequence pattern;
otherwise it is a variable-length sequence pattern.

A sequence pattern fails if the subject value is not an instance of
``collections.abc.Sequence``.  It also fails if the subject value is
an instance of ``str``, ``bytes`` or ``bytearray``.

A fixed-length sequence pattern fails if the length of the subject
sequence is not equal to the number of subpatterns.

A variable-length sequence pattern fails if the length of the subject
sequence is less than the number of non-star subpatterns.

The length of the subject sequence is obtained using the builtin
``len()`` function (i.e., via the ``__len__`` protocol).  However, the
interpreter may cache this value in a similar manner as described for
constant value patterns.

A fixed-length sequence pattern matches the subpatterns to
corresponding items of the subject sequence, from left to right.
Matching stops (with a failure) as soon as a subpattern fails.  If all
subpatterns succeed in matching their corresponding item, the sequence
pattern succeeds.

A variable-length sequence pattern first matches the leading non-star
subpatterns to the curresponding items of the subject sequence, as for
a fixed-length sequence.  If this succeeds, the star subpattern
matches a list formed of the remaining subject items, with items
removed from the end corresponding to the non-star subpatterns
following the star subpattern.  The remaining non-star subpatterns are
then matched to the corresponding subject items, as for a fixed-length
sequence.


.. _mapping_pattern:

Mapping Patterns
^^^^^^^^^^^^^^^^

Syntax::

  mapping_pattern: '{' [items_pattern] '}'
  items_pattern: ','.key_value_pattern+ ','?
  key_value_pattern:
      | (literal_pattern | constant_pattern) ':' or_pattern
      | double_star_pattern
  double_star_pattern: '**' capture_pattern

(Note that ``**_`` is disallowed by this syntax.)

A mapping pattern may contain at most one double star pattern,
and it must be last.

A mapping pattern fails if the subject value is not an instance of
``collections.abc.Mapping``.

A mapping pattern succeeds if every key given in the mapping pattern
matches the corresponding item of the subject mapping.  If a ``'**'
NAME`` form is present, that name is bound to a ``dict`` containing
remaining key-value pairs from the subject mapping.

If duplicate keys are detected in the mapping pattern, the pattern is
considered invalid, and a ``ValueError`` is raised.

Key-value pairs are matched using the two-argument form of the
subject's ``get()`` method.  As a consequence, matched key-value pairs
must already be present in the mapping, and not created on-the-fly by
``__missing__`` or ``__getitem__``.  For example,
``collections.defaultdict`` instances will only be matched by patterns
with keys that were already present when the ``match`` block was
entered.


.. _class_pattern:

Class Patterns
^^^^^^^^^^^^^^

TODO: Modernize this section.

Syntax::

  class_pattern:
      | name_or_attr '(' ')'
      | name_or_attr '(' ','.pattern+ ','? ')'
      | name_or_attr '(' ','.keyword_pattern+ ','? ')'
      | name_or_attr '(' ','.pattern+ ',' ','.keyword_pattern+ ','? ')'
  keyword_pattern: NAME '=' or_pattern

A class pattern provides support for destructuring arbitrary objects.
There are two possible ways of matching on object attributes: by position
like ``Point(1, 2)``, and by name like ``Point(x=1, y=2)``. These
two can be combined, but a positional match cannot follow a match by name.
Each item in a class pattern can be an arbitrary pattern. A simple
example::

  match shape:
      case Point(x, y):
          ...
      case Rectangle(x0, y0, x1, y1, painted=True):
          ...

Whether a match succeeds or not is determined by the equivalent of an
``isinstance`` call.  If the subject (``shape``, in the example) is not
an instance of the named class (``Point`` or ``Rectangle``), the match
fails.  Otherwise, it continues (see details in the `runtime`_
section).

The named class must inherit from ``type``.  It may be a single name
or a dotted name (e.g., ``some_mod.SomeClass`` or ``mod.pkg.Class``).
Use ``object(foo=_)`` to check whether the
matched object has an attribute ``foo``.

By default, subpatterns may only match by keyword for
user-defined classes. In order to support positional subpatterns, a
custom ``__match_args__`` attribute is required.
The runtime allows matching
arbitrarily nested patterns by chaining all of the instance checks and
attribute lookups appropriately.


OR patterns
^^^^^^^^^^^

TODO: Modernize this section.  Also, move it earlier (so that the
order in which pattern types are introduced in the top-level grammar
matches the order of the sections?)

Multiple alternative patterns can be combined into one using ``|``. This means
the whole pattern matches if at least one alternative matches.
Alternatives are tried from left to right and have a short-circuit property,
subsequent patterns are not tried if one matched. Examples::

  match something:
      case 0 | 1 | 2:
          print("Small number")
      case [] | [_]:
          print("A short sequence")
      case str() | bytes():
          print("Something string-like")
      case _:
          print("Something else")

The alternatives may bind variables, as long as each alternative binds
the same set of variables (excluding ``_``).  For example::

  match something:
      case 1 | x:  # Error!
          ...
      case x | 1:  # Error!
          ...
      case one := [1] | two := [2]:  # Error!
          ...
      case Foo(arg=x) | Bar(arg=x):  # Valid, both arms bind 'x'
          ...
      case [x] | x:  # Valid, both arms bind 'x'
          ...


Walrus patterns
^^^^^^^^^^^^^^^

TODO: Modernize this section.  Also, move it earlier (same as OR
patterns TODO).  Also, consider changing the syntax from ``v := P`` to
``P as v`` and renaming (e.g. to AS pattern?).

It is often useful for a pattern to match *and* bind the corresponding
value to a name. For example, it can be useful to write more efficient
matches, or simply to avoid repetition. To simplify such cases, any pattern
(other than the walrus pattern itself) can be preceded by a name and
the walrus operator (``:=``). For example::

  match get_shape():
      case Line(start := Point(x, y), end) if start == end:
          print(f"Zero length line at {x}, {y}")

The name on the left of the walrus operator can be used in a guard, in
the case block, or after the ``match`` statement.  However, the name will
*only* be bound if the subpattern succeeds.  Another example::

  match group_shapes():
      case [], [point := Point(x, y), *other]:
          print(f"Got {point} in the second group")
          process_coordinates(x, y)
          ...

Technically, most such examples can be rewritten using guards and/or nested
``match`` statements, but this will be less readable and/or will produce less
efficient code. Essentially, most of the arguments in PEP 572 apply here
equally.

The wildcard ``_`` is not a valid name here.


.. _guards:

Guards
------

TODO: Modernize this section.

Each *top-level* pattern can be followed by a **guard** of the form
``if expression``. A case clause succeeds if the pattern matches and the guard
evaluates to a true value. For example::

  match input:
      case [x, y] if x > MAX_INT and y > MAX_INT:
          print("Got a pair of large numbers")
      case x if x > MAX_INT:
          print("Got a large number")
      case [x, y] if x == y:
          print("Got equal items")
      case _:
          print("Not an outstanding input")

If evaluating a guard raises an exception, it is propagated onwards rather
than fail the case clause. Names that appear in a pattern are bound before the
guard succeeds. So this will work::

  values = [0]

  match values:
      case [x] if x:
          ...  # This is not executed
      case _:
          ...
  print(x)  # This will print "0"

Note that guards are not allowed for nested patterns, so that ``[x if x > 0]``
is a ``SyntaxError`` and ``1 | 2 if 3 | 4`` will be parsed as
``(1 | 2) if (3 | 4)``.


.. _runtime:

Runtime specification
=====================

TODO: Modernize this section.

The Match Protocol
------------------

The equivalent of an ``isinstance`` call is used to decide whether an
a given class pattern matches a subject and to extract the corresponding
attributes.  Classes requiring different matching semantics (such as
duck-typing) can do so by defining ``__instancecheck__`` (a
pre-existing metaclass hook) or by using ``typing.Protocol``.

The procedure is as following:

* The class object for ``Class`` in ``Class(<subpatterns>)`` is
  looked up and ``isinstance(obj, Class)`` is called, where ``obj`` is
  the subject value.  If false, the match fails.

* Otherwise, if any subpatterns are given in the form of positional
  or keyword arguments, these are matched from left to right, as
  follows.  The match fails as soon as a subpattern fails; if all
  subpatterns succeed, the overall class pattern match succeeds.

* If there are match-by-position items and the class has a
  ``__match_args__`` attribute, the item at position ``i``
  is matched against the value looked up by attribute
  ``__match_args__[i]``. For example, a pattern ``Point2d(5, 8)``,
  where ``Point2d.__match_args__ == ["x", "y"]``, is translated
  (approximately) into ``obj.x == 5 and obj.y == 8``.

* If there are more positional items than the length of
  ``__match_args__``, a ``TypeError`` is raised.

* If the ``__match_args__`` attribute is absent on the matched class,
  and one or more positional item appears in a match,
  ``TypeError`` is also raised. We don't fall back on
  using ``__slots__`` or ``__annotations__`` -- "In the face of ambiguity,
  refuse the temptation to guess."

* If there are any match-by-keyword items the keywords are looked up
  as attributes on the subject.  If the lookup succeeds, the value is
  matched against the corresponding subpattern.  If the lookup fails,
  the match fails.

Such a protocol favors simplicity of implementation over flexibility and
performance. For other considered alternatives, see "extended matching".

For the most commonly-matched built-in types (``bool``,
``bytearray``, ``bytes``, ``dict``, ``float``,
``frozenset``, ``int``, ``list``, ``set``, ``str``, and ``tuple``), a
single positional subpattern is allowed to be passed to
the call. Rather than matching any particular attribute
on the subject, it instead matches the subject itself.  This
creates behavior that is useful and intuitive for these objects:

* ``int(0)`` matches ``0`` (but not ``0.0``).
* ``tuple((0, 1, 2))`` matches ``(0, 1, 2)`` (but not ``[0, 1, 2]``).
* ``bool(b)`` matches any ``bool`` and binds it to the name ``b``.


Overlapping subpatterns
-----------------------

Certain classes of overlapping matches are detected at
runtime and will raise exceptions. In addition to basic checks
described in the previous subsection:

* The interpreter will check that two subpatterns are not targeting the same
  attribute, for example ``Point2d(1, 2, y=3)`` is an error.

* It will also check that a mapping pattern does not attempt to match
  the same key more than once.


Special attribute ``__match_args__``
------------------------------------

The ``__match_args__`` attribute is always looked up on the type
object named in the pattern.  If present, it must be a list or tuple
of strings naming the allowed positional arguments.

In deciding what names should be available for matching, the
recommended practice is that class patterns should be the mirror of
construction; that is, the set of available names and their types
should resemble the arguments to ``__init__()``.

Only match-by-name will work by default, and classes should define
``__match_args__`` as a class attribute if they would like to support
match-by-position.  Additionally, dataclasses and named tuples will
support match-by-position out of the box. See below for more details.

Exceptions and side effects
---------------------------

While matching each case, the ``match`` statement may trigger execution of other
functions (for example ``__getitem__()``, ``__len__()`` or
a property). Almost every exception caused by those propagates outside of the
``match`` statement normally. The only case where an exception is not propagated is
an ``AttributeError`` raised while trying to lookup an attribute while matching
attributes of a Class Pattern; that case results in just a matching failure,
and the rest of the statement proceeds normally.

The only side-effect carried on explicitly by the matching process is the binding of
names. However, the process relies on attribute access,
instance checks, ``len()``, equality and item access on the subject and some of
its components. It also evaluates constant value patterns and the left side of
class patterns. While none of those typically create any side-effects, some of
these objects could. This proposal intentionally leaves out any specification
of what methods are called or how many times. User code relying on that
behavior should be considered buggy.

The standard library
--------------------

TODO: Make this a top-level section?

To facilitate the use of pattern matching, several changes will be made to
the standard library:

* Namedtuples and dataclasses will have auto-generated ``__match_args__``.

* For dataclasses the order of attributes in the generated ``__match_args__``
  will be the same as the order of corresponding arguments in the generated
  ``__init__()`` method. This includes the situations where attributes are
  inherited from a superclass.

In addition, a systematic effort will be put into going through
existing standard library classes and adding ``__match_args__`` where
it looks beneficial.


.. _Appendix A:

Appendix A -- Full Grammar
==========================

TODO: Double-check that the syntax sections above match what's written
here (except for trailing lookaheads).

TODO: Go over the differences with the reference implementation and
resolve them (either by fixing the PEP or by fixing the reference
implementation).

Here is the full grammar for ``match_stmt``.  This is an additional
alternative for ``compound_stmt``.  Remember that ``match`` and
``case`` are soft keywords, i.e. they are not reserved words in other
grammatical contexts (including at the start of a line if there is no
colon where expected).  By convention, hard keywords use single quotes
while soft keywords use double quotes.

Other notation used beyond standard EBNF:

- ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``
- ``!RULE`` is a negative lookahead assertion

::

  match_stmt: "match" match_expr ':' NEWLINE INDENT case_block+ DEDENT
  match_expr:
      | star_named_expression ',' [star_named_expressions]
      | named_expression
  case_block: "case" patterns [guard] ':' block
  guard: 'if' named_expression

  patterns: open_sequence_pattern | pattern
  pattern: walrus_pattern | or_pattern
  walrus_pattern: NAME ':=' or_pattern
  or_pattern: '|'.closed_pattern+
  closed_pattern:
      | literal_pattern
      | capture_pattern
      | wildcard_pattern
      | constant_pattern
      | group_pattern
      | sequence_pattern
      | mapping_pattern
      | class_pattern

  literal_pattern:
      | signed_number !('+' | '-')
      | signed_number '+' NUMBER
      | signed_number '-' NUMBER
      | strings
      | 'None'
      | 'True'
      | 'False'
  signed_number: NUMBER | '-' NUMBER

  capture_pattern: !"_" NAME !('.' | '(' | '=')

  wildcard_pattern: "_"

  constant_pattern: attr !('.' | '(' | '=')
  attr: name_or_attr '.' NAME
  name_or_attr: attr | NAME

  group_pattern: '(' pattern ')'

  sequence_pattern:
    | '[' [values_pattern] ']'
    | '(' [open_sequence_pattern] ')'
  open_sequence_pattern: value_pattern ',' [values_pattern]
  values_pattern: ','.value_pattern+ ','?
  value_pattern: star_pattern | pattern
  star_pattern: '*' (capture_pattern | wildcard_pattern)

  mapping_pattern: '{' [items_pattern] '}'
  items_pattern: ','.key_value_pattern+ ','?
  key_value_pattern:
      | (literal_pattern | constant_pattern) ':' or_pattern
      | double_star_pattern
  double_star_pattern: '**' capture_pattern

  class_pattern:
      | name_or_attr '(' ')'
      | name_or_attr '(' ','.pattern+ ','? ')'
      | name_or_attr '(' ','.keyword_pattern+ ','? ')'
      | name_or_attr '(' ','.pattern+ ',' ','.keyword_pattern+ ','? ')'
  keyword_pattern: NAME '=' or_pattern


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
