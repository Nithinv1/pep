PEP: 634
Title: Structural Pattern Matching: Specification
Version: $Revision$
Last-Modified: $Date$
Author: Brandt Bucher <brandtbucher@gmail.com>,
        Guido van Rossum <guido@python.org>
BDFL-Delegate:
Discussions-To: Python-Dev <python-dev@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 12-Sep-2020
Python-Version: 3.10
Post-History:
Replaces: 622
Resolution:


Abstract
========

TODO: Do we use "the subject matches the pattern" or "the pattern
matches the subject"?

This PEP provides the technical specification for the ``match``
statement.  It replaces PEP 622, which is hereby split in three parts:

- PEP 634: Specification
- PEP 635: Motivation and Rationale
- PEP 636: Tutorial

This PEP is intentionally devoid of commentary; all explanations of
design choices are in PEP 635.  First-time readers are encouraged to
start with PEP 636, which provides a gentler introduction to the
concepts, syntax and semantics of patterns.


Syntax and Semantics
====================

TODO: Should we show the lookaheads in the grammar?  They are a bit
ugly.  Maybe as a compromise show them in the appendix but not in the
main text?

See `Appendix A`_ for the complete grammar.


The ``match`` statement
-----------------------

A ``match`` statement has the following top-level grammar::

  match_stmt: "match" match_expr ':' NEWLINE INDENT case_block+ DEDENT
  match_expr:
      | star_named_expression ',' star_named_expressions?
      | named_expression
  case_block: "case" patterns [guard] ':' block
  guard: 'if' named_expression

The rules ``star_named_expression``, ``star_named_expressions``,
``named_expression`` and ``block`` are part of the `standard Python
grammar <https://docs.python.org/3.10/reference/grammar.html>`_.

The rule ``patterns`` is specified below.

For context, ``match_stmt`` is a new alternative for
``compound_statement``::

  compound_statement:
      | if_stmt
      ...
      | match_stmt


The ``match`` and ``case`` keywords are soft keywords, i.e. they are
not reserved words in other grammatical contexts (including at the
start of a line if there is no colon where expected).  This implies
that they are recognized as keywords when part of a ``match``
statement or ``case`` block only, and are allowed to be used in all
other context as variable or argument names.


Match semantics
~~~~~~~~~~~~~~~

TODO: Make the language about choosing a block more precise.

The overall semantics for choosing the match is to choose the first
matching pattern (including guard) and execute the corresponding
block.  The remaining patterns are not tried.  If there are no
matching patterns, execution continues at the following statement.

Name bindings made during a successful pattern match outlive the
executed block and can be used after the ``match`` statement.

During failed pattern matches, some sub-patterns may succeed. For
example, while matching the value ``[0, 1, 2]`` with the pattern ``(0,
x, 1)``, the sub-pattern ``x`` may succeed if the list elements are
matched from left to right.  The implementation may choose to either
make persistent bindings for those partial matches or not. User code
including a ``match`` statement should not rely on the bindings being
made for a failed match, but also shouldn't assume that variables are
unchanged by a failed match.  This part of the behavior is left
intentionally unspecified so different implementations can add
optimizations, and to prevent introducing semantic restrictions that
could limit the extensibility of this feature.

The precise pattern binding rules vary per pattern type and are
specified below.


.. _patterns:

Patterns
--------

TODO: rewrite the ``patterns`` rule to be easier to follow -- why
isn't it just ``','.value_pattern+ [',']``?  Also, ``value_pattern``
is a confusing name, since it is unrelated to "constant value
pattern".

The top-grammar for patterns is as follows::

  patterns: value_pattern ',' [values_pattern] | pattern
  pattern: walrus_pattern | or_pattern
  walrus_pattern: NAME ':=' or_pattern
  or_pattern: '|'.closed_pattern+
  closed_pattern:
      | literal_pattern
      | capture_pattern
      | wildcard_pattern
      | constant_pattern
      | group_pattern
      | sequence_pattern
      | mapping_pattern
      | class_pattern
  values_pattern: ','.value_pattern+ ','?
  value_pattern: '*' NAME | pattern


.. _literal_pattern:

Literal Patterns
~~~~~~~~~~~~~~~~

Syntax::

  literal_pattern:
      | signed_number !('+' | '-')
      | signed_number '+' NUMBER
      | signed_number '-' NUMBER
      | strings
      | 'None'
      | 'True'
      | 'False'
  signed_number: NUMBER | '-' NUMBER

The rule ``strings`` and the token ``NUMBER`` are defined in the
standard Python grammar.

Triple-quoted strings are supported.  Raw strings and byte strings
are supported.  F-strings are not supported.

The forms ``signed_number '+' NUMBER`` and ``signed_number '-'
NUMBER`` are only permitted to express complex numbers; they require a
real number on the left and an imaginary number on the right.

A literal pattern succeeds if the subject value compares equal to the
value expressed by the literal, using the following comparisons rules:

- Numbers and strings are compared using the ``==`` operator.

- The singleton literals ``None``, ``True`` and ``False`` are compared
  using the ``is`` operator.


.. _capture_pattern:

Capture Patterns
~~~~~~~~~~~~~~~~

Syntax::

  capture_pattern: !"_" NAME !('.' | '(' | '=')

The single underscore (``_``) is not a capture pattern.  It is
treated as a `wildcard pattern`_.

A capture pattern always succeeds.  It binds the subject value to the
name using the scoping rules for name binding established for the
walrus operator in PEP 572.  (Summary: the name becomes a local
variable in the nearest function scope unless there's an applicable
``nonlocal`` or ``global`` statement.)

In a given pattern, a given name may be bound only once.  This
disallows e.g. ``case x, x: ...`` but allows ``case x | x: ...``.

.. _wildcard_pattern:

Wildcard Pattern
~~~~~~~~~~~~~~~~

Syntax::

    wildcard_pattern: "_"

A wildcard pattern always succeeds.  It binds no name.

.. _constant_value_pattern:

Constant Value Patterns
~~~~~~~~~~~~~~~~~~~~~~~

TODO: Rename to Value Patterns?  (But ``value_pattern[s]`` is already
a grammatical rule.)

Syntax::

  constant_pattern: attr !('.' | '(' | '=')
  attr: name_or_attr '.' NAME
  name_or_attr: attr | NAME

The dotted name in the pattern is looked up using the standard Python
name resolution rules.  However, when the same constant pattern occurs
multiple times in the same ``match`` statement, the interpreter may cache
the first value found and reuse it, rather than repeat the same
lookup.  (To clarify, this cache is strictly tied to a given execution
of a given ``match`` statement.)

The pattern succeeds if the value found thus compares equal to the
subject value (using the `==` operator).


Group Patterns
~~~~~~~~~~~~~~

Syntax:

  group_pattern: '(' pattern ')'

(For the syntax of ``pattern``, see Patterns above.)

A parenthesized pattern has no additional syntax.  It allows uses to
add parentheses around patterns to emphasize the intended grouping.


.. _sequence_pattern:

Sequence Patterns
~~~~~~~~~~~~~~~~~


Syntax::

  sequence_pattern:
    | '[' [values_pattern] ']'
    | '(' [value_pattern ',' [values_pattern]] ')'

(For ``values_pattern`` and ``value_pattern``, see Patterns above.)

(Note that a single parenthesized pattern without a trailing comma is
a group pattern, not a sequence pattern.)

A sequence pattern may (directly) contain at most one subpattern of
the form ``'*' NAME``; all other subpatterns must be walrus patterns,
OR patterns or closed patterns.

A sequence pattern fails if the subject value is not an instance of
``collections.abc.Sequence``.  It also fails if the subject value is
an instance of ``str``, ``bytes`` or ``bytearray``.

If the one of the subpatterns has the form ``'*' NAME``, this is
called a variable-length sequence pattern.  A variable-length sequence
pattern fails if the length of the subject sequence is less than the
number of subpatterns not of that form.

If no such subpattern is present, the sequence pattern is considered
fixed-length.  A fixed-length sequence pattern fails if the length of
the subject sequence is not equal to the number of subpatterns.

The length of the subject sequence is obtained using the builtin
``len()`` function (i.e., via the ``__len__`` protocol).  However, the
interpreter may cache this value in a similar manner as described for
constant value patterns.

TODO: Do we have left-to-right semantics here?

A fixed-length sequence pattern matches the subpatterns to
corresponding items of the subject sequence, from left to right.
Matching stops (with a failure) as soon as a subpattern fails.  If all
subpatterns succeed in matching their corresponding item, the sequence
pattern succeeds.

TODO: Describe variable-length sequence patterns.  (Brandt?)


.. _mapping_pattern:

Mapping Patterns
~~~~~~~~~~~~~~~~

Syntax::

  mapping_pattern: '{' items_pattern? '}'
  items_pattern: ','.key_value_pattern+ ','?
  key_value_pattern:
      | (literal_pattern | constant_pattern) ':' or_pattern
      | '**' (!"_" NAME)

(Note that ``'**' "_"`` is disallowed by this grammar.)

A mapping pattern fails if the subject value is not an instance of
``collections.abc.Mapping``.

A mapping pattern succeeds if every key given in the mapping pattern
matches the corresponding item of the subject mapping.  If a ``'**'
NAME`` form is present, that name is bound to a ``dict`` containing
remaining key-value pairs from the subject mapping.

If duplicate keys are detected in the mapping pattern, the pattern is
considered invalid, and a ``ValueError`` is raised.

TODO: Should we be more prescriptive about using ``in``?

Matched key-value pairs must already be present in the mapping, and
not created on-the-fly by ``__missing__`` or ``__getitem__``.  For
example, ``collections.defaultdict`` instances will only match
patterns with keys that were already present when the ``match`` block
was entered.  This may be implemented by using the ``in`` operator
(i.e., the ``__contains__`` protocol) before using ``__getitem__``.


.. _class_pattern:

Class Patterns
~~~~~~~~~~~~~~

Simplified syntax::

  class_pattern:
      | name_or_attr '(' ')'
      | name_or_attr '(' ','.pattern+ ','? ')'
      | name_or_attr '(' ','.keyword_pattern+ ','? ')'
      | name_or_attr '(' ','.pattern+ ',' ','.keyword_pattern+ ','? ')'
  keyword_pattern: NAME '=' or_pattern


A class pattern provides support for destructuring arbitrary objects.
There are two possible ways of matching on object attributes: by position
like ``Point(1, 2)``, and by name like ``Point(x=1, y=2)``. These
two can be combined, but a positional match cannot follow a match by name.
Each item in a class pattern can be an arbitrary pattern. A simple
example::

  match shape:
      case Point(x, y):
          ...
      case Rectangle(x0, y0, x1, y1, painted=True):
          ...

Whether a match succeeds or not is determined by the equivalent of an
``isinstance`` call.  If the subject (``shape``, in the example) is not
an instance of the named class (``Point`` or ``Rectangle``), the match
fails.  Otherwise, it continues (see details in the `runtime`_
section).

The named class must inherit from ``type``.  It may be a single name
or a dotted name (e.g. ``some_mod.SomeClass`` or ``mod.pkg.Class``).
The leading name must not be ``_``, so e.g. ``_(...)`` and
``_.C(...)`` are invalid. Use ``object(foo=_)`` to check whether the
matched object has an attribute ``foo``.

By default, sub-patterns may only be matched by keyword for
user-defined classes. In order to support positional sub-patterns, a
custom ``__match_args__`` attribute is required.
The runtime allows matching against
arbitrarily nested patterns by chaining all of the instance checks and
attribute lookups appropriately.


Combining multiple patterns (OR patterns)
-----------------------------------------

Multiple alternative patterns can be combined into one using ``|``. This means
the whole pattern matches if at least one alternative matches.
Alternatives are tried from left to right and have a short-circuit property,
subsequent patterns are not tried if one matched. Examples::

  match something:
      case 0 | 1 | 2:
          print("Small number")
      case [] | [_]:
          print("A short sequence")
      case str() | bytes():
          print("Something string-like")
      case _:
          print("Something else")

The alternatives may bind variables, as long as each alternative binds
the same set of variables (excluding ``_``).  For example::

  match something:
      case 1 | x:  # Error!
          ...
      case x | 1:  # Error!
          ...
      case one := [1] | two := [2]:  # Error!
          ...
      case Foo(arg=x) | Bar(arg=x):  # Valid, both arms bind 'x'
          ...
      case [x] | x:  # Valid, both arms bind 'x'
          ...


.. _guards:

Guards
------

Each *top-level* pattern can be followed by a **guard** of the form
``if expression``. A case clause succeeds if the pattern matches and the guard
evaluates to a true value. For example::

  match input:
      case [x, y] if x > MAX_INT and y > MAX_INT:
          print("Got a pair of large numbers")
      case x if x > MAX_INT:
          print("Got a large number")
      case [x, y] if x == y:
          print("Got equal items")
      case _:
          print("Not an outstanding input")

If evaluating a guard raises an exception, it is propagated onwards rather
than fail the case clause. Names that appear in a pattern are bound before the
guard succeeds. So this will work::

  values = [0]

  match values:
      case [x] if x:
          ...  # This is not executed
      case _:
          ...
  print(x)  # This will print "0"

Note that guards are not allowed for nested patterns, so that ``[x if x > 0]``
is a ``SyntaxError`` and ``1 | 2 if 3 | 4`` will be parsed as
``(1 | 2) if (3 | 4)``.


Walrus patterns
---------------

It is often useful to match a sub-pattern *and* bind the corresponding
value to a name. For example, it can be useful to write more efficient
matches, or simply to avoid repetition. To simplify such cases, any pattern
(other than the walrus pattern itself) can be preceded by a name and
the walrus operator (``:=``). For example::

  match get_shape():
      case Line(start := Point(x, y), end) if start == end:
          print(f"Zero length line at {x}, {y}")

The name on the left of the walrus operator can be used in a guard, in
the case block, or after the ``match`` statement.  However, the name will
*only* be bound if the sub-pattern succeeds.  Another example::

  match group_shapes():
      case [], [point := Point(x, y), *other]:
          print(f"Got {point} in the second group")
          process_coordinates(x, y)
          ...

Technically, most such examples can be rewritten using guards and/or nested
``match`` statements, but this will be less readable and/or will produce less
efficient code. Essentially, most of the arguments in PEP 572 apply here
equally.

The wildcard ``_`` is not a valid name here.


.. _runtime:

Runtime specification
=====================

The Match Protocol
------------------

The equivalent of an ``isinstance`` call is used to decide whether an
object matches a given class pattern and to extract the corresponding
attributes.  Classes requiring different matching semantics (such as
duck-typing) can do so by defining ``__instancecheck__`` (a
pre-existing metaclass hook) or by using ``typing.Protocol``.

The procedure is as following:

* The class object for ``Class`` in ``Class(<sub-patterns>)`` is
  looked up and ``isinstance(obj, Class)`` is called, where ``obj`` is
  the value being matched.  If false, the match fails.

* Otherwise, if any sub-patterns are given in the form of positional
  or keyword arguments, these are matched from left to right, as
  follows.  The match fails as soon as a sub-pattern fails; if all
  sub-patterns succeed, the overall class pattern match succeeds.

* If there are match-by-position items and the class has a
  ``__match_args__`` attribute, the item at position ``i``
  is matched against the value looked up by attribute
  ``__match_args__[i]``. For example, a pattern ``Point2d(5, 8)``,
  where ``Point2d.__match_args__ == ["x", "y"]``, is translated
  (approximately) into ``obj.x == 5 and obj.y == 8``.

* If there are more positional items than the length of
  ``__match_args__``, a ``TypeError`` is raised.

* If the ``__match_args__`` attribute is absent on the matched class,
  and one or more positional item appears in a match,
  ``TypeError`` is also raised. We don't fall back on
  using ``__slots__`` or ``__annotations__`` -- "In the face of ambiguity,
  refuse the temptation to guess."

* If there are any match-by-keyword items the keywords are looked up
  as attributes on the subject.  If the lookup succeeds the value is
  matched against the corresponding sub-pattern.  If the lookup fails,
  the match fails.

Such a protocol favors simplicity of implementation over flexibility and
performance. For other considered alternatives, see "extended matching".

For the most commonly-matched built-in types (``bool``,
``bytearray``, ``bytes``, ``dict``, ``float``,
``frozenset``, ``int``, ``list``, ``set``, ``str``, and ``tuple``), a
single positional sub-pattern is allowed to be passed to
the call. Rather than being matched against any particular attribute
on the subject, it is instead matched against the subject itself.  This
creates behavior that is useful and intuitive for these objects:

* ``int(0)`` matches ``0`` (but not ``0.0``).
* ``tuple((0, 1, 2))`` matches ``(0, 1, 2)`` (but not ``[0, 1, 2]``).
* ``float(f)`` matches any ``float`` and binds it to the name ``f``.


Overlapping sub-patterns
------------------------

Certain classes of overlapping matches are detected at
runtime and will raise exceptions. In addition to basic checks
described in the previous subsection:

* The interpreter will check that two match items are not targeting the same
  attribute, for example ``Point2d(1, 2, y=3)`` is an error.

* It will also check that a mapping pattern does not attempt to match
  the same key more than once.


Special attribute ``__match_args__``
------------------------------------

The ``__match_args__`` attribute is always looked up on the type
object named in the pattern.  If present, it must be a list or tuple
of strings naming the allowed positional arguments.

In deciding what names should be available for matching, the
recommended practice is that class patterns should be the mirror of
construction; that is, the set of available names and their types
should resemble the arguments to ``__init__()``.

Only match-by-name will work by default, and classes should define
``__match_args__`` as a class attribute if they would like to support
match-by-position.  Additionally, dataclasses and named tuples will
support match-by-position out of the box. See below for more details.

Exceptions and side effects
---------------------------

While matching each case, the ``match`` statement may trigger execution of other
functions (for example ``__getitem__()``, ``__len__()`` or
a property). Almost every exception caused by those propagates outside of the
``match`` statement normally. The only case where an exception is not propagated is
an ``AttributeError`` raised while trying to lookup an attribute while matching
attributes of a Class Pattern; that case results in just a matching failure,
and the rest of the statement proceeds normally.

The only side-effect carried on explicitly by the matching process is the binding of
names. However, the process relies on attribute access,
instance checks, ``len()``, equality and item access on the subject and some of
its components. It also evaluates constant value patterns and the left side of
class patterns. While none of those typically create any side-effects, some of
these objects could. This proposal intentionally leaves out any specification
of what methods are called or how many times. User code relying on that
behavior should be considered buggy.

The standard library
--------------------

To facilitate the use of pattern matching, several changes will be made to
the standard library:

* Namedtuples and dataclasses will have auto-generated ``__match_args__``.

* For dataclasses the order of attributes in the generated ``__match_args__``
  will be the same as the order of corresponding arguments in the generated
  ``__init__()`` method. This includes the situations where attributes are
  inherited from a superclass.

In addition, a systematic effort will be put into going through
existing standard library classes and adding ``__match_args__`` where
it looks beneficial.


.. _Appendix A:

Appendix A -- Full Grammar
==========================

Here is the full grammar for ``match_stmt``.  This is an additional
alternative for ``compound_stmt``.  Remember that ``match`` and
``case`` are soft keywords, i.e. they are not reserved words in other
grammatical contexts (including at the start of a line if there is no
colon where expected).  By convention, hard keywords use single quotes
while soft keywords use double quotes.

Other notation used beyond standard EBNF:

- ``SEP.RULE+`` is shorthand for ``RULE (SEP RULE)*``
- ``!RULE`` is a negative lookahead assertion

::

  match_stmt: "match" match_expr ':' NEWLINE INDENT case_block+ DEDENT
  match_expr:
      | star_named_expression ',' star_named_expressions?
      | named_expression
  case_block: "case" patterns [guard] ':' block
  guard: 'if' named_expression

  patterns: value_pattern ',' [values_pattern] | pattern
  pattern: walrus_pattern | or_pattern
  walrus_pattern: NAME ':=' or_pattern
  or_pattern: '|'.closed_pattern+
  closed_pattern:
      | literal_pattern
      | capture_pattern
      | wildcard_pattern
      | constant_pattern
      | group_pattern
      | sequence_pattern
      | mapping_pattern
      | class_pattern
  values_pattern: ','.value_pattern+ ','?
  value_pattern: '*' capture_pattern | pattern

  literal_pattern:
      | signed_number !('+' | '-')
      | signed_number '+' NUMBER
      | signed_number '-' NUMBER
      | strings
      | 'None'
      | 'True'
      | 'False'
  signed_number: NUMBER | '-' NUMBER

  capture_pattern: !"_" NAME !('.' | '(' | '=')

  wildcard_pattern: "_"

  constant_pattern: attr !('.' | '(' | '=')
  attr: name_or_attr '.' NAME
  name_or_attr: attr | NAME

  group_pattern: '(' patterns ')'

  sequence_pattern: '[' [values_pattern] ']' | '(' ')'

  mapping_pattern: '{' items_pattern? '}'
  items_pattern: ','.key_value_pattern+ ','?
  key_value_pattern:
      | (literal_pattern | constant_pattern) ':' or_pattern
      | '**' capture_pattern

  class_pattern:
      | name_or_attr '(' ')'
      | name_or_attr '(' ','.pattern+ ','? ')'
      | name_or_attr '(' ','.keyword_pattern+ ','? ')'
      | name_or_attr '(' ','.pattern+ ',' ','.keyword_pattern+ ','? ')'
  keyword_pattern: NAME '=' or_pattern


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
