PEP: 657
Title: Specializing Adaptive Interpreter
Author: Mark Shannon <mark@hotpy.org>
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 13-Apr-2021
Post-History: 11-May-2021


Abstract
========

In order to perform well, virtual machines for dynamic languages must specialize the code that they execute 
to the types and values in the program being run.
This specialization is often associated with "JIT" compilers, but is beneficial even without machine code generation.

A specializing, adaptive interpeter is one that speculatively specializes on the types or values it is currently operating on,
and adapts to changes in those types and values.

Specialization gives us improved performance, and adaptation allows the interpreter to rapidly change when the pattern of usage in a program alters,
limiting the amount of additional work caused by mis-specialization.

This PEP proposes using a specializing, adaptive interpreter that specializes code aggressively, but over a very small region,
and is able to adjust to mis-specialization rapidly and at low cost.

Adding a specializing, adaptive interpeter to CPython will bring significant performance improvements:
  * At least 30% from specialization, maybe as high as 50%.
  * Further increases in the benefits of other optimizations, as they can exploit, or be exploited by specialization.

Motivation
==========

Python is widely acknowledged as slow.
Whilst Python will never attain the performance of low-level langauges like C, Fortran, or even Java,
we would like it to be competitive with fast implementations of scripting languages, like V8 for Javascript or luajit for lua.
Specifically, we want to achieve these performance goals with CPython to benefit all users of Python
including those unable to use PyPy or other alternative virtual machines.

Achieving these performance goals is a long way off, and will require a lot of engineering effort,
but we can make a significant step towards those goals by speeding up the interpreter.
Both academic research and practical implementations have shown that a fast interpreter is a key part of a fast virtual machine.

Typical optimizations for virtual machines are expensive, so a long "warm up" time is required 
to gain confidence that the cost of optimization is justified.
In order to get speed-ups rapidly, without noticable warmup times,
we speculate that specialization is justified even after a few executions of a function.
To do that, the interpreter must be able to optimize and de-optimize continually and very cheaply.

By using adaptive and speculative specialization at the granularity of individual virtual machine instructions, we get a faster
interpeter that also generates profiling information for more sophisticated optimizations in the future.

Rationale
=========

There are many pratical ways to speed-up a virtual machine for a dynamic language.
However, specialization is the most important, both in itself and as an enabler of other optimizations.
Therefore it makes sense to focus our efforts on specialization first, if we want to improve the performance of CPython.

Specialization is typically done in the context of a JIT compiler, but research shows specialization in an interpeter
can boost performance significantly, even outperforming a naive compiler [1]_.

There have been several ways of doing this proposed in the academic literature,
but most attempt to optimize regions larger than a single bytecode [1]_ [2]_.
Using larger regions than a single instruction, requires code to handle deoptimization in the middle of a region.
Specialization at the level on individual bytecodes makes deoptimization trivial, as it cannot occur in the middle of a region.

By speculatively specializing individual bytecodes, we can gain significant performance improvements without anything but the most local,
and trivial to implement, de-optimizations.

The closest approach to this PEP in the literature is "Inline Caching meets Quickening" [3]_.
This PEP has the advantages of inline caching, but adds the ability to quickly de-optimize making the performance
more robust in cases where specialization fails or is not stable.

Implementation
==============

Overview
--------

Once any instruction in a code object has executed a few times, that code object will be "quickened" by allocating a new array
for the bytecode that can be modified at runtime, and is not constrained as the `code.co_code` object is.
From that point onwards, whenever any instruction in that code object is executed, it will use the quickened form.

Any instruction that would benefit from specialization will be replaced by an "adaptive" form of that instruction.
When executed, the adaptive instructions will specialize themselves in response to the types and values that they see.

Quickening
----------

Quickening is the process of replacing slow instructions with faster variants.

Quickened code has number of advantages over the normal bytecode:

* It can be changed at runtime
* It can use super-instructions that span lines and take multiple operands.
* It does not need to handle tracing as it can fallback to the normal bytecode for that.

In order that tracing can supported, and quickening performed quickly, the quickened instruction format should match the normal
bytecode format: 16-bit instructions of 8-bit opcode followed by 8-bit operand.

Adaptive instructions
---------------------

Each instruction that would benefit from specialization is replaced by an adaptive version during quickening.
For example, the ``LOAD_ATTR`` instruction would be replaced with ``LOAD_ATTR_ADAPTIVE``.

Each adaptive instruction maintains a counter, and periodically attempts to specialize itself.

Specialization
--------------

CPython bytecode contains many bytecodes that represent high-level operations, and would benefit from specialization.
Examples include ``CALL_FUNCTION``, ``LOAD_ATTR``, ``LOAD_GLOBAL`` and ``BINARY_ADD``.

By introducing a "family" of specialized instructions for each of these instructions allows effective specialization,
since each new instruction is specialized to a single task.
Each family will include an "adaptive" instruction, that maintains a counter and periodically attempts to specialize itself.
Each family will also include one or more specialized instructions that perform the equivalent
of the generic operation much faster provided their inputs are as expected.
Each specialized instruction will maintain a saturating counter which will be incremented whenever the inputs are as expected.
Should the inputs not be as expected, the counter will be decremented and the generic operation will be performed.
If the counter reaches the minimum value, the instruction is de-optimized by simply replacing its opcode with the adaptive version.

Ancillary data
--------------

Most families of specialized instructions will require more information than can fit in an 8-bit operand.
To do this, an array of specialization data entries will be maintained alongside the new instruction array.
For instructions that need specialization data, the operand in the quickened array will serve as a partial index, 
along with the offset of the instruction, to find the first specialization data entry for that instruction.

Data layout
-----------

Quickened instructions will be stored in an array (it is neither necessary not desirable to store them in a Python object) with the same
format as the original bytecode. Ancillary data will be stored in a separate array.
Experiments show that approximately 1 in 4 instructions can be usefully specialized. Some instruction families need more data than others,
so it makes sense to allow each instruction between 1 and 3 entries. Assuming an average of 2 that means we need approximately half as many data
entries as instructions. 

In order to support larger functions than 256 instructions, we compute the offset of the first data entry for instructions
as ``(instruction offset)//2 + (quickened operand)``.
If the number of data entries per instruction is less than 50% we waste a little space.
As long as the ratio does not exceed 55%, code objects of up to about 5000 instructions can be quickened.


Example families of instructions
--------------------------------

CALL_FUNCTION
'''''''''''''

The ``CALL_FUNCTION`` instruction calls the (N+1)th item on the stack with top N items on the stack as arguments.

This is an obvious candidate for specialization. For example, the call in ``len(x)`` is repesented as the bytecode ``CALL_FUNCTION 1``.
In this case we would always expect the object ``len`` to be the function. We probably don't want to specialize for ``len``
(although we might for ``type`` and ``isinstance``), but it would be beneficial to specialize for builtin functions taking a single argument.
A fast check that the underlying function is a builtin function taking a single argument (``METHOD_O``) would allow use to avoid a
sequence of checks for number of parameters and keyword arguments.

``CALL_FUNCTION_ADAPTIVE`` would track how often it is executed, and call the ``call_function_optimize`` when executed enough times, or jump
to ``CALL_FUNCTION`` otherwise.
When optimizing, the kind of the function would be checked and if a suitable specialized instruction was found,
it would replace ``CALL_FUNCTION_ADAPTIVE`` in place.

Specializations might include:
  * ``CALL_FUNCTION_PY_SIMPLE``: Calls to Python functions with exactly matching parameters.
  * ``CALL_FUNCTION_PY_DEFAULTS``: Calls to Python functions with more parameters and default values.
    Since the exact number of defaults needed is known, the instruction needs to do no additional checking or computation; just copy some defaults.
  * ``CALL_BUILTIN_O``: The example given above for calling builtin methods taking exactly one argument.
  * ``CALL_BUILTIN_VECTOR``: For calling builtin function taking vector arguments.

Note how this allows optimizations that complement other optimizations.
For example, if the Python and C call stacks were decoupled and the data stack were contiguous,
then Python-to-Python calls could be made very fast.

LOAD_GLOBAL
'''''''''''

The ``LOAD_GLOBAL`` instruction looks up a name in the global namespace and then, if not present in the global namespace,
looks it up in the builtins namespace.
In 3.9 the C code for the ``LOAD_GLOBAL`` includes code to check to see whether the whole code object should be modified to add a cache,
whether either the global or builtins namespace, code to lookup the value in a cache, and fallback code.
This makes it complicated and bulky. It also performs many redundant operations even when supposedly optimized.

Using a family of instructions makes the code more maintainable and faster, as each instruction only needs to handle one concern.

Specializations would include:
  * ``LOAD_GLOBAL_ADAPTIVE`` would operate like ``CALL_FUNCTION_ADAPTIVE`` above.
  * ``LOAD_GLOBAL_MODULE`` can be specialized for the case where the value is in the globals namespace.
    After checking that the keys of the namespace have not changed, it can load the value from the stored index.
  * ``LOAD_GLOBAL_BUILTIN``  can be specialized for the case where the value is in the builtins namespace.
    It needs to check that the keys of the global namespace have not been added to, and that the builtins namespace has not changed.
    Note that we don't care if the values of the global namespace have changed, just the keys.


Compatibility
=============

There will no change to the language, library or API.

The only way that users will be able to detect the presence of the new interpeter is through timing execution, the use of debugging tools,
or measuring memory use.


Security Implications
=====================

None


Rejected Ideas
==============

Too many to list.


References
==========

.. [1] The construction of high-performance virtual machines for dynamic languages, Mark Shannon 2010.
  http://theses.gla.ac.uk/2975/1/2011shannonphd.pdf

.. [2] Dynamic Interpretation for Dynamic Scripting Languages
  https://www.scss.tcd.ie/publications/tech-reports/reports.09/TCD-CS-2009-37.pdf

.. [3] Inline Caching meets Quickening
  http://www.complang.tuwien.ac.at/kps09/pdfs/brunthaler.pdf

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
    Local Variables:
    mode: indented-text
    indent-tabs-mode: nil
    sentence-end-double-space: t
    fill-column: 70
    coding: utf-8
    End:
